name: Trinity
scopeName: source.dart
fileTypes: [dart, trin]
patterns: [include: "#core"]

Information for Contributors: |
  This is the grammar for the Trinity programming language. The grammar
  is about 80% complete though there still need to be some fixes.

  Should you want to provide a fix improvement, or perhaps to
  change or add a new feature, or even some general constructive
  feedback, make a pull request, or an issue on this very repository,
  and I will be very happy to receive it/them.

  Go visit my Trello to find out what I'm working on:
  https://trello.com/b/A3NDX7qY/trinity-language

  Some parts such as numeric literals, HTML character entities and more
  are partially or entirely generated through code by means of compressed
  tries and DFA minimization (Brzozowski algorithm).

comment: |
  To-Do:
  - Add route blocks

  Done:
  - Changed from indentation to curly bracket syntax
  - Map/set syntax should only activate next to an opening bracket, or
    non-suffix operator
  - Freed backslash to be an operator character
  - Added support for dashed identifiers, to support Lisp/train case
    - Fixed highlighting of "S-1" scenario, where a dash would only
      highlight the first word
  - Removed unquoted strings, especially YAML ones
  - Added CSS keyword and function properties
  - Reworked JSX syntax
  - Reworked format directives and embedded expressions, with a little
    help from recursion
  - Reworked number literals
  - Revamped JSX literals following

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.3n}
    2: {name: punctuation.separator.decimal.period.3n}
    3: {name: punctuation.separator.decimal.fraction.3n}
    4: {name: constant.numeric.other.exponent.3n}
    5: {name: constant.numeric.other.density.3n}
    6: {name: storage.type.numeric.3n}

  entity-name-clause: &entity-name-clause |
    (?x)\s*\b
    (?<=(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:ext|impl)\b|\s*[<>]\s+)\s*

    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|new|to|til|thru|by|del|unset
    |var|val|let|const|decl|def|func|type|object
    |class|enum|module|pack|struct|inter|space|pragma
    |proc|proto|macro|given|style|elem|field
    |ext|pred|data|trait|lemma|iter|sub|prop
    |if|un|elif|elun|else|then
    |for|each|loop|while|until|when
    |with|do|from
    |try|throw|catch|final
    |switch|match|case|fail
    |race|some|every|done|spawn|kill|lock
    |break|next|redo|retry|return|await|label|yield|goto|pass
    |import|export|using
    |debug|assert|where
    )(?![\w\p{Pd}])
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|new|to|til|thru|by|del|unset
    |var|val|let|const|decl|def|func|type|object
    |class|enum|module|pack|struct|inter|space|pragma
    |proc|proto|macro|given|style|elem|field
    |ext|pred|data|trait|lemma|iter|sub|prop
    |if|un|elif|elun|else|then
    |for|each|loop|while|until|when
    |with|do|from
    |try|throw|catch|final
    |switch|match|case|fail
    |race|some|every|done|spawn|kill|lock
    |break|next|redo|retry|return|await|label|yield|goto|pass
    |import|export|using
    |debug|assert|where
    )(?![\w\p{Pd}])
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

repository:
  core:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  everything-but-comments:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.other.3n
      - match: '[\w]+?'
        name: invalid.illegal.variable.other.3n
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.3n
      - match: \S+?
        name: invalid.illegal.syntax.3n

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|func|type|object
      |class|enum|module|pack|struct|inter|space|pragma
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|final
      |switch|match|case|fail
      |race|some|every|done|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )(?![\w\p{Pd}])\s*
    name: invalid.illegal.keyword.3n

  # Support

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|Nat)
          |Imaginary|Complex|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          )(?![\w\p{Pd}])
        name: support.type.builtin.primitive.3n
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map|Bag)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          )(?![\w\p{Pd}])
        name: support.type.builtin.3n
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit
          |Any|Mixed|Just|Some|None|Never|Const|(Im)?pure
          |Class|Enum|module|Pkg|Inter|Struct|Obj|Rec
          |Frag|Nspace|Data|Trait|Proto|Proc|Macro|Type|Given
          |Raw|Style|Comp|Elem|Decl|Ext|Impl|Sub|Chan
          )(?![\w\p{Pd}])
        name: support.type.primitive.3n

      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)\b
        name: entity.name.interface.3n
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)\b
        name: entity.name.namespace.3n
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.3n
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able\b
        name: support.class.trait.3n

      - comment: Swift
      - include: source.swift#builtin-types
      - comment: Python
      - include: source.python#builtin-types
      - comment: JS
      - include: "#support-js"
      - comment: PHP
      - include: source.php#class-builtin

  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.3n
      - comment: magic functions
        match: (?x)\s*\b_+([\p{Pc}\p{L}][\w\p{Pd}]*)+_+\b\s*
        name: support.function.magic.3n
      - comment: Swift
      - include: source.swift#builtin-functions
      - comment: JavaScript
      - include: source.js#support-objects
      - comment: Python
      - include: source.python#builtin-functions
      - comment: PHP
      - include: source.php#support
      - comment: SASS
      - include: source.css.sass#constant_sass_functions
      - comment: Other (coming soon!)
      - match: |
          (?x)\b(?:
          (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          |
          (?:# Objects and maps
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
          |
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.3n}
          2: {name: entity.name.tag.3n support.class.component.3n}
          3: {name: entity.name.class.builtin.3n}
          4: {name: entity.name.function.method.3n}
          5: {name: variable.other.global.3n}
          6: {name: variable.other.constant.object.3n}
          7: {name: variable.other.conditional.3n}
          8: {name: variable.other.object.3n}
          9: {name: entity.name.function.tagged-template.3n}
          10: {name: entity.name.type.3n}
          11: {name: entity.name.class.3n}
          12: {name: entity.name.function.3n}
      - include: $self

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns:
      - comment: Python
      - include: source.python#magic-variable-names

  variable-names:
    comment: Standard Library variable names
    patterns:
      - comment: Python
      - include: source.python#magic-function-names

  property-names:
    comment: Standard Library property names
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )(?![\w\p{Pd}])\s*
        captures:
          1: {name: constant.language.boolean.true.3n}
          2: {name: constant.language.boolean.false.3n}
          3: {name: constant.language.null.3n}
          4: {name: constant.language.undefined.3n}
          5: {name: constant.language.nan.3n}
          6: {name: constant.language.infinity.3n}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (it|this|that|super|self|target)#1
          |(params)#2
          |(ctor)#3
          |(prot)#4
          |(pro)#5
          )(?![\w\p{Pd}])\s*
        captures:
          1: {name: variable.language.$1.3n}
          2: {name: variable.language.arguments.3n}
          3: {name: variable.language.constructor.3n}
          4: {name: variable.language.prototype.3n}
          5: {name: variable.language.proto.3n}

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.3n
      - match: (?<=(^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.3n
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix/base prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# integer & numerator part
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional part
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?|# repeating part
          (\/)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?# integer/numerator
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0b)# radix/base prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)# integer & numerator part
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional part
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?|# repeating part
          (\/)(?:[01]+(?:\p{Pc}*[01]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0b)# radix prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)?# integer/numerator
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0q)# radix/base prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional part
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?|# repeating part
          (\/)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0q)# radix prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0s)# radix/base prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional part
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?|# repeating part
          (\/)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0s)# radix prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0o)# radix/base prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional part
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?|# repeating part
          (\/)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0o)# radix prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0z)# radix/base prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)# integer & numerator part
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional part
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?|# repeating part
          (\/)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0z)# radix prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)?# integer/numerator
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0x)# radix/base prefix
          (?:\h+(?:\p{Pc}*\h+)*)# integer & numerator part
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional part
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?|# repeating part
          (\/)(?:\h+(?:\p{Pc}*\h+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (0x)# radix prefix
          (?:\h+(?:\p{Pc}*\h+)*)?# integer/numerator
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          ()# radix/base prefix
          (?:\d+(?:\p{Pc}*\d+)*)# integer & numerator part
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional part
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?|# repeating part
          (\/)(?:\d+(?:\p{Pc}*\d+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          ()# radix prefix
          (?:\d+(?:\p{Pc}*\d+)*)?# integer/numerator
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix/base prefix
          (?:\w+(?:\p{Pc}*\w+)*)# integer & numerator part
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional part
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?|# repeating part
          (\/)(?:\w+(?:\p{Pc}*\w+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix prefix
          (?:\w+(?:\p{Pc}*\w+)*)?# integer/numerator
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.3n}
          1: {name: storage.type.numeric.3n}
          2: {name: punctuation.separator.decimal.period.3n}
          3: {name: punctuation.separator.decimal.repeating.3n}
          4: {name: punctuation.separator.decimal.fraction.3n}
          5: {name: constant.numeric.other.exponent.3n}
          6: {name: constant.numeric.other.precision.3n}
          7: {name: storage.type.numeric.3n}

  strings-quoted:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.3n
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - include: "#embedded-raw"
      - comment: single quoted string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.3n
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - match: "''"
            name: constant.character.escape.3n
          - include: "#embedded-raw"
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.3n
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - include: "#string-content"
      - comment: double quoted string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.3n
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - include: "#string-content"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: (?ix)\\b[01]{1,21}
        name: constant.character.escape.binary.3n
      - comment: Binary escape sequences
        begin: (?ix)\\b{
        end: \s*}
        name: constant.character.escape.binary.3n
        patterns:
          - match: \b[01]{1,21}\b
            name: constant.character.escape.binary.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Quaternary escape sequences
        match: (?ix)\\q[0-3]{1,11}
        name: constant.character.escape.quaternary.3n
      - comment: Quaternary escape sequences
        begin: (?ix)\\q{
        end: \s*}
        name: constant.character.escape.quaternary.3n
        patterns:
          - match: \b[0-3]{1,11}\b
            name: constant.character.escape.quaternary.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Senary escape sequences
        match: (?ix)\\s[0-5]{1,8}
        name: constant.character.escape.senary.3n
      - comment: Senary escape sequences
        begin: (?ix)\\s{
        end: \s*}
        name: constant.character.escape.senary.3n
        patterns:
          - match: \b[0-5]{1,8}\b
            name: constant.character.escape.senary.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Octal escape sequences
        match: (?ix)\\o[0-7]{1,7}
        name: constant.character.escape.octal.3n
      - comment: Octal escape sequences
        begin: (?ix)\\o{
        end: \s*}
        name: constant.character.escape.octal.3n
        patterns:
          - match: \b[0-7]{1,7}\b
            name: constant.character.escape.octal.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Decimal escape sequences
        match: (?ix)\\d?\d{1,7}
        name: constant.character.escape.decimal.3n
      - comment: Decimal escape sequences
        begin: (?ix)\\d{
        end: \s*}
        name: constant.character.escape.decimal.3n
        patterns:
          - match: \b\d{1,7}\b
            name: constant.character.escape.decimal.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Duodecimal escape sequences
        match: (?ix)\\z[\dab]{1,6}
        name: constant.character.escape.duodecimal.3n
      - comment: Duodecimal escape sequences
        begin: (?ix)\\z{
        end: \s*}
        name: constant.character.escape.duodecimal.3n
        patterns:
          - match: \b[\dab]{1,6}\b
            name: constant.character.escape.duodecimal.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n
      - comment: Hexadecimal escape sequences
        match: (?ix)\\[ux]\h{1,6}
        name: constant.character.escape.hexadecimal.3n
      - comment: Hexadecimal escape sequences
        begin: (?ix)\\[ux]{
        end: \s*}
        name: constant.character.escape.hexadecimal.3n
        patterns:
          - match: \b\h{1,6}\b
            name: constant.character.escape.hexadecimal.3n
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.3n

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.3n
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.3n
        patterns:
          - include: "#named-char-notation"
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.3n
      - match: (?i)\\[a-z]
        name: constant.character.escape.3n
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.3n
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.3n
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.3n

  embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.3n
        captures:
          1: {name: punctuation.section.embedded.3n}
        patterns: [include: $self]
      - match: |
          (?x)(\$)
          (\b[\p{Pc}\p{L}]
          (?<expr>
          # Recursive brackets
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>["`])[^\\.]*\g<q2>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.3n}
          2: {patterns: [include: "#everything-but-comments"]}

  format-specifier:
    match: |
      (?x)(%)
      (
      (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
      (
      (?<sw>
      /\g<ident>
      (?<val>:
      (?<expr>
      # Recursive brackets
      (?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      (?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>["`])[^\\.]*\g<q2>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Everything nice
      ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
      )
      )?
      )*
      )?
      )
    captures:
      1: {name: punctuation.definition.directive.3n}
      2:
        name: storage.type.format.3n
        patterns:
          - include: "#format-language"
          - match: .+
            name: string.other.format.3n

  embedded-placeholder:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.3n}
          2: {name: constant.numeric.decimal.3n}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.anchor.3n}
          2: {patterns: [include: "#placeholder-variables"]}
      - begin: (\#{)\s*
        end: (})
        name: entity.quasi.element.3n
        captures:
          1: {name: punctuation.definition.anchor.3n}
        patterns:
          - include: "#placeholder-variables"
          - include: $self

  embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"

  embedded-raw:
    patterns:
      - match: \$\$|\%\%\|#\#
        name: constant.character.escape.3n
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"

  # Format Specifier Language

  format-language:
    comment: Grammar for Trinity's format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: type specifier
        match: (?<=[^\\%]%)\w+
        name: entity.other.attribute-name.3n
      - comment: Format switch with value /x:24
        applyEndPatternLast: 1
        begin: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)(:)
        beginCaptures:
          1: {name: punctuation.separator.mapping.3n}
          2: {name: entity.other.attribute-name.class.3n}
          3: {name: punctuation.separator.key-value.3n}
        end: (?=.)|$
        patterns: [include: "#html-properties"]
      - comment: Format switch without value
        match: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.separator.mapping.3n}
          2: {name: entity.other.attribute-name.id.3n}

  # Unicode Named Character Language

  named-char-notation:
    comment: Grammar for the Unicode Named Character Mini-Language.
    repository:
      character-names:
        patterns:
          - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
            name: entity.name.tag.namespace.3n
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            name: entity.name.tag.3n
          - match: ":"
            name: punctuation.separator.namespace.3n
          - match: \.
            name: punctuation.accessor.3n
      latex-notation:
        patterns:
          - name: comment.line.math.3n
            match: (%)(.+)$
            captures:
              1: {name: punctuation.definition.comment.math.3n}
          - name: line.separator.math.3n
            match: (\\\\)$
            captures:
              1: {name: punctuation.line.separator.math.3n}
          - name: meta.function.math.3n
            begin: ((\\)([\p{Pc}\p{L}][\w\p{Pd}]*))(\{)
            beginCaptures:
              1: {name: storage.type.function.math.3n}
              2: {name: punctuation.definition.function.math.3n}
              3: {name: entity.name.function.math.3n}
              4: {name: punctuation.definition.arguments.begin.math.3n}
            end: \}
            endCaptures:
              0: {name: punctuation.definition.arguments.end.math.3n}
            patterns:
              - include: "#named-char-notation"
          - captures:
              1: {name: punctuation.definition.constant.math.3n}
            match: (\\)([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: constant.character.math.3n
          - captures:
              1: {name: punctuation.definition.constant.math.3n}
            match: (\\)(?!begin\{|verb)([\p{Pc}\p{L}][\w\p{Pd}]*)
            name: constant.other.general.math.3n
          - match: (?<!\\)\{
            name: meta.brace.curly.3n
          - match: (?<!\\)\}
            name: meta.brace.curly.3n
          - match: \(
            name: meta.brace.round.3n
          - match: \)
            name: meta.brace.round.3n
          - match: (([0-9]*[\.][0-9]+)|[0-9]+)
            name: constant.numeric.math.3n
          - match: "[-+*/^]"
            name: punctuation.math.operator.latex
    patterns:
      - include: "#character-names"
      - include: "#latex-notation"
      - include: "#regexp-patterns"

  # Symbols

  symbols:
    patterns:
      - match: \s*(:)(?=['"])
        name: punctuation.definition.symbol.3n
      - begin: \s*(:)(\w|\\.)
        beginCaptures:
          1: {name: punctuation.definition.symbol.3n}
          2: {name: constant.other.symbol.3n}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/|::|!:|\?:|\.|!\.|\?\.)
        name: constant.other.symbol.3n
        patterns:
          - include: "#string-content"

  # Regular expressions

  regexps:
    patterns:
      - comment: Replacement section
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        contentName: string.replace.regexp.3n
        captures:
          1: {name: punctuation.section.regexp.end.3n}
          2: {name: keyword.other.flag.3n}
        patterns:
          - include: "#back-references"
          - include: "#string-content"
      - comment: Pattern section
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        contentName: string.pattern.regexp.3n
        beginCaptures:
          1: {name: keyword.modifier.3n}
          2: {name: punctuation.section.regexp.begin.3n}
        endCaptures:
          1: {name: punctuation.section.regexp.end.3n}
          2: {name: keyword.other.flag.3n}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"

  back-references:
    patterns:
      - match: \$(\d+|[&+-])
        name: keyword.other.back-reference.3n
      - match: \${2}
        name: constant.character.escape.3n
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.3n
        captures:
          1: {name: keyword.other.back-reference.3n}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.3n
        captures:
          1: {name: keyword.other.back-reference.3n}
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.3n
      - match: \&
        name: keyword.operator.compose.3n
      - match: \.
        name: constant.character.all.3n
      - match: \\[mM]({[\w\s]+})?
        name: keyword.control.anchor.3n
      - match: \$|\\[yYzZ]({[\w\s]+})?
        name: keyword.control.end.3n}
      - match: \^|\\[AbB]({[\w\s]+})?
        name: keyword.control.begin.3n
      - match: \\K
        name: keyword.control.keepout.3n
      - match: \\G
        name: keyword.control.search.3n
      - match: \\R
        name: constant.character.control.3n
      - match: \\[XO]
        name: constant.character.unicode.3n
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.3n}
          2: {name: keyword.operator.quantifier.lazy.3n}
          3: {name: keyword.operator.quantifier.eager.3n}
          4: {name: keyword.operator.quantifier.greedy.3n}
      - match: \\\d+
        name: keyword.other.back-reference.3n
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.3n
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.3n
        captures:
          1: {name: keyword.other.back-reference.3n}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.3n
        captures:
          1: {name: keyword.other.subroutine.3n}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.back-reference.3n
        captures:
          1: {name: keyword.other.back-reference.3n}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.subroutine.3n
        captures:
          1: {name: keyword.other.subroutine.3n}
        patterns: *regex-back-references
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.3n}
          2: {name: keyword.operator.modifier.eager.3n}
          3: {name: keyword.operator.modifier.greedy.3n}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.3n}
          2: {name: keyword.operator.quantifier.eager.3n}
          3: {name: keyword.operator.quantifier.greedy.3n}
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: \\.
        name: constant.character.escape.other.3n

  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(([*+])
        end: \s*(\))
        name: constant.other.pcre.3n
        captures:
          0: {name: punctuation.section.expression.3n}
        patterns:
          - include: $self
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.3n
        end: \s*(\))
        name: comment.block.regexp.3n
        captures:
          1: {name: punctuation.definition.comment.3n}
        patterns:
          - match: \\.
            name: comment.block.regexp.3n
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.3n
        captures:
          1: {name: punctuation.definition.group.look-ahead.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.3n
        captures:
          1: {name: punctuation.definition.group.look-behind.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.3n
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.3n
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Match directive
        begin: |
          (?x)(\(\?%)
          (
          (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (
          (?<sw>
          /\g<ident>
          (?<val>:
          (?<expr>
          # Recursive brackets
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>["`])[^\\.]*\g<q2>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Everything nice
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )
          )?
          )*
          )?
          )
        captures:
          1: {name: punctuation.definition.directive.3n}
          2:
            name: storage.type.format.3n
            patterns:
              - include: "#format-language"
              - match: .+
                name: string.other.format.3n
        end: \s*(\))
        name: meta.group.directive.3n
        patterns: [include: "#regexp-patterns"]
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.3n
        captures:
          1: {name: punctuation.definition.group.longest.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.3n
        captures:
          0: {name: punctuation.definition.group.flag.3n}
          1: {name: punctuation.definition.group.flag.3n}
          2: {name: constant.numeric.index.3n}
          3: {name: keyword.control.recursion.3n}
          4: {name: keyword.other.flag.3n}
          5: {name: punctuation.separator.colon.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.3n
        captures:
          1: {name: punctuation.definition.group.call-out.3n}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.3n
            captures:
              1: {name: punctuation.definition.group.call-out.3n}
              2: {name: keyword.operator.range.3n}
              3: {name: punctuation.definition.tag.3n}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.3n}
            patterns:
              - include: $self
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.3n
        captures:
          1: {name: punctuation.definition.group.atomic.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.3n
        captures:
          1: {name: punctuation.definition.group.non-capturing.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.3n
        captures:
          1: {name: punctuation.definition.group.branch.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.3n
        captures:
          1: {name: punctuation.definition.group.absent.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.3n
        captures:
          0: {name: punctuation.definition.group.back-reference.3n}
          1: {name: punctuation.definition.group.back-reference.3n}
          2: {name: constant.numeric.index.3n}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.3n}
        patterns: [include: "#regexp-patterns"]
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.3n
        captures:
          0: {name: punctuation.definition.group.named.3n}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.3n
            captures:
              1: {name: punctuation.definition.group.named.3n}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.3n
        captures:
          0: {name: punctuation.definition.group.named.3n}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|'|")
            end: \s*(\1)
            name: constant.other.group.3n
            captures:
              1: {name: punctuation.definition.group.named.3n}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.3n
        captures:
          1: {name: punctuation.definition.group.3n}
        patterns: [include: "#regexp-patterns"]

  regexp-char-class:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.3n
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.3n
        patterns:
          - include: "#attribute-selectors"
      - begin: \\j{
        end: \s*}
        name: constant.character.entity.named.3n
        patterns:
          - include: "#named-char-notation"
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.3n
      - match: (?i)\\p(\w\w?)
        name: constant.other.character-class.unicode.3n
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.3n
      - match: (?x)\\[a-z]
        name: constant.other.character-class.3n
      - match: (?x)\\[A-Z]
        name: constant.other.character-class.negated.3n
      - match: (?i)\\n{[\w\s\p{Pd}]+}
        name: constant.character.escape.unicode.name.3n
      - match: (?i)\\[\p{L}\p{N}]
        name: constant.character.escape.3n
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.3n
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.3n
      - match: (?x)\\\p{C}
        name: invalid.illegal.unknown-escape.3n
      - include: "#embedded"

  regexp-char-ops:
    patterns:
      - match: (?<!\|)\|\|(?!\|)
        name: keyword.operator.union.3n
      - match: (?<!&)&&(?!&)
        name: keyword.operator.intersection.3n
      - match: (?<!\^)\^\^(?!\^)
        name: keyword.operator.symmetric.3n
      - match: (?<!~)~~(?!~)
        name: keyword.operator.negation.3n
      - match: (?<!-)--(?!-)
        name: keyword.operator.difference.3n
      - match: (?<![^\\][\\\[])-(?![-\[\]])
        name: keyword.operator.range.3n
      - match: ([^-\\\[\]]|\\.)(?<!-+)(?=(?<!\\)-)
        name: constant.other.character-class.range.from.3n
      - match: (?<=[^\\]-)(?!-+)([^-\\\[\]]|\\.)
        name: constant.other.character-class.range.to.3n
      - match: \\.
        name: constant.character.escape.other.3n

  regexp-char-set:
    patterns:
      - begin: (\[[.:=])
        end: (\])
        name: constant.other.character-class.posix.3n
        captures:
          1: {name: punctuation.definition.character-class.posix.3n}
        patterns: [include: "#attribute-selectors"]
      - begin: (\[[!^])
        end: (\])
        name: constant.other.character-class.negated.3n
        captures:
          1: {name: punctuation.definition.character-class.negated.3n}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"
      - begin: (\[)
        end: (\])
        name: constant.other.character-class.3n
        captures:
          1: {name: punctuation.definition.character-class.3n}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"

  attribute-selectors:
    patterns:
      - match: ","
        name: punctuation.separator.sequence.3n
      - include: "#comments"
      - include: "#strings-quoted"
      - match: (?xi)\b[is]\b(?=\)|\]|\}|&&|\|\||\^\^)
        name: storage.modifier.ignore-case.3n
      - include: "#string-escapes"
      - match: "[.:=!</>^$%?*+]?="
        name: keyword.operator.pattern.3n
      - match: ([&|^])\1|!
        name: keyword.operator.logical.3n
      - match: \b(i[ns])\b
        name: keyword.operator.expression.$1.3n
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)([.:=!</>^$%?*+]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.3n}
          2: {name: keyword.operator.pattern.3n}
        end: (?=&&|\|\||\^\^|\s|,|:|;|'|"|`|\(|\)|\[|\]|\{|\})
        name: string.unquoted.attribute-name.3n
        patterns:
          - include: "#html-properties"
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: {name: entity.other.attribute-name.3n}
          2: {name: keyword.operator.pattern.3n}
      - include: "#operators"

  # Markdown

  markdown:
    comment: Only inline Markdown syntax would be supported, plus some enhancements HAML, Textile and more. Coming soon.
    patterns: []

  # Special code blocks

  html-properties:
    patterns:
      - match: \s+
        name: meta.var.expr.3n
      - include: "#clauses"
      - include: "#declarations"
      - include: "#brackets"
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional
      - include: source.css#numeric-values
      - include: source.css#property-keywords
      - include: source.css#color-keywords
      - include: source.css#property-names
      - include: "#literals"
      - include: "#embedded"

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})
    captures:
      1: {name: punctuation.definition.block.3n}
    patterns:
      - include: "#style-properties"
  style-properties:
    patterns:
      - include: "#clauses"
      - include: "#style-block"
      - include: "#style-rules"
      - applyEndPatternLast: 1
        begin: \s*([\p{Pc}\p{L}][\w\p{Pd}]*)(:)?\s*
        beginCaptures:
          1: {name: support.type.property-name.3n}
          2: {name: punctuation.separator.key-value.3n}
        end: (?=.)|$
        name: string.unquoted.3n
        patterns:
          - include: "#html-properties"
      - include: "#declarations"
      - include: $self
  style-rules:
    patterns:
      - include: "#style-attributes"
      - include: "#style-parameters"
      - include: "#style-selectors"
      - include: "#tag-names"
  style-parameters:
    begin: \s*(\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.3n}
    patterns:
      - include: "#style-properties"
  style-attributes:
    begin: \s*(\[)\s*
    end: \s*(\])
    captures:
      1: {name: punctuation.definition.selector.3n}
    patterns:
      - include: "#attribute-selectors"
  style-selectors:
    patterns:
      - include: "#format-language"
      - match: \s*(\@|\#|\$|\&|\*|\.|\:|::)\b
        name: punctuation.definition.entity.3n
      - match: \s*(?<=\@)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: keyword.control.at-rule.3n
      - match: \s*(?<=\#)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.id.3n
      - match: \s*(?<=\&)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.type.anchor.3n
      - match: \s*(?<=\.)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.class.3n
      - match: \s*(?<=::?)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.pseudo-element.3n
      - match: \s*(?<=::?)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.pseudo-element.3n

  route-block:
    begin: \s*(\{)\s*
    end: \s*(\})
    captures:
      1: {name: punctuation.definition.block.3n}
    patterns:
      - begin: ^\s*([\p{Pc}\p{L}][\w\p{Pd}]*)(:)\s*
        beginCaptures:
          1: {name: support.type.property-name.3n}
          2: {name: punctuation.separator.key-value.3n}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/|::|!:|\?:|\.|!\.|\?\.)
        name: string.unquoted.3n
        patterns: [include: "#html-properties"]
      - comment: Attribute names
        match: ^\s*([\p{Pc}\p{L}][\w\p{Pd}]*)(:)?\s*
        captures:
          1: {name: support.type.property-name.3n}
          2: {name: punctuation.separator.key-value.3n}
      - include: "#html-properties"
      - include: source.css.scss#property_list
      - include: $self

  # JSX

  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    begin: |
      (?x)
      (?<=(?:
      ^\s*|,\s*|;\s*|
      \#?[({\[]\s*|
      [\p{Pc}\p{L}][\w\p{Pd}]*|
      (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+|
      \b(?:#keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|func|type|object
      |class|enum|module|pack|struct|inter|space|pragma
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|final
      |switch|match|case|fail
      |race|some|every|done|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b)\s*)
      (?=<[\p{Pc}\p{L}])
    end: (?=.)|$
    applyEndPatternLast: 1
    patterns:
      - include: "#tag-element-name"

  tag-names:
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)([:.][\p{Pc}\p{L}][\w\p{Pd}]*)?\b
        captures:
          1:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: entity.name.tag.namespace.3n
              - match: |
                  (?x)\b
                  (?:
                  (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
                  ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
                  ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
                  ([\p{Pc}\p{L}][\w\p{Pd}]*)
                  )\b
                captures:
                  1: {name: entity.name.tag.style.3n}
                  2: {name: entity.name.tag.script.3n}
                  3: {name: entity.name.tag.3n support.class.component.3n}
                  4: {name: entity.name.tag.3n}
              - match: ':\b'
                name: punctuation.separator.namespace.3n
              - match: \.\b
                name: punctuation.accessor.3n

  tag-element-name:
    comment: "Tags that end > are trapped in #tag-termination"
    contentName: string.unquoted.html.3n
    begin: |
      (?x)\s*+(<)#start tag begin
      ([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.\p{Pd}][\p{Pc}\p{L}][\w\p{Pd}]*)*)#tag name
      (?=[\/>\s])(?![:])(?<!\.|:)
    end: \s*(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>
    beginCaptures:
      1: {name: punctuation.definition.tag.3n}
      2: {patterns: [include: "#tag-names"]}
    endCaptures:
      1: {patterns: [include: "#tag-names"]}
      2: {name: punctuation.definition.tag.3n}
      3: {name: punctuation.definition.tag.3n}
      4: {name: invalid.illegal.termination.3n}
    patterns:
      - include: "#tag-termination"
      - include: "#tag-attributes"

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.3n
    name: meta.jsx.children.3n
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.3n}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-element-name"
      - include: "#string-content"
      - include: markdown.math.block
      - include: text.html.markdown#inline

  tag-attributes:
    patterns:
      - include: "#style-selectors"
      - include: "#attributes"
      - include: "#comments"

  attributes:
    patterns:
      - applyEndPatternLast: 1
        begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(=)\s*
        beginCaptures:
          1: {name: entity.other.attribute-name.3n}
          2: {name: punctuation.separator.key-value.3n}
        end: (?=.)|$
        name: string.unquoted.attribute-name.3n
        patterns:
          - include: "#html-properties"
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(=)?\s*
        captures:
          1: {name: entity.other.attribute-name.3n}
          2: {name: punctuation.separator.key-value.3n}

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.3n

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.3n}
          2: {name: punctuation.definition.entity.3n}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.3n
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.3n
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.3n
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.3n
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.3n
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.3n
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.3n
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.3n
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.3n
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.3n

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"

  nested-comments:
    patterns:
      - begin: \s*((/\+\+))
        end: (\s*(\+/))
        name: comment.block.documentation.nested.3n
        captures:
          1: {name: comment.block.documentation.3n}
          2: {name: punctuation.definition.comment.3n}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*((/\+))
        end: (\s*(\+/))
        name: comment.block.nested.3n
        captures:
          1: {name: comment.block.nested.3n}
          2: {name: punctuation.definition.comment.3n}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested"

  block-comments:
    patterns:
      - begin: \s*((/\*\*))
        end: (\s*(\*/))
        name: comment.block.documentation.3n
        captures:
          1: {name: comment.block.documentation.3n}
          2: {name: punctuation.definition.comment.3n}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*((/\*))
        end: (\s*(\*/))
        name: comment.block.3n
        captures:
          1: {name: comment.block.3n}
          2: {name: punctuation.definition.comment.3n}
        patterns:
          - include: text.html.markdown#inline

  line-comments:
    patterns:
      - begin: ((^\s*)|\s*)((///))
        end: \s*$
        name: comment.line.documentation.3n
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.3n}
          3: {name: comment.line.documentation.3n}
          4: {name: punctuation.definition.comment.3n}
        endCaptures:
          0: {name: comment.line.documentation.3n}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//))
        end: \s*$
        name: comment.line.number-sign.3n
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.3n}
          3: {name: comment.line.double-slash.3n}
          4: {name: punctuation.definition.comment.3n}
        endCaptures:
          0: {name: comment.line.number-sign.3n}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\+\+?)\s*
    end: \s*(\+/)
    name: comment.block.documentation.nested.3n
    captures:
      1: {name: punctuation.definition.comment.3n}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"

  nested:
    begin: (/\+)\s*
    end: \s*(\+/)
    name: comment.block.nested.3n
    captures:
      1: {name: punctuation.definition.comment.3n}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested"

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc
  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}
  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}
  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"
  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}
  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"
  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"
  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: (})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}
  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}
  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"
  jsdoc-name-path-scopes:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#jsdoc-string"
  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - comment: |
          Function calls (with spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|new|to|til|thru|by|del|unset
          |var|val|let|const|decl|def|func|type|object
          |class|enum|module|pack|struct|inter|space|pragma
          |proc|proto|macro|given|style|elem|field
          |ext|pred|data|trait|lemma|iter|sub|prop
          |if|un|elif|elun|else|then
          |for|each|loop|while|until|when
          |with|do|from
          |try|throw|catch|final
          |switch|match|case|fail
          |race|some|every|done|spawn|kill|lock
          |break|next|redo|retry|return|await|label|yield|goto|pass
          |import|export|using
          |debug|assert|where
          )(?![\w\p{Pd}])
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b\s+
          (?=<\|{1,3}\s+|<\+\s+)
        captures:
          1: {patterns: [include: "#function-names"]}
      - comment: |
          Function calls (optional spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|new|to|til|thru|by|del|unset
          |var|val|let|const|decl|def|func|type|object
          |class|enum|module|pack|struct|inter|space|pragma
          |proc|proto|macro|given|style|elem|field
          |ext|pred|data|trait|lemma|iter|sub|prop
          |if|un|elif|elun|else|then
          |for|each|loop|while|until|when
          |with|do|from
          |try|throw|catch|final
          |switch|match|case|fail
          |race|some|every|done|spawn|kill|lock
          |break|next|redo|retry|return|await|label|yield|goto|pass
          |import|export|using
          |debug|assert|where
          )(?![\w\p{Pd}])
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b
          (?=
          (?:[!?]?\.=?|[?!:]:=?)?\#?\(|
          (?:[!?]?\.=?|[?!:]:=?)?['"`]|
          (?:[!?]?\.=?|[?!:]:=?)?<[\p{Pc}\p{L}]
          )
        captures:
          1: {patterns: [include: "#function-names"]}

  # Variables

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.3n
      - match: (?i)\s*\*[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.3n
      - match: (?i)\s*[&~][\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.3n
      - match: (?i)\s*\%[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.3n
      - match: (?i)\s*\$[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.3n
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.3n

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.3n}
      2: {name: variable.other.constant.property.3n}
      3: {name: variable.other.property.static.3n}
      4: {name: variable.other.property.3n}
      5: {name: variable.other.global.3n}
      6: {name: variable.other.constant.object.3n}
      7: {name: variable.other.conditional.3n}
      8: {name: variable.other.object.3n}
      9: {name: variable.other.dollar.3n}
      10: {name: variable.other.constant.3n}
      11: {name: variable.other.class.3n}
      12: {name: variable.other.readwrite.3n}

  # Operators

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"
  special-operators:
    patterns:
      - include: "#pipeline-operator"
      - begin: (?<=^|\s)(\?)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.conditional.3n}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\!)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.ternary.3n}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\$)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.macro.dollar.3n}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            name: entity.name.function.3n
          - include: $self
  binary-ops:
    patterns:
      - comment: augmented assignment += -= *= /= etc
        match: (?<=^|[\s'"`({\[])([\p{S}\p{P}&&[^!:~.<=>,;'"`(){}\[\]\p{Pc}]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=)(?=$|[\s'"`)}\]])
        name: keyword.operator.assignment.augmented.3n
      - comment: |
          BUILT-IN OPERATORS

          1: assignment : :=
          2: arithmetic + - * ** *** / // /// % %% *> <*
          3: increment/decrement ++ --
          4: logical && || ^^ !& !| !^ &| &!
          5: bitwise & | ^ ~
          6: bitwise shift << >> <<< >>>
          7: function pipeline <| |> <|| ||> <||| |||>
          8: function composition +> <+
          9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
          10: relational < > <= >=
          11: regex =< <> </ /> <$ $> <+> <*> </> <$>
          12: equality == != === !==
          13: wavy operators ~> <~ ~~> <~~
          14: fat arrow-like => ==> <==
          15: skinny arrow-like -> --> <- <--
          16: null-coalescing ??
          17: non-null coalescing !!
          18: compact ternary operator ?:
          19: inverse ternary operator !:
          20: infix function call $:
        captures:
          1: {name: keyword.operator.assignment.3n}
          2: {name: keyword.operator.arithmetic.3n}
          3: {name: keyword.operator.successor.3n}
          4: {name: keyword.operator.logical.3n}
          5: {name: keyword.operator.bitwise.3n}
          6: {name: keyword.operator.bitwise.shift.3n}
          7: {name: keyword.operator.pipeline.3n}
          8: {name: keyword.operator.compose.3n}
          9: {name: keyword.operator.class.3n}
          10: {name: keyword.operator.relational.3n}
          11: {name: keyword.operator.regexp.3n}
          12: {name: keyword.operator.comparison.3n}
          13: {name: keyword.operator.similarity.3n}
          14: {name: keyword.operator.arrow.fat.3n}
          15: {name: keyword.operator.arrow.skinny.3n}
          16: {name: keyword.operator.null-coalescing.3n}
          17: {name: keyword.operator.coalescing.3n}
          18: {name: keyword.operator.conditional.3n}
          19: {name: keyword.operator.ternary.3n}
          20: {name: keyword.operator.macro.dollar.3n}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          (:?=)#1
          |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
          |(\+\+|--)#3
          |(&&|\|\||\^\^)#4
          |([&|^~])#5
          |(<<<?|>>>?)#6
          |(\|{1,3}>|<\|{1,3})#7
          |(\+>|<\+)#8
          |([<>][!:]|[!:][<>])#9
          |([<>]=?|<=?>)#10
          |(=<|<?[/*|+$:]>?)#11
          |([!=]==?|[!=]~|~[!=])#12
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*~>|
          <~[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#13
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=>|
          <=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#14
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*->|
          <-[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#15
          |(\?\?)#16
          |(!!)#17
          |(\?:)#18
          |(!:)#19
          |(\$:)#20
          )
          (?=$|[\s'"`)}\]])# closing
      - comment: |
          CUSTOM OPERATORS

          1: custom bitwise (& | ^ ~)
          2: custom arithmetic (+ - * / %)
          3: custom prototype (:)
          4: custom accessor (.)
          5: custom equality (= !)
          6: custom comparison (< >)
          7: custom private (? #)
          8: custom mathematical (Unicode Sm)
          9: custom currency (Unicode Sc)
          10: custom ASCII (between \x80 and \xff)
          11: custom infix operators (all other chars)
        captures:
          1: {name: keyword.operator.bitwise.custom.3n}
          2: {name: keyword.operator.arithmetic.custom.3n}
          3: {name: keyword.operator.prototype.custom.3n}
          4: {name: keyword.operator.accessor.custom.3n}
          5: {name: keyword.operator.comparison.custom.3n}
          6: {name: keyword.operator.relational.custom.3n}
          7: {name: keyword.operator.private.custom.3n}
          8: {name: keyword.operator.math.custom.3n}
          9: {name: keyword.operator.currency.custom.3n}
          10: {name: keyword.operator.ascii.custom.3n}
          11: {name: keyword.operator.infix.custom.3n}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          ([&|^~][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#1
          |([+\-*/%][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#2
          |([@:][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |(\.[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |([!=][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#4
          |([<>][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          |([?\#][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#6
          |(\p{Sm}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#7
          |(\p{Sc}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#8
          |([\p{S}\p{P}&&[\x80-\xFF]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#9
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#10
          )
          (?=$|[\s'"`)}\]])# closing
  unary-ops:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`)}\]])# closing
          (?:
          ([>.]\.[.<])#1
          |(\?[.:]=?)#2
          |(![.:]=?)#3
          |((?:::|\.)=?)#4
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          )
          (?=\b|['"`({\[])# opening
        captures:
          1: {name: keyword.operator.range.3n}
          2: {name: keyword.operator.optional.3n}
          3: {name: keyword.operator.assert.3n}
          4: {name: keyword.operator.accessor.3n}
          5: {name: keyword.operator.primary.3n}
      - &prefix-operators
        comment: Prefix operators
        match: |
          (?x)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
          (?=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          [\w({\['"`])
        name: keyword.operator.prefix.3n
        captures:
          1: {name: keyword.operator.module.all.3n}
          2: {name: keyword.operator.increment.3n}
          3: {name: keyword.operator.decrement.3n}
          4: {name: keyword.operator.intersection.3n}
          5: {name: keyword.operator.union.3n}
          6: {name: keyword.operator.symmetric.3n}
          7: {name: keyword.operator.logical.3n}
          8: {name: keyword.operator.private.3n}
          9: {name: keyword.operator.decorator.3n}
          10: {name: keyword.operator.bitwise.not.3n}
          11: {name: keyword.operator.existential.3n}
          12: {name: keyword.operator.assignment.3n}
          13: {name: keyword.operator.pipeline.3n}
          14: {name: keyword.operator.private.3n}
          15: {name: keyword.operator.prefix.3n}
      - &suffix-operators
        comment: Suffix operators
        match: |
          (?x)
          (?<=[)}\]\w'"`]
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
        name: keyword.operator.suffix.3n
        captures:
          1: {name: keyword.operator.module.all.3n}
          2: {name: keyword.operator.increment.3n}
          3: {name: keyword.operator.decrement.3n}
          4: {name: keyword.operator.intersection.3n}
          5: {name: keyword.operator.union.3n}
          6: {name: keyword.operator.symmetric.3n}
          7: {name: keyword.operator.assert.3n}
          8: {name: keyword.operator.private.3n}
          9: {name: keyword.operator.decorator.3n}
          10: {name: keyword.operator.bitwise.3n}
          11: {name: keyword.operator.optional.3n}
          12: {name: keyword.operator.assignment.3n}
          13: {name: keyword.operator.pipeline.3n}
          14: {name: keyword.operator.private.3n}
          15: {name: keyword.operator.suffix.3n}
  pipeline-operator:
    patterns:
      - applyEndPatternLast: 1
        begin: |
          (?x)\s*(?:(\+>)|(\|{1,3}>))(?=\s*(
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|new|to|til|thru|by|del|unset
          |var|val|let|const|decl|def|func|type|object
          |class|enum|module|pack|struct|inter|space|pragma
          |proc|proto|macro|given|style|elem|field
          |ext|pred|data|trait|lemma|iter|sub|prop
          |if|un|elif|elun|else|then
          |for|each|loop|while|until|when
          |with|do|from
          |try|throw|catch|final
          |switch|match|case|fail
          |race|some|every|done|spawn|kill|lock
          |break|next|redo|retry|return|await|label|yield|goto|pass
          |import|export|using
          |debug|assert|where
          )(?![\w\p{Pd}])
          )
          [\w]+
          (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# primary
          [\w]+)*
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# suffix
          )\s*([^(]|$|;))
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.compose.3n}
          2: {name: keyword.operator.pipeline.3n}
        patterns:
          - match: |
              (?x)\s*\b
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
              \b(?:# don't match keywords
              in|of|as|is|new|to|til|thru|by|del|unset
              |var|val|let|const|decl|def|func|type|object
              |class|enum|module|pack|struct|inter|space|pragma
              |proc|proto|macro|given|style|elem|field
              |ext|pred|data|trait|lemma|iter|sub|prop
              |if|un|elif|elun|else|then
              |for|each|loop|while|until|when
              |with|do|from
              |try|throw|catch|final
              |switch|match|case|fail
              |race|some|every|done|spawn|kill|lock
              |break|next|redo|retry|return|await|label|yield|goto|pass
              |import|export|using
              |debug|assert|where
              )(?![\w\p{Pd}])
              )
              (?:
              (?:# Objects and maps
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
              |
              (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
              (?:# Properties
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              |
              (?:# Regular variables
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              )\b
            captures:
              1: {name: variable.other.global.3n}
              2: {name: variable.other.constant.object.3n}
              3: {name: variable.other.conditional.3n}
              4: {name: variable.other.object.3n}
              5: {name: entity.name.tag.3n}
              6: {name: entity.name.tag.3n support.class.component.3n}
              7: {name: entity.name.class.builtin.3n}
              8: {name: entity.name.function.method.3n}
              9: {name: entity.name.function.tagged-template.3n}
              10: {name: entity.name.type.3n}
              11: {name: entity.name.class.3n}
              12: {name: entity.name.function.3n}
          - *primary-operators

  # Types

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=.)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.3n}
    patterns:
      - include: "#types"
  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.3n
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.3n
        patterns:
          - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.binding-pattern.object.3n}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|;|,|\(|\[|\{|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])(?<![\w,;'"`)}\]]\|)\s*(\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.mapping.3n}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|;|,|\(|\[|\{|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])(?<![\w,;'"`)}\]]\|)\s*(\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.3n}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.3n
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.3n}
            patterns:
              - include: "#punctuation"
              - include: "#function-params"
              - include: "#types"
              - include: $self
          - begin: \s*(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.3n}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
                captures:
                  1: {name: punctuation.separator.slice.3n}
              - match: ","
                name: punctuation.separator.sequence.3n
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.attribute-selector.3n}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.sequence.3n}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.3n
              - include: "#types"
              - include: $self
          - begin: \s*(\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.3n}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.3n
              - include: "#types"
              - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.3n
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - include: "#type-embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.3n
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - match: "''"
            name: constant.character.escape.3n
          - include: "#type-embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.3n
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.3n}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"

  type-embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.3n
        captures:
          1: {name: punctuation.section.embedded.3n}
        patterns: [include: $self]
      - match: |
          (?x)(\$)
          (\b[\p{Pc}\p{L}]
          (?<expr>
          # Recursive brackets
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>["`])[^\\.]*\g<q2>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.3n}
          2: {patterns: [include: "#everything-but-comments"]}

  type-format-specifier:
    match: |
      (?x)(%)
      (
      (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
      (
      (?<sw>
      /\g<ident>
      (?<val>:
      (?<expr>
      # Recursive brackets
      (?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      (?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>["`])[^\\.]*\g<q2>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Everything nice
      ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
      )
      )?
      )*
      )?
      )
    captures:
      1: {name: punctuation.definition.directive.3n}
      2:
        name: storage.type.format.3n
        patterns:
          - include: "#format-language"
          - match: .+
            name: string.other.format.3n

  type-embedded-placeholder:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.3n}
          2: {name: constant.numeric.decimal.3n}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.anchor.3n}
          2: {patterns: [include: "#placeholder-variables"]}
      - begin: (\#{)\s*
        end: (})
        name: entity.quasi.element.3n
        captures:
          1: {name: punctuation.definition.anchor.3n}
        patterns:
          - include: "#placeholder-variables"
          - include: $self

  type-embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#type-embedded-placeholder"
      - include: "#type-embedded-expression"

  type-embedded-raw:
    patterns:
      - match: \$\$|\%\%\|#\#
        name: constant.character.escape.3n
      - include: "#format-specifier"
      - include: "#type-embedded-placeholder"
      - include: "#type-embedded-expression"

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?![\w\p{Pd}])\s*
        name: storage.type.extends.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)(?![\w\p{Pd}])\s*
        name: storage.type.implements.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|pairof|infer|as|is)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.$1.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(instof)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.instanceof.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(valof)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.valueof.3n

  type-operators:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`\\)}\]])
          (?:
          ([>.]\.[.<])
          |(\?[.:]=?)
          |(![.:]=?)
          |((?:::|\.)=?)
          )
          (?=\b|['"`\\({\[])
        captures:
          1: {name: keyword.operator.range.3n}
          2: {name: keyword.operator.optional.3n}
          3: {name: keyword.operator.assert.3n}
          4: {name: keyword.operator.accessor.3n}

      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.3n}
          2: {name: keyword.operator.difference.3n}
          3: {name: keyword.operator.product.3n}
          4: {name: keyword.operator.quotient.3n}
          5: {name: keyword.operator.remainder.3n}
          6: {name: keyword.operator.only.3n}
          7: {name: keyword.operator.maybe.3n}
          8: {name: keyword.operator.intersection.3n}
          9: {name: keyword.operator.union.3n}
          10: {name: keyword.operator.symmetric.3n}
          11: {name: keyword.operator.negation.3n}
          12: {name: keyword.operator.macro.dollar.3n}
          13: {name: keyword.operator.private.3n}
          14: {name: keyword.operator.class.3n}

  types:
    patterns:
      - match: \s*(==?>|--?>|~~?>)
        name: keyword.operator.type.function.3n
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.3n
      - include: "#params-clause"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#type-strings"
      - include: "#literals"

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.3n}
    patterns: &function-params
      - include: "#clauses"
      - include: "#constants"
      - include: "#declarations"
      - include: "#keywords"
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.optional.3n
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\*[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.spread.3n
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\&[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.name.3n
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\%[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.reference.3n
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\$[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.other.3n
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,]|^)
          \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=\s*(?:[,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.3n
      - include: "$self"

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
      \b(?:# don't match keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|func|type|object
      |class|enum|module|pack|struct|inter|space|pragma
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|final
      |switch|match|case|fail
      |race|some|every|done|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )(?![\w\p{Pd}])
      )
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.3n}
      2: {name: entity.name.tag.3n}
      3: {name: entity.name.namespace.3n}
      4: {name: entity.name.interface.3n}
      5: {name: entity.name.tag.block.3n}
      6: {name: entity.name.tag.script.3n}
      7: {name: entity.name.tag.style.3n}
      8: {name: entity.name.tag.inline.3n}
      9: {name: entity.name.label.3n}
      10: {name: entity.name.project.3n}
      11: {name: entity.name.class.3n}
      12: {name: entity.name.type.3n}

  # Clauses and Keywords

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.3n
      - include: "#type-operators"
      - include: "#operators"
      - include: "#literals"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]))
        end: (?=.)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.3n}
        patterns: [include: "#types"]
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      # access modifiers
      pub|priv|prot|inline|final|mut|immut|ghost|early|late|joint|contra
      |seal|abs|intern|extern|imply|exply|global|local

      # concurrency modifiers
      |a?sync|stat|dyn|lazy|eager|strong|weak|swap
      |vol|unsafe|unfix|bound|free|opaque|trans

      # property or method modifiers
      |rec|gen|oper|get|set|post|put|rem|new|del|patch
      |prefix|suffix|infix|binary|unary|left|right
      )
      )(?![\w\p{Pd}])\s*
      |# Decorators
      @[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
      )*
      )
      (?=
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      var|val|let|const|decl|def|func|type|object
      |class|enum|module|pack|struct|inter|space|pragma
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - &decorators
            match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
            name: entity.name.class.decorator.3n
          - &modifiers
            match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|inline|final|mut|immut|ghost|early|late|joint|contra
              |seal|abs|intern|extern|imply|exply|global|local
              )|
              (# Function or method modifiers
              a?sync|stat|dyn|lazy|eager|strong|weak|swap
              |vol|unsafe|unfix|bound|free|opaque|trans
              )|
              (# Property modifiers
              rec|gen|oper|get|set|post|put|rem|new|del|patch
              |prefix|suffix|infix|binary|unary|left|right
              )
              )(?![\w\p{Pd}])\s*
            captures:
              1: {name: storage.modifier.3n}
              2: {name: storage.type.accessor.3n}
              3: {name: storage.type.property.3n}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)(?![\w\p{Pd}])\s*
        name: keyword.other.declare.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)(?![\w\p{Pd}])\s*
        name: storage.type.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?![\w\p{Pd}])\s*
        name: storage.type.style.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?![\w\p{Pd}])\s*
        name: storage.type.function.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
        name: storage.type.method.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?![\w\p{Pd}])\s*
        name: storage.type.class.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?![\w\p{Pd}])\s*
        name: storage.type.enum.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?![\w\p{Pd}])\s*
        name: storage.type.module.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pack)(?![\w\p{Pd}])\s*
        name: storage.type.package.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?![\w\p{Pd}])\s*
        name: storage.type.interface.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(space)(?![\w\p{Pd}])\s*
        name: storage.type.namespace.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)(?![\w\p{Pd}])\s*
        name: storage.type.structure.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?![\w\p{Pd}])\s*
        name: storage.type.object.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?![\w\p{Pd}])\s*
        name: storage.type.data.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?![\w\p{Pd}])\s*
        name: storage.type.trait.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?![\w\p{Pd}])\s*
        name: storage.type.procedure.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)(?![\w\p{Pd}])\s*
        name: storage.type.protocol.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?![\w\p{Pd}])\s*
        name: storage.type.macro.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)(?![\w\p{Pd}])\s*
        name: storage.type.given.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?![\w\p{Pd}])\s*
        name: storage.type.element.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?![\w\p{Pd}])\s*
        name: storage.type.extends.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)(?![\w\p{Pd}])\s*
        name: storage.type.subroutine.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pred)(?![\w\p{Pd}])\s*
        name: storage.type.predicate.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(lemma)(?![\w\p{Pd}])\s*
        name: storage.type.lemma.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?![\w\p{Pd}])\s*
        name: storage.type.iterator.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)(?![\w\p{Pd}])\s*
        name: storage.type.field.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?![\w\p{Pd}])\s*
        name: storage.type.property.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pragma)(?![\w\p{Pd}])\s*
        name: storage.type.pragma.3n

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)(?![\w\p{Pd}])\s*
        name: keyword.control.conditional.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)(?![\w\p{Pd}])\s*
        name: keyword.control.loop.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|final)(?![\w\p{Pd}])\s*
        name: keyword.control.trycatch.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|fail)(?![\w\p{Pd}])\s*
        name: keyword.control.switch.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|when)(?![\w\p{Pd}])\s*
        name: keyword.control.match.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(race|some|every|done|spawn|kill|lock)(?![\w\p{Pd}])\s*
        name: keyword.control.thread.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?![\w\p{Pd}])\s*
        name: keyword.control.flow.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|using)(?![\w\p{Pd}])\s*
        name: keyword.control.module.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from)(?![\w\p{Pd}])\s*
        name: keyword.control.$1.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|where)(?![\w\p{Pd}])\s*
        name: keyword.other.$1.3n

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.$1.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.delete.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.range.3n
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.void.3n

  keywords:
    patterns:
      - include: "#validation-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.control.flow.3n}
        patterns:
          - match: *entity-name
            name: constant.other.label.3n

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|using)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.control.module.3n}
            patterns:
              - include: source.yaml#flow-collection
              - *modifiers
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                name: keyword.control.module.3n
              - include: "#type-keywords"
              - include: "#declarations"
              - include: "#strings-quoted"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.3n
              - match: *entity-name
                name: variable.other.readwrite.alias.3n

      validation-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?![\w\p{Pd}])\s*
        beginCaptures:
          1: {name: keyword.control.validate.3n}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?![\w\p{Pd}])\s*
            name: keyword.control.validate.3n
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?![\w\p{Pd}])\s*
            name: keyword.control.validate.3n
          - include: $self

      query-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?![\w\p{Pd}])\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?![\w\p{Pd}])\s*
        beginCaptures:
          1: {name: keyword.control.query.3n}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.3n}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - include: "#query-body"
          - include: $self
      query-body:
        patterns:
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"
        repository:
          join-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part)?(?![\w\p{Pd}])\s*\b(?:inner|outer|left|right)?(?![\w\p{Pd}])\s*\bjoin)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(on|equals|into)(?![\w\p{Pd}])\s*
                name: keyword.control.query.3n
              - include: "#query-body"
              - include: $self
          where-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          sort-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sort(?![\w\p{Pd}])\s*\b(?:asc|desc)?(?![\w\p{Pd}])\s*\b(?:by|with)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          select-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(select(?![\w\p{Pd}])\s*\b(?:unique|any|all)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.3n
              - include: "#query-body"
              - include: $self
          limit-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit)(?![\w\p{Pd}])\s*\b(?:first|last|head|tail)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.3n
              - include: "#query-body"
              - include: $self
          reduce-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?![\w\p{Pd}])\s*\b(?:left|right)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.3n
              - include: "#query-body"
              - include: $self
          group-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.3n}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)(?![\w\p{Pd}])\s*
                name: keyword.control.query.3n
              - include: "#query-body"
              - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#function"
      - include: "#method"
      - include: "#class"
      - include: "#enum"
      - include: "#module"
      - include: "#package"
      - include: "#interface"
      - include: "#namespace"
      - include: "#structure"
      - include: "#object"
      - include: "#data"
      - include: "#trait"
      - include: "#procedure"
      - include: "#protocol"
      - include: "#macro"
      - include: "#type"
      - include: "#given"
      - include: "#element"
      - include: "#extends"
      - include: "#subroutine"
      - include: "#predicate"
      - include: "#lemma"
      - include: "#iterator"
      - include: "#field"
      - include: "#property"
      - include: "#pragma"

    repository:
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.style.3n}
        patterns:
          - include: "#style-block"
          - include: "#style-rules"
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.3n

      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.variable.3n}
      declare:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.other.declare.3n}

      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.function.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.3n
      method:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.method.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.method.3n
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.class.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.3n
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.enum.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.3n
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.module.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.3n
      package:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pack)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.package.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.package.3n
      interface:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.interface.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.interface.3n
      namespace:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(space)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.namespace.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.namespace.3n
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.structure.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.3n
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.object.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.3n
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.data.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.3n
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.trait.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.3n
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.procedure.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.3n
      protocol:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.protocol.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.protocol.3n
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.macro.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.3n
      given:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.given.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.given.3n
      element:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.element.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.element.3n
      extends:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.extends.3n
      subroutine:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.subroutine.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.subroutine.3n
      predicate:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pred)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.predicate.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.predicate.3n
      lemma:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(lemma)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.lemma.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.lemma.3n
      iterator:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.iterator.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.iterator.3n
      field:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.field.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.field.3n
      property:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.property.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.property.3n
      pragma:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pragma)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.pragma.3n}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.pragma.3n

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|\#?[({\[]\s*|(?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+|\b(?:#keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|func|type|object
      |class|enum|module|pack|struct|inter|space|pragma
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|final
      |switch|match|case|fail
      |race|some|every|done|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.3n}
    end: (?<!\|)(\|)(?!\|)
    patterns: *function-params

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#params-clause"

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.3n}
        patterns:
          - include: "#function-params"
      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?![\w\p{Pd}])
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.3n}
        patterns:
          - match: *entity-name
            name: entity.name.instance.3n
          - include: "#type-keywords"
          - include: "#illegal-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"
      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.3n}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            captures:
              1: {name: keyword.other.typedef.3n}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.3n}
              - include: "#types"
      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|final)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.catch.3n
        captures:
          1: {name: keyword.control.error.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.3n}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
                name: keyword.control.error.3n
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
            name: keyword.control.error.3n
          - include: $self
      thread-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(race|some|every|done|spawn|kill|lock)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.thread.3n
        captures:
          1: {name: keyword.control.thread.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - &thread-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
            name: keyword.control.thread.3n
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.3n}
            patterns:
              - *thread-clause-keywords
              - include: $self
          - include: $self
      do-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(do)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.do.3n
        captures:
          1: {name: keyword.control.do.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - include: $self
      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.for.3n
        captures:
          1: {name: keyword.control.loop.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - &for-clause-keywords
            match: \s*\b(in|of)\b
            name: keyword.control.loop.3n
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.3n}
            patterns:
              - *for-clause-keywords
              - include: $self
          - include: $self
      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.if.3n
        captures:
          1: {name: keyword.control.conditional.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - include: $self
      match-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?![\w\p{Pd}])\s*
        end: (?<=;|})|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.match.3n
        captures:
          1: {name: keyword.control.match.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.section.class.3n}
            patterns:
              - &when-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.match.3n}
                  2: {name: punctuation.separator.colon.3n}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?![\w\p{Pd}])\s*
                    end: (?=.)|$
                    beginCaptures:
                      1: {name: keyword.control.match.3n}
                    patterns:
                      - include: "#types"
                  - include: "#type-keywords"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)(?![\w\p{Pd}])\s*
                    name: keyword.control.match.3n
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?![\w\p{Pd}])\s*
                    name: keyword.control.match.3n
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                    name: keyword.control.match.3n
                  - include: $self
              - &else-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.match.3n}
                  2: {name: punctuation.separator.colon.3n}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.block.3n}
            patterns:
              - *when-clause
              - *else-clause
              - include: $self
          - include: $self
      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)(?![\w\p{Pd}])\s*
        end: (?<=;|})|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.switch.3n
        captures:
          1: {name: keyword.control.switch.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.section.class.3n}
            patterns:
              - &case-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.3n}
                  2: {name: punctuation.separator.colon.3n}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?![\w\p{Pd}])\s*
                    end: (?=.)|$
                    beginCaptures:
                      1: {name: keyword.control.switch.3n}
                    patterns:
                      - include: "#types"
                  - include: "#type-keywords"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.3n
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.3n
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.3n
                  - include: $self
              - &default-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.3n}
                  2: {name: punctuation.separator.colon.3n}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.block.3n}
            patterns:
              - *case-clause
              - *default-clause
              - include: $self
          - include: $self
      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.with.3n
        captures:
          1: {name: keyword.control.with.3n}
          2: {name: punctuation.separator.colon.3n}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
            name: keyword.control.with.3n
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.3n}
            patterns:
              - *with-clause-keywords
              - include: $self
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
          ((?:
          \s*(?:
          (?:# access modifiers
          pub|priv|prot|inline|final|mut|immut|ghost|early|late|joint|contra
          |seal|abs|intern|extern|imply|exply|global|local

          # concurrency modifiers
          |a?sync|stat|dyn|lazy|eager|strong|weak|swap
          |vol|unsafe|unfix|bound|free|opaque|trans

          # property or method modifiers
          |rec|gen|oper|get|set|post|put|rem|new|del|patch
          |prefix|suffix|infix|binary|unary|left|right
          |# Decorators
          @[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
          ))
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.3n
        captures:
          1: {name: entity.name.function.3n}
          2: {name: punctuation.separator.key-value.3n}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
          (
          (?:
          (?:# access modifiers
          pub|priv|prot|inline|final|mut|immut|ghost|early|late|joint|contra
          |seal|abs|intern|extern|imply|exply|global|local

          # concurrency modifiers
          |a?sync|stat|dyn|lazy|eager|strong|weak|swap
          |vol|unsafe|unfix|bound|free|opaque|trans

          # property or method modifiers
          |rec|gen|oper|get|set|post|put|rem|new|del|patch
          |prefix|suffix|infix|binary|unary|left|right
          |# Decorators
          @[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.3n
        captures:
          1: {name: entity.name.function.3n}
          2: {name: punctuation.separator.key-value.3n}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.3n}
        endCaptures:
          1: {name: punctuation.separator.arguments.3n}
        patterns: *function-params
      - match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
        name: meta.object-literal.key.3n
        captures:
          1:
            name: constant.other.object.key.3n
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"
          2: {name: punctuation.separator.key-value.3n}

  # Punctuation

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#semicolon"

    repository:
      line-continuation:
        match: (\\)\s*(?=/[/*+]|$)
        name: punctuation.separator.continuation.line.3n
      comma:
        match: \s*(,)
        name: punctuation.separator.comma.3n
      double-semi:
        match: \s*(;;)
        name: punctuation.terminator.expression.3n
      semicolon:
        match: \s*(;)
        name: punctuation.terminator.statement.3n

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.3n
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.3n
      closures:
        patterns:
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)(?![\w\p{Pd}])\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.3n}
              2: {name: punctuation.separator.colon.3n}
            patterns:
              - include: "#params-clause"
              - applyEndPatternLast: 1
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?![\w\p{Pd}])\s*
                end: (?=.)|$
                beginCaptures:
                  1: {name: keyword.control.3n}
                patterns:
                  - include: "#types"
              - include: "#type-keywords"
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)(?![\w\p{Pd}])\s*
                name: keyword.control.3n
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?![\w\p{Pd}])\s*
                name: keyword.control.3n
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                name: keyword.control.switch.3n
              - include: $self
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)(?![\w\p{Pd}])\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.3n}
              2: {name: punctuation.separator.colon.3n}
            patterns:
              - include: $self
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.typeparameters.3n}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.3n}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|;|,|\(|\[|\{|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])(?<![\w,;'"`)}\]]\|)\s*(\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.3n}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|;|,|\(|\[|\{|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])(?<![\w,;'"`)}\]]\|)\s*(\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.3n}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.3n}
        patterns:
          - include: "#closures"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.3n}
        patterns:
          - include: "#closures"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.3n
      function-params:
        patterns: *function-params
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.3n}
        patterns:
          - include: "#punctuation"
          - include: "#function-params"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.3n}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.3n}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
            captures:
              1: {name: punctuation.separator.slice.3n}
          - match: ","
            name: punctuation.separator.sequence.3n
    patterns:
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.3n}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.3n}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.3n}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.3n
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.3n}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.3n
          - include: $self

  support-js:
    patterns:
      - begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<=\.)\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.mutator.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.error.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(debugger)\b
        captures:
          1: {name: keyword.other.js}
      - match: (?<!\.)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.js}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.js}
      - begin: (?<!\.)\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.console.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.console.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.process.js}
      - begin: (?<!\.)\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.process.js}
        patterns:
          - include: "#round-brackets"
      - match: (((?<!\.)\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.module.js}
      - match: (?<!\.)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.js}
      - begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.node.js}
        patterns:
          - include: "#round-brackets"
      - match: |-
          (?<=\.|::)\s*\b
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: |-
          (?x)(?<=\.|::)\s*\b
          (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName
          |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop
          |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor
          |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption
          |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear
          |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete
          |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset
          |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
          |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
          |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
          |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
          |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
          |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
          |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
          |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
          |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
          |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
          |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
          |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
          |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|relat|responseText
          |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
          |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
          |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
          |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
          |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
          |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: (?x)(?<=\.|::)\s*\b(module|exports|id|filename|loaded|parent|children)(?![\w\p{Pd}])\s*
        name: support.type.object.module.js

name: Protea
scopeName: source.dart
fileTypes: [dart, protea]
patterns: [include: "#core"]

Information for Contributors: |
  This is the grammar for the Protea programming language. The grammar
  is about 85% complete though there still need to be some fixes.

  Should you want to provide a fix or improvement, or perhaps to
  change or add a new feature, or even some general constructive
  feedback, make a pull request, or an issue on this very repository,
  and I will be very happy to receive it/them.

  Some parts such as numeric literals, HTML character entities and more
  are partially or entirely generated through code by means of compressed
  tries and DFA minimization.

comment: |
  To-Do:
  - Revamp numeric literals again
  - Add type-regex literals

  Done:
  - Changed from indentation to curly bracket syntax
  - Map/set syntax should only activate next to an opening bracket, or
    non-suffix operator
  - Freed backslash to be an operator character
  - Added support for dashed identifiers, to support Lisp/train case
  - Fixed highlighting of "S-1" scenario, where a dash would only
    highlight the first word
  - Removed unquoted strings, especially YAML ones
  - Added CSS keyword and function properties
  - Reworked JSX syntax, restored JSX fragments
  - Reworked format directives and embedded expressions, with a little
    help from recursion
  - Reworked number, string and JSX literals
  - Rework keywords in favor of a smaller set (see documentation)
  - Fix highlighting of CSS style rules to allow not repeating the "style"
    keyword for nested styles
  - Add highlighting for CSS dynamic properties

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.protea}
    2: {name: punctuation.separator.decimal.period.protea}
    3: {name: punctuation.separator.decimal.fraction.protea}
    4: {name: constant.numeric.other.exponent.protea}
    5: {name: constant.numeric.other.density.protea}
    6: {name: storage.type.numeric.protea}

  entity-name-clause: &entity-name-clause |
    (?x)\s*\b
    (?<=(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:ext|impl)\b|\s*[<>]\s+)\s*

    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    )(?![\w\p{Pd}])
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  class-name: &class-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    |ext|impl
    )(?![\w\p{Pd}])
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    )(?![\w\p{Pd}])
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

repository:
  core:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  everything-but-comments:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  # Function brackets (early here as not to break things)

  function-params:
    patterns:
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.optional.protea
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.spread.protea
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.name.protea
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.reference.protea
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.other.protea
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+:?=\s+|\s+\bas\b\s+)
        name: variable.parameter.protea

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.protea}
    patterns: &function-params
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.as.protea
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.protea
      - include: "#clauses"
      - include: "#constants"
      - include: "#declarations"
      - include: "#expression-keywords"
      - include: "#function-params"
      - include: "$self"

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.other.protea
      - match: '[\w]+?'
        name: invalid.illegal.variable.other.protea
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.protea
      - match: \S+?
        name: invalid.illegal.syntax.protea

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?![\w\p{Pd}])\s*
    name: invalid.illegal.keyword.protea

  # Support

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"
  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)
          |Imag|Comp|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          # lowerFlatCase
          |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)
          |imag|comp|char|rune|str|sym
          |u?int(8|16|32|64|128)
          |[ci]?float(16|32|64|128)
          |[ui](8|16|32|64|128)
          |[ci]?f(16|32|64|128)
          )(?![\w\p{Pd}])
        name: support.type.builtin.primitive.protea
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map|Bag)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          # lowerFlatCase
          |array|tuple|(mut)?(list|set|map|bag)|dict|func|iter
          |proc|seq|gen|range|stack|heap|queue|tree|trie
          |future|stream|regexp?|func|buf|strbuf|bytes
          )(?![\w\p{Pd}])
        name: support.type.builtin.protea
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit
          |Any|Mixed|Just|Some|None|Never|(Im)?pure
          |Class|Enum|Module|Pack|Struct|Schema|Space|Pragma
          |Proc|Proto|Macro|Given|Style|Compo|Field
          |Ext|Pred|Data|Trait|Lemma|Iter|Sub|Prop|Const
          # lowerFlatCase
          |true|false|null|void|nan|infin|empty|unit
          |any|mixed|just|some|none|never|(im)?pure|const
          )(?![\w\p{Pd}])
        name: support.type.primitive.protea
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.protea
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)\b
        name: entity.name.interface.protea
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)\b
        name: entity.name.namespace.protea
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able\b
        name: support.class.trait.protea
      - comment: Swift
      - include: source.swift#builtin-types
      - comment: Python
      - include: source.python#builtin-types
      - comment: JS
      - includes: "#support-js"
      - comment: PHP
      - include: source.php#class-builtin
  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.protea
      - comment: magic functions
        match: (?x)\s*\b_+([\p{Pc}\p{L}][\w\p{Pd}]*)+_+\b\s*
        name: support.function.magic.protea
      - comment: Swift
      - include: source.swift#builtin-functions
      - comment: JavaScript
      - include: source.js#support-objects
      - comment: Python
      - include: source.python#builtin-functions
      - comment: PHP
      - include: source.php#support
      - comment: SASS
      - include: source.css.sass#constant_sass_functions
      - comment: Other (coming soon!)
      - match: |
          (?x)\b(?:
          (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          |
          (?:# Objects
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
          |
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.protea}
          2: {name: entity.name.tag.protea support.class.component.protea}
          3: {name: entity.name.class.builtin.protea}
          4: {name: entity.name.function.method.protea}
          5: {name: variable.other.global.protea}
          6: {name: variable.other.constant.object.protea}
          7: {name: variable.other.conditional.protea}
          8: {name: variable.other.object.protea}
          9: {name: entity.name.function.tagged-template.protea}
          10: {name: entity.name.type.protea}
          11: {name: entity.name.class.protea}
          12: {name: entity.name.function.protea}
      - include: $self
  constant-names:
    comment: Names for constants, symbols and static properties
    patterns:
      - comment: Python
      - include: source.python#magic-variable-names
  variable-names:
    comment: Standard Library variable names
    patterns:
      - comment: Python
      - include: source.python#magic-function-names
  property-names:
    comment: Standard Library property names
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties

  # Literals and Constants

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"
  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )(?![\w\p{Pd}])\s*
        captures:
          1: {name: constant.language.boolean.true.protea}
          2: {name: constant.language.boolean.false.protea}
          3: {name: constant.language.null.protea}
          4: {name: constant.language.undefined.protea}
          5: {name: constant.language.nan.protea}
          6: {name: constant.language.infinity.protea}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (it|this|that|sub|self)#1
          |(args)#2
          |(ctor)#3
          |(prot)#4
          |(proto)#5
          )(?![\w\p{Pd}])\s*
        captures:
          1: {name: variable.language.$1.protea}
          2: {name: variable.language.arguments.protea}
          3: {name: variable.language.constructor.protea}
          4: {name: variable.language.prototype.protea}
          5: {name: variable.language.proto.protea}
  symbols:
    patterns:
      - match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
        name: entity.name.class.decorator.protea
      - match: \s*\B(:)(?=['"])
        name: punctuation.definition.symbol.protea
      - begin: \s*\B(:)(\w|\\.)
        beginCaptures:
          1: {name: punctuation.definition.symbol.protea}
          2: {name: constant.other.symbol.protea}
        end: (?=[\s.,:;'"`</>(){}\[\]]|$|[?!:]:|[!?]\.)
        name: constant.other.symbol.protea
        patterns:
          - include: "#string-content"

  # Numbers

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.protea
      - match: (?<=(^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.protea
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix/base prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# integer & numerator part
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional part
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?|# repeating part
          (\/)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?# integer/numerator
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0b)# radix/base prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)# integer & numerator part
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional part
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?|# repeating part
          (\/)(?:[01]+(?:\p{Pc}*[01]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0b)# radix prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)?# integer/numerator
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0q)# radix/base prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional part
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?|# repeating part
          (\/)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0q)# radix prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0s)# radix/base prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional part
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?|# repeating part
          (\/)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0s)# radix prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0o)# radix/base prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional part
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?|# repeating part
          (\/)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0o)# radix prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0z)# radix/base prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)# integer & numerator part
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional part
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?|# repeating part
          (\/)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0z)# radix prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)?# integer/numerator
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0x)# radix/base prefix
          (?:\h+(?:\p{Pc}*\h+)*)# integer & numerator part
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional part
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?|# repeating part
          (\/)(?:\h+(?:\p{Pc}*\h+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (0x)# radix prefix
          (?:\h+(?:\p{Pc}*\h+)*)?# integer/numerator
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          ()# radix/base prefix
          (?:\d+(?:\p{Pc}*\d+)*)# integer & numerator part
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional part
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?|# repeating part
          (\/)(?:\d+(?:\p{Pc}*\d+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          ()# radix prefix
          (?:\d+(?:\p{Pc}*\d+)*)?# integer/numerator
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix/base prefix
          (?:\w+(?:\p{Pc}*\w+)*)# integer & numerator part
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional part
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?|# repeating part
          (\/)(?:\w+(?:\p{Pc}*\w+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix prefix
          (?:\w+(?:\p{Pc}*\w+)*)?# integer/numerator
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.protea}
          1: {name: storage.type.numeric.protea}
          2: {name: punctuation.separator.decimal.period.protea}
          3: {name: punctuation.separator.decimal.repeating.protea}
          4: {name: punctuation.separator.decimal.fraction.protea}
          5: {name: constant.numeric.other.exponent.protea}
          6: {name: constant.numeric.other.precision.protea}
          7: {name: storage.type.numeric.protea}

  strings-quoted:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#embedded-raw"
      - comment: single quoted string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - match: "''"
            name: constant.character.escape.protea
          - include: "#embedded-raw"
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-content"
      - comment: double quoted string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-content"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: (?ix)\\b[01]{1,21}
        name: constant.character.escape.binary.protea
      - comment: Binary escape sequences
        begin: (?ix)\\b{
        end: \s*}
        name: constant.character.escape.binary.protea
        patterns:
          - match: \b[01]{1,21}\b
            name: constant.character.escape.binary.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Quaternary escape sequences
        match: (?ix)\\q[0-3]{1,11}
        name: constant.character.escape.quaternary.protea
      - comment: Quaternary escape sequences
        begin: (?ix)\\q{
        end: \s*}
        name: constant.character.escape.quaternary.protea
        patterns:
          - match: \b[0-3]{1,11}\b
            name: constant.character.escape.quaternary.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Senary escape sequences
        match: (?ix)\\s[0-5]{1,8}
        name: constant.character.escape.senary.protea
      - comment: Senary escape sequences
        begin: (?ix)\\s{
        end: \s*}
        name: constant.character.escape.senary.protea
        patterns:
          - match: \b[0-5]{1,8}\b
            name: constant.character.escape.senary.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Octal escape sequences
        match: (?ix)\\o[0-7]{1,7}
        name: constant.character.escape.octal.protea
      - comment: Octal escape sequences
        begin: (?ix)\\o{
        end: \s*}
        name: constant.character.escape.octal.protea
        patterns:
          - match: \b[0-7]{1,7}\b
            name: constant.character.escape.octal.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Decimal escape sequences
        match: (?ix)\\d?\d{1,7}
        name: constant.character.escape.decimal.protea
      - comment: Decimal escape sequences
        begin: (?ix)\\d{
        end: \s*}
        name: constant.character.escape.decimal.protea
        patterns:
          - match: \b\d{1,7}\b
            name: constant.character.escape.decimal.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Duodecimal escape sequences
        match: (?ix)\\z[\dab]{1,6}
        name: constant.character.escape.duodecimal.protea
      - comment: Duodecimal escape sequences
        begin: (?ix)\\z{
        end: \s*}
        name: constant.character.escape.duodecimal.protea
        patterns:
          - match: \b[\dab]{1,6}\b
            name: constant.character.escape.duodecimal.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea
      - comment: Hexadecimal escape sequences
        match: (?ix)\\[ux]\h{1,6}
        name: constant.character.escape.hexadecimal.protea
      - comment: Hexadecimal escape sequences
        begin: (?ix)\\[ux]{
        end: \s*}
        name: constant.character.escape.hexadecimal.protea
        patterns:
          - match: \b\h{1,6}\b
            name: constant.character.escape.hexadecimal.protea
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.protea

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.protea
        patterns:
          - include: "#latex-sublanguage"
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.protea
      - match: (?i)\\[a-z]
        name: constant.character.escape.protea
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.protea
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.protea
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.protea

  embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.component.protea
        captures:
          1: {name: punctuation.section.embedded.protea}
        patterns: [include: $self]
      - comment: Oniguruma supports only 20 levels of recursion
        match: |
          (?x)(\$)
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?![\w\p{Pd}])
          )
          \b[\p{Pc}\p{L}][\p{Pd}\w]*\b
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.protea}
          2: {patterns: [include: "#everything-but-comments"]}
  format-specifier:
    comment: Oniguruma supports only 20 levels of recursion
    match: |
      (?x)(%)
      (
      (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
      (
      (?<sw>
      /\g<ident>
      (?<val>:
      (?<expr>
      # Recursive brackets
      ([?!]?\.|[?!:]:)?(?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      ([?!]?\.|[?!:]:)?(?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
      (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Rest of identifier characters
      [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
      (\w+[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)*
      (?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
      )*
      )?
      )*
      )
      )
    captures:
      1: {name: punctuation.definition.directive.protea}
      2:
        name: storage.type.format.protea
        patterns:
          - include: "#format-language"
          - match: .+
            name: string.other.format.protea
  embedded-placeholder:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2: {name: constant.numeric.decimal.protea}
      - match: (\#)((?:[*&%$]\??|\?)?[\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2: {patterns: [include: "#placeholder-variables"]}
      - begin: (\#{)\s*
        end: (})
        name: entity.quasi.component.protea
        captures:
          1: {name: punctuation.definition.anchor.protea}
        patterns:
          - include: "#function-params"
          - include: $self
  embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"
  embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.protea
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"

  # Format Specifier Language

  format-language:
    comment: Grammar for Protea's format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: type specifier
        match: (?<=[^\\%]%)\w+
        name: entity.other.attribute-name.protea
      - comment: Format switch with value /x:24
        applyEndPatternLast: 1
        begin: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)(:)
        beginCaptures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: entity.other.attribute-name.class.protea}
          3: {name: punctuation.separator.key-value.protea}
        end: (?=.)|$
        patterns: [include: "#html-properties"]
      - comment: Format switch without value
        match: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: entity.other.attribute-name.id.protea}

  # Unicode Named Character Language

  latex-sublanguage:
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - include: "#embedded"
      - name: line.separator.math.protea
        match: (\\\\)$
        captures:
          1: {name: punctuation.line.separator.math.protea}
      - name: meta.function.math.protea
        begin: ((\\)([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*))(\{)
        beginCaptures:
          1: {name: storage.type.function.math.protea}
          2: {name: punctuation.definition.function.math.protea}
          3:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: entity.name.namespace.protea
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: entity.name.function.protea
              - match: \b\:\b
                name: punctuation.separator.namespace.protea
              - match: \b\.\b
                name: punctuation.accessor.protea
          4: {name: punctuation.definition.arguments.begin.math.protea}
        end: \}
        endCaptures:
          0: {name: punctuation.definition.arguments.end.math.protea}
        patterns:
          - include: "#latex-sublanguage"
      - match: (\\)\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
        captures:
          1: {name: punctuation.definition.constant.protea}
          2:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: constant.other.namespace.protea
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: constant.character.math.protea
              - match: \b\:\b
                name: punctuation.separator.namespace.protea
              - match: \b\.\b
                name: punctuation.accessor.protea
      - match: "[-+*/^]"
        name: punctuation.math.operator.latex
      - include: "#string-escapes"
      - include: source.yaml#flow-scalar

  # Regular expressions

  regexps:
    patterns:
      - comment: Replacement section
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        contentName: string.replace.regexp.protea
        captures:
          1: {name: punctuation.section.regexp.end.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#back-references"
          - include: "#string-content"
      - comment: Pattern section
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        contentName: string.pattern.regexp.protea
        beginCaptures:
          1: {name: keyword.modifier.protea}
          2: {name: punctuation.section.regexp.begin.protea}
        endCaptures:
          1: {name: punctuation.section.regexp.end.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
  back-references:
    patterns:
      - match: \$(\d+|[+-]\d*|&)
        name: keyword.other.back-reference.protea
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.protea
      - match: \&
        name: keyword.operator.compose.protea
      - match: \.
        name: constant.character.all.protea
      - match: \\[bB]({[\w\s]+})?
        name: keyword.control.anchor.protea
      - match: \$|\\[yYzZ]({[\w\s]+})?
        name: keyword.control.end.protea}
      - match: \^|\\[AmM]({[\w\s]+})?
        name: keyword.control.begin.protea
      - match: \\K
        name: keyword.control.keepout.protea
      - match: \\G
        name: keyword.control.search.protea
      - match: \\R
        name: constant.character.control.protea
      - match: \\[XO]
        name: constant.character.unicode.protea
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.protea}
          2: {name: keyword.operator.quantifier.lazy.protea}
          3: {name: keyword.operator.quantifier.eager.protea}
          4: {name: keyword.operator.quantifier.greedy.protea}
      - match: \\\d+
        name: keyword.other.back-reference.protea
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.protea
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.protea}
          2: {name: keyword.operator.modifier.eager.protea}
          3: {name: keyword.operator.modifier.greedy.protea}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.protea}
          2: {name: keyword.operator.quantifier.eager.protea}
          3: {name: keyword.operator.quantifier.greedy.protea}
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: \\.
        name: constant.character.escape.other.protea
  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(\??([*+])
        end: \s*(\))
        name: constant.other.pcre.protea
        captures:
          0: {name: punctuation.section.expression.protea}
        patterns:
          - include: $self
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.protea
        end: \s*(\))
        name: comment.block.regexp.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - match: \\.
            name: comment.block.regexp.protea
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.look-ahead.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.protea
        captures:
          1: {name: punctuation.definition.group.look-behind.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: |
          (?x)(\(\?%)
          (
          (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (
          (?<sw>
          /\g<ident>
          (?<val>:
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          (\w+[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)*
          (?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
          )*
          )?
          )*
          )
          )
        captures:
          1: {name: punctuation.definition.directive.protea}
          2:
            name: storage.type.format.protea
            patterns:
              - include: "#format-language"
              - match: .+
                name: string.other.format.protea
        end: \s*(\))
        name: meta.group.directive.protea
        patterns: [include: "#regexp-patterns"]
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.protea
        captures:
          1: {name: punctuation.definition.group.longest.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.protea
        captures:
          0: {name: punctuation.definition.group.flag.protea}
          1: {name: punctuation.definition.group.flag.protea}
          2: {name: constant.numeric.index.protea}
          3: {name: keyword.control.recursion.protea}
          4: {name: keyword.other.flag.protea}
          5: {name: punctuation.separator.colon.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.protea
        captures:
          1: {name: punctuation.definition.group.call-out.protea}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.protea
            captures:
              1: {name: punctuation.definition.group.call-out.protea}
              2: {name: keyword.operator.range.protea}
              3: {name: punctuation.definition.tag.protea}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.protea}
            patterns:
              - include: $self
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.protea
        captures:
          1: {name: punctuation.definition.group.atomic.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.protea
        captures:
          1: {name: punctuation.definition.group.non-capturing.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.protea
        captures:
          1: {name: punctuation.definition.group.branch.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.protea
        captures:
          1: {name: punctuation.definition.group.absent.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.protea
        captures:
          0: {name: punctuation.definition.group.back-reference.protea}
          1: {name: punctuation.definition.group.back-reference.protea}
          2: {name: constant.numeric.index.protea}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.protea}
        patterns: [include: "#regexp-patterns"]
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|'|")
            end: \s*(\1)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.protea
        captures:
          1: {name: punctuation.definition.group.protea}
        patterns: [include: "#regexp-patterns"]
  regexp-char-class:
    patterns:
      - include: "#embedded"
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - include: "#attribute-selectors"
      - begin: \\j{
        end: \s*}
        name: constant.character.entity.named.protea
        patterns:
          - include: "#latex-sublanguage"
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.protea
      - match: (?i)\\p(\w\w?)
        name: constant.other.character-class.unicode.protea
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.protea
      - match: (?x)\\[a-z]
        name: constant.other.character-class.protea
      - match: (?x)\\[A-Z]
        name: constant.other.character-class.negated.protea
      - match: (?i)\\n{[\w\s\p{Pd}]+}
        name: constant.character.escape.unicode.name.protea
      - match: (?i)\\[\p{L}\p{N}]
        name: constant.character.escape.protea
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.protea
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.protea
      - match: (?x)\\\p{C}
        name: invalid.illegal.unknown-escape.protea
  regexp-char-ops:
    patterns:
      - match: (?<!\|)\|\|(?!\|)
        name: keyword.operator.union.protea
      - match: (?<!&)&&(?!&)
        name: keyword.operator.intersection.protea
      - match: (?<!\^)\^\^(?!\^)
        name: keyword.operator.symmetric.protea
      - match: (?<!~)~~(?!~)
        name: keyword.operator.negation.protea
      - match: (?<!-)--(?!-)
        name: keyword.operator.difference.protea
      - match: (?<![^\\][\\\[])-(?![-\[\]])
        name: keyword.operator.range.protea
      - match: ([^-\\\[\]]|\\.)(?<!-+)(?=(?<!\\)-)
        name: constant.other.character-class.range.from.protea
      - match: (?<=[^\\]-)(?!-+)([^-\\\[\]]|\\.)
        name: constant.other.character-class.range.to.protea
      - match: \\.
        name: constant.character.escape.other.protea
  regexp-char-set:
    patterns:
      - begin: (\[[:])
        end: (\])
        name: constant.other.character-class.posix.protea
        captures:
          1: {name: punctuation.definition.character-class.posix.protea}
        patterns: [include: "#attribute-selectors"]
      - begin: (\[[!^])
        end: (\])
        name: constant.other.character-class.negated.protea
        captures:
          1: {name: punctuation.definition.character-class.negated.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"
      - begin: (\[)
        end: (\])
        name: constant.other.character-class.protea
        captures:
          1: {name: punctuation.definition.character-class.protea}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"

  attribute-selectors:
    patterns:
      - match: ","
        name: punctuation.separator.sequence.protea
      - include: "#comments"
      - include: "#strings-quoted"
      - match: (?xi)\b[is]\b(?=[)}\]]|&&|\|\||\^\^)
        name: storage.modifier.ignore-case.protea
      - include: "#string-escapes"
      - match: "[:!=</>.^$%?*+|&~]?="
        name: keyword.operator.pattern.protea
      - match: ([&|^])\1|!
        name: keyword.operator.logical.protea
      - match: \b(i[ns])\b
        name: keyword.operator.expression.$1.protea
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: keyword.operator.pattern.protea}
        end: (?=&&|\|\||\^\^|[\s,:;'"`(){}\[\]])
        name: string.unquoted.attribute-name.protea
        patterns: [include: "#html-properties"]
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: keyword.operator.pattern.protea}
      - include: "#operators"

  # Markdown

  markdown:
    comment: Only inline Markdown syntax would be supported, plus some enhancements HAML, Textile and more. Coming soon.
    patterns: []

  # Special code blocks

  html-properties:
    patterns:
      - match: \s+
        name: meta.var.expr.protea
      - include: "#clauses"
      - include: "#declarations"
      - include: source.yaml#flow-collection
      - include: "#brackets"
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional
      - include: source.css#numeric-values
      - include: source.css#property-keywords
      - include: source.css#color-keywords
      - include: source.css#property-names
      - include: "#literals"
      - include: "#variables"
      - include: "#embedded"
  tag-names:
    match: \s*\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b\s*
    name: entity.name.tag.protea
    captures:
      1:
        name: entity.name.tag.protea
        patterns:
          - match: "[.:]"
            name: punctuation.separator.namespace.protea
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
            name: entity.name.tag.namespace.protea
          - match: ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)\b
            name: support.class.component.protea
          - include: source.css#tag-names
  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})
    captures:
      1: {name: punctuation.definition.block.protea}
    patterns: [include: "#style-properties"]
  style-properties:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: source.css.scss#variable_setting
      - include: source.css.scss#at_rule_forward
      - include: source.css.scss#at_rule_use
      - include: source.css.scss#at_rule_include
      - include: source.css.scss#at_rule_import
      - include: source.css.scss#general
      - include: source.css.scss#flow_control
      - include: source.css.scss#rules
      - include: source.css.scss#at_rule_mixin
      - include: source.css.scss#at_rule_media
      - include: source.css.scss#at_rule_function
      - include: source.css.scss#at_rule_charset
      - include: source.css.scss#at_rule_option
      - include: source.css.scss#at_rule_namespace
      - include: source.css.scss#at_rule_fontface
      - include: source.css.scss#at_rule_page
      - include: source.css.scss#at_rule_keyframes
      - include: source.css.scss#at_rule_at_root
      - include: source.css.scss#at_rule_supports
      - applyEndPatternLast: 1
        begin: |
          (?x)
          \s*
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )
          (:)\s*
        beginCaptures:
          1:
            name: support.type.property-name.protea
            patterns:
              - include: "#embedded"
              - include: source.yaml#flow-collection
              - include: "#brackets"
          8: {name: punctuation.separator.key-value.protea}
        end: (?=.)|$
        name: string.unquoted.protea
        patterns: [include: "#html-properties"]
      - include: "#style-block"
      - include: "#style-rules"
      - include: $self
  style-rules:
    patterns:
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: "#function-params"
          - include: "#style-properties"
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.selector.protea}
        patterns: [include: "#attribute-selectors"]
      - match: \s*(\@|\#|\$|\&|\*|\.|\:|::)\b
        name: punctuation.definition.entity.protea
      - match: \s*(?<=\@)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: keyword.control.at-rule.protea
      - match: \s*(?<=\#)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.id.protea
      - match: \s*(?<=\&)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.type.anchor.protea
      - match: \s*(?<=\.)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.class.protea
      - match: \s*(?<=::?)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.pseudo-component.protea
      - include: "#format-language"
      - include: "#tag-names"

  # JSX

  jsx:
    comment: Only after opening brackets, commas, semicolons, keywords, and operators. In addition, < > starts a JSX fragment.
    begin: |
      (?x)
      (?<=(?:
      ^\s*|,\s*|;\s*|
      \#?[({\[]\s*|
      [\p{Pc}\p{L}][\w\p{Pd}]*|
      (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+|
      \b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )\b)\s*)
      (?=<[\p{Pc}\p{L}]|<\s+>)
    end: (?=.)|$
    applyEndPatternLast: 1
    patterns: [include: "#tag-component-name"]
  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: string.unquoted.html.protea
        begin: \s*(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
        endCaptures:
          1: {name: punctuation.definition.tag.protea}
        patterns:
          - include: "#tag-termination"
      - comment: Tags that end > are trapped in tag-termination
        contentName: string.unquoted.html.protea
        begin: |
          (?x)\s*+(<)#start tag begin
          ([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)#tag name
          (?=[\/>\s])(?![:])(?<!\.|:)
        end: \s*(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.protea}
          3: {name: punctuation.definition.tag.protea}
          4: {name: invalid.illegal.termination.protea}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"
  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.protea
    name: meta.jsx.children.protea
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.protea}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-component-name"
      - include: "#string-content"
      - include: markdown.math.block
      - include: text.html.markdown#inline
  tag-attributes:
    patterns:
      - include: "#style-selectors"
      - include: "#attributes"
      - include: "#comments"
  attributes:
    patterns:
      - applyEndPatternLast: 1
        begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(=)\s*
        beginCaptures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: punctuation.separator.key-value.protea}
        end: (?=.)|$
        name: string.unquoted.attribute-name.protea
        patterns: [include: "#html-properties"]
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(=)?\s*
        captures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: punctuation.separator.key-value.protea}
  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.protea
  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.protea}
          2: {name: punctuation.definition.entity.protea}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.protea
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.protea
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.protea
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.protea
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.protea
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.protea
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.protea
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.protea

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"
  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*(/\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"
  line-comments:
    patterns:
      - begin: \s*(///)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*(//)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.number-sign.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline
  nested-jsdoc:
    begin: (/\*\*?)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.documentation.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"
  nested-block:
    begin: (/\*)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"
  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc
  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}
  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}
  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"
  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}
  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"
  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"
  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: (})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}
  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}
  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"
  jsdoc-name-path-scopes:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#jsdoc-string"
  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - comment: |
          Function calls (with spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?![\w\p{Pd}])
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b\s+
          (?=<\|{1,3}\s+|<\+\s+)
        captures:
          1: {patterns: [include: "#function-names"]}
      - comment: |
          Function calls (optional spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?![\w\p{Pd}])
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b
          (?=
          (?:[!?]\.=?|\.=|[?!:]:=?)?\#?\(|
          (?:[!?]\.=?|\.=|[?!:]:=?)?['"`]|
          (?:[!?]\.=?|\.=|[?!:]:=?)?<[\p{Pc}\p{L}]
          )
        captures:
          1: {patterns: [include: "#function-names"]}

  # Variables

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.protea
      - match: (?i)\s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.protea
      - match: (?i)\s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.protea
      - match: (?i)\s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.protea
      - match: (?i)\s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.protea
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.protea

  variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.protea}
      2: {name: variable.other.constant.property.protea}
      3: {name: variable.other.property.static.protea}
      4: {name: variable.other.property.protea}
      5: {name: variable.other.global.protea}
      6: {name: variable.other.constant.object.protea}
      7: {name: variable.other.conditional.protea}
      8: {name: variable.other.object.protea}
      9: {name: variable.other.dollar.protea}
      10: {name: variable.other.constant.protea}
      11: {name: variable.other.class.protea}
      12: {name: variable.other.readwrite.protea}

  # Operators

  operators:
    patterns:
      - include: "#pipeline-operator"
      - include: "#unary-ops"
      - include: "#binary-ops"
  special-operators:
    patterns:
      - begin: (?<=^|\s)(\?)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.conditional.protea}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\!)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.ternary.protea}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\$)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.macro.dollar.protea}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            name: entity.name.function.protea
          - include: $self
  binary-ops:
    patterns:
      - comment: augmented assignment += -= *= /= etc
        match: (?<=^|[\s'"`({\[])([\p{S}\p{P}&&[^!:~.<=>,;'"`(){}\[\]\p{Pc}]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=)(?=$|[\s'"`)}\]])
        name: keyword.operator.assignment.augmented.protea
      - comment: |
          BUILT-IN OPERATORS

          1: assignment : :=
          2: arithmetic + - * ** *** / // /// % %% *> <*
          3: increment/decrement ++ --
          4: logical && || ^^ !& !| !^ &| &!
          5: bitwise & | ^ ~
          6: bitwise shift << >> <<< >>>
          7: function pipeline <| |> <|| ||> <||| |||>
          8: function composition +> <+
          9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
          10: relational < > <= >=
          11: regex =< <> </ /> <$ $> <+> <*> </> <$>
          12: equality == != === !==
          13: wavy operators ~> <~ ~~> <~~
          14: fat arrow-like => ==> <==
          15: skinny arrow-like -> --> <- <--
          16: null-coalescing ??
          17: non-null coalescing !!
          18: compact ternary operator ?:
          19: inverse ternary operator !:
          20: infix function call $:
        captures:
          1: {name: keyword.operator.assignment.protea}
          2: {name: keyword.operator.arithmetic.protea}
          3: {name: keyword.operator.successor.protea}
          4: {name: keyword.operator.logical.protea}
          5: {name: keyword.operator.bitwise.protea}
          6: {name: keyword.operator.bitwise.shift.protea}
          7: {name: keyword.operator.pipeline.protea}
          8: {name: keyword.operator.compose.protea}
          9: {name: keyword.operator.class.protea}
          10: {name: keyword.operator.relational.protea}
          11: {name: keyword.operator.regexp.protea}
          12: {name: keyword.operator.comparison.protea}
          13: {name: keyword.operator.similarity.protea}
          14: {name: keyword.operator.arrow.fat.protea}
          15: {name: keyword.operator.arrow.skinny.protea}
          16: {name: keyword.operator.null-coalescing.protea}
          17: {name: keyword.operator.coalescing.protea}
          18: {name: keyword.operator.conditional.protea}
          19: {name: keyword.operator.ternary.protea}
          20: {name: keyword.operator.macro.dollar.protea}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          (:?=)#1
          |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
          |(\+\+|--)#3
          |(&&|\|\||\^\^)#4
          |([&|^~])#5
          |(<<<?|>>>?)#6
          |(\|{1,3}>|<\|{1,3})#7
          |(\+>|<\+)#8
          |([<>][!:]|[!:][<>])#9
          |([<>]=?|<=?>)#10
          |(=<|<?[/*|+$:]>?)#11
          |([!=]==?|[!=]~|~[!=])#12
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*~>|
          <~[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#13
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=>|
          <=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#14
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*->|
          <-[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#15
          |(\?\?)#16
          |(!!)#17
          |(\?:)#18
          |(!:)#19
          |(\$:)#20
          )
          (?=$|[\s'"`)}\]])# closing
      - comment: |
          CUSTOM OPERATORS

          1: custom bitwise (& | ^ ~)
          2: custom arithmetic (+ - * / %)
          3: custom prototype (:)
          4: custom accessor (.)
          5: custom equality (= !)
          6: custom comparison (< >)
          7: custom private (? #)
          8: custom mathematical (Unicode Sm)
          9: custom currency (Unicode Sc)
          10: custom ASCII (between \x80 and \xff)
          11: custom infix operators (all other chars)
        captures:
          1: {name: keyword.operator.bitwise.custom.protea}
          2: {name: keyword.operator.arithmetic.custom.protea}
          3: {name: keyword.operator.prototype.custom.protea}
          4: {name: keyword.operator.accessor.custom.protea}
          5: {name: keyword.operator.comparison.custom.protea}
          6: {name: keyword.operator.relational.custom.protea}
          7: {name: keyword.operator.private.custom.protea}
          8: {name: keyword.operator.math.custom.protea}
          9: {name: keyword.operator.currency.custom.protea}
          10: {name: keyword.operator.ascii.custom.protea}
          11: {name: keyword.operator.infix.custom.protea}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          ([&|^~][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#1
          |([+\-*/%][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#2
          |([@:][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |(\.[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |([!=][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#4
          |([<>][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          |([?\#][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#6
          |(\p{Sm}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#7
          |(\p{Sc}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#8
          |([\p{S}\p{P}&&[\x80-\xFF]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#9
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#10
          )
          (?=$|[\s'"`)}\]])# closing
  unary-ops:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`)}\]])# closing
          (?:
          ([>.]\.[.<])#1
          |(\?[.:]=?)#2
          |(![.:]=?)#3
          |((?:::|\.)=?)#4
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          )
          (?=\b|['"`({\[])# opening
        captures:
          1: {name: keyword.operator.range.protea}
          2: {name: keyword.operator.optional.protea}
          3: {name: keyword.operator.assert.protea}
          4: {name: keyword.operator.accessor.protea}
          5: {name: keyword.operator.primary.protea}
      - &prefix-operators
        comment: Prefix operators
        match: |
          (?x)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
          (?=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          [\w({\['"`])
        name: keyword.operator.prefix.protea
        captures:
          1: {name: keyword.operator.module.all.protea}
          2: {name: keyword.operator.increment.protea}
          3: {name: keyword.operator.decrement.protea}
          4: {name: keyword.operator.intersection.protea}
          5: {name: keyword.operator.union.protea}
          6: {name: keyword.operator.symmetric.protea}
          7: {name: keyword.operator.logical.protea}
          8: {name: keyword.operator.private.protea}
          9: {name: keyword.operator.decorator.protea}
          10: {name: keyword.operator.bitwise.not.protea}
          11: {name: keyword.operator.existential.protea}
          12: {name: keyword.operator.assignment.protea}
          13: {name: keyword.operator.pipeline.protea}
          14: {name: keyword.operator.private.protea}
          15: {name: keyword.operator.prefix.protea}
      - &suffix-operators
        comment: Suffix operators
        match: |
          (?x)
          (?<=[)}\]\w'"`]
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
        name: keyword.operator.suffix.protea
        captures:
          1: {name: keyword.operator.module.all.protea}
          2: {name: keyword.operator.increment.protea}
          3: {name: keyword.operator.decrement.protea}
          4: {name: keyword.operator.intersection.protea}
          5: {name: keyword.operator.union.protea}
          6: {name: keyword.operator.symmetric.protea}
          7: {name: keyword.operator.assert.protea}
          8: {name: keyword.operator.private.protea}
          9: {name: keyword.operator.decorator.protea}
          10: {name: keyword.operator.bitwise.protea}
          11: {name: keyword.operator.optional.protea}
          12: {name: keyword.operator.assignment.protea}
          13: {name: keyword.operator.pipeline.protea}
          14: {name: keyword.operator.private.protea}
          15: {name: keyword.operator.suffix.protea}
  pipeline-operator:
    patterns:
      - applyEndPatternLast: 1
        begin: |
          (?x)\s*(?:(\+>)|(\|{1,3}>))(?=\s*(
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?![\w\p{Pd}])
          )
          [\w]+
          (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# primary
          [\w]+)*
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# suffix
          )\s*([^(]|$|;))
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.compose.protea}
          2: {name: keyword.operator.pipeline.protea}
        patterns:
          - match: |
              (?x)\s*\b
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
              \b(?:# keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|val|func|proc|type
              |class|data|enum|module
              |iter|macro|struct|object
              |trait|style|compo|prop
              |go|defer|do|from|where|with
              |if|elif|else|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|goto|pass
              |break|next|redo|retry
              |return|yield|await|label
              |import|export|route
              |debug|assert|check
              )(?![\w\p{Pd}])
              )
              (?:
              (?:# Objects
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
              |
              (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
              (?:# Properties
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              |
              (?:# Regular variables
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              )\b
            captures:
              1: {name: variable.other.global.protea}
              2: {name: variable.other.constant.object.protea}
              3: {name: variable.other.conditional.protea}
              4: {name: variable.other.object.protea}
              5: {name: entity.name.tag.protea}
              6: {name: entity.name.tag.protea support.class.component.protea}
              7: {name: entity.name.class.builtin.protea}
              8: {name: entity.name.function.method.protea}
              9: {name: entity.name.function.tagged-template.protea}
              10: {name: entity.name.type.protea}
              11: {name: entity.name.class.protea}
              12: {name: entity.name.function.protea}
          - *primary-operators

  # Types

  types:
    patterns:
      - match: \s*(==?>|--?>|~~?>)
        name: keyword.operator.type.function.protea
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.protea
      - include: "#params-clause"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#type-variables"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#type-strings"
      - include: "#literals"
  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
      \b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?![\w\p{Pd}])
      )
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}]\w+\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ([\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )\b
    captures: &type-variables
      1: {name: entity.name.module.protea}
      2: {name: entity.name.tag.protea}
      3: {name: entity.name.namespace.protea}
      4: {name: entity.name.interface.protea}
      5: {name: entity.name.tag.block.protea}
      6: {name: entity.name.tag.script.protea}
      7: {name: entity.name.tag.style.protea}
      8: {name: entity.name.tag.inline.protea}
      9: {name: entity.name.label.protea}
      10: {name: entity.name.project.protea}
      11: {name: entity.name.class.protea}
      12: {name: entity.name.type.protea}
  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=.)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.protea}
    patterns:
      - include: "#types"
  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.protea
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.protea
        patterns:
          - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.binding-pattern.object.protea}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.mapping.protea}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.protea}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.protea
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.protea}
            patterns:
              - include: "#punctuation"
              - include: "#function-params"
              - include: "#types"
              - include: $self
          - begin: \s*(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
                captures:
                  1: {name: punctuation.separator.slice.protea}
              - match: ","
                name: punctuation.separator.sequence.protea
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.attribute-selector.protea}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.sequence.protea}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.protea
              - include: "#types"
              - include: $self
          - begin: \s*(\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.protea}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.protea
              - include: "#types"
              - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#type-embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - match: "''"
            name: constant.character.escape.protea
          - include: "#type-embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"

  type-embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.component.protea
        captures:
          1: {name: punctuation.section.embedded.protea}
        patterns: [include: "types", include: $self]
      - match: |
          (?x)(\$)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.protea}
          2: {patterns: [include: "#types", include: "#everything-but-comments"]}

  type-embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.protea
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?![\w\p{Pd}])\s*
        name: storage.type.extends.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)(?![\w\p{Pd}])\s*
        name: storage.type.implements.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|pairof|infer|as|is)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.$1.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(instof)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.instanceof.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(valof)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.valueof.protea

  type-operators:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`\\)}\]])
          (?:
          ([>.]\.[.<])
          |(\?[.:]=?)
          |(![.:]=?)
          |((?:::|\.)=?)
          )
          (?=\b|['"`\\({\[])
        captures:
          1: {name: keyword.operator.range.protea}
          2: {name: keyword.operator.optional.protea}
          3: {name: keyword.operator.assert.protea}
          4: {name: keyword.operator.accessor.protea}
      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.protea}
          2: {name: keyword.operator.difference.protea}
          3: {name: keyword.operator.product.protea}
          4: {name: keyword.operator.quotient.protea}
          5: {name: keyword.operator.remainder.protea}
          6: {name: keyword.operator.only.protea}
          7: {name: keyword.operator.maybe.protea}
          8: {name: keyword.operator.intersection.protea}
          9: {name: keyword.operator.union.protea}
          10: {name: keyword.operator.symmetric.protea}
          11: {name: keyword.operator.negation.protea}
          12: {name: keyword.operator.macro.dollar.protea}
          13: {name: keyword.operator.private.protea}
          14: {name: keyword.operator.class.protea}

  # Clauses and Keywords

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
        name: entity.name.namespace.protea
      - applyEndPatternLast: 1
        begin: \s+(impl)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.implements.protea}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.namespace.protea
          - match: *class-name
            name: entity.name.trait.protea
          - include: "#punctuation"
      - applyEndPatternLast: 1
        begin: \s+(ext)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.protea}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.module.protea
          - match: *class-name
            name: entity.name.interface.protea
          - include: "#punctuation"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.protea
      - include: "#type-operators"
      - include: "#operators"
      - include: "#literals"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]))
        end: (?=.)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.protea}
        patterns: [include: "#types"]
      - include: "#comments"
      - include: "#brackets"
      - include: "#line-continuation"
      - include: "#comma"

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      # Visibility and mutability
      pub|priv|prot|after|mut|immut
      |glo|loc|early|late|covar|contra
      |seal|abst|inter|exter|imply|exply
      |sub

      # Concurrency/thread
      |sync|async|stat|dyn|lazy|eager|bound|free

      # Function and methods
      |rec|gen|oper|get|set|post|del|curry|inline
      |prefix|suffix|infix|binary|unary|left|right
      )
      )(?![\w\p{Pd}])\s*
      )*
      )
      (?=
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - &decorators
            match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
            name: entity.name.class.decorator.protea
          - &modifiers
            match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|after|mut|immut
              |glo|loc|early|late|covar|contra
              |seal|abst|inter|exter|imply|exply
              |sub
              )|
              (# Function or method modifiers
              sync|async|stat|dyn|lazy|eager|bound|free
              )|
              (# Property modifiers
              rec|gen|oper|get|set|post|del|curry|inline
              |prefix|suffix|infix|binary|unary|left|right
              )
              )(?![\w\p{Pd}])\s*
            captures:
              1: {name: storage.modifier.protea}
              2: {name: storage.type.accessor.protea}
              3: {name: storage.type.property.protea}
              4: {name: keyword.operator.expression.protea}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
        name: keyword.other.declare.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?![\w\p{Pd}])\s*
        name: storage.type.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?![\w\p{Pd}])\s*
        name: storage.type.style.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)\b\s*
        name: storage.type.function.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        name: storage.type.procedure.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        name: storage.type.class.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        name: storage.type.data.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        name: storage.type.enum.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        name: storage.type.module.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        name: storage.type.iterator.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        name: storage.type.macro.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        name: storage.type.structure.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        name: storage.type.object.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        name: storage.type.trait.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)\b\s*
        name: storage.type.component.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)\b\s*
        name: storage.type.property.protea

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif|else)(?![\w\p{Pd}])\s*
        name: keyword.control.conditional.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|loop|while)(?![\w\p{Pd}])\s*
        name: keyword.control.loop.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|after)(?![\w\p{Pd}])\s*
        name: keyword.control.trycatch.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|case|fail)(?![\w\p{Pd}])\s*
        name: keyword.control.switch.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?![\w\p{Pd}])\s*
        name: keyword.control.flow.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?![\w\p{Pd}])\s*
        name: keyword.control.module.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from|ref|go|defer)(?![\w\p{Pd}])\s*
        name: keyword.control.$1.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)(?![\w\p{Pd}])\s*
        name: keyword.other.$1.protea

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.$1.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.delete.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.range.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.void.protea
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)(?![\w\p{Pd}])\s*
        name: keyword.operator.expression.logical.protea

  keywords:
    patterns:
      - include: "#validation-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.control.flow.protea}
        patterns:
          - match: *entity-name
            name: constant.other.label.protea

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.control.module.protea}
            patterns:
              - include: source.yaml#flow-collection
              - *modifiers
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                name: keyword.control.module.protea
              - include: "#type-keywords"
              - include: "#declarations"
              - include: "#strings-quoted"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.protea
              - match: *entity-name
                name: variable.other.readwrite.alias.protea

      validation-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?![\w\p{Pd}])\s*
        beginCaptures:
          1: {name: keyword.control.validate.protea}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?![\w\p{Pd}])\s*
            name: keyword.control.validate.protea
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?![\w\p{Pd}])\s*
            name: keyword.control.validate.protea
          - include: $self

      query-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?![\w\p{Pd}])\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?![\w\p{Pd}])\s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.protea}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - include: "#query-body"
          - include: $self
      query-body:
        patterns:
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"
        repository:
          join-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part|self|cross)?(?![\w\p{Pd}])\s*\b(?:inner|outer|left|right)?(?![\w\p{Pd}])\s*\bjoin)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(on|equals|into)(?![\w\p{Pd}])\s*
                name: keyword.control.query.protea
              - include: "#query-body"
              - include: $self
          where-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          sort-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sort(?![\w\p{Pd}])\s*\b(?:asc|desc)?(?![\w\p{Pd}])\s*\b(?:by|with)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          select-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:select|map)(?![\w\p{Pd}])\s*\b(?:unique|any|all)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.protea
              - include: "#query-body"
              - include: $self
          limit-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit)(?![\w\p{Pd}])\s*\b(?:first|last|head|tail)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.protea
              - include: "#query-body"
              - include: $self
          reduce-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?![\w\p{Pd}])\s*\b(?:left|right)?)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?![\w\p{Pd}])\s*
                name: keyword.control.query.protea
              - include: "#query-body"
              - include: $self
          group-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)(?![\w\p{Pd}])\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)(?![\w\p{Pd}])\s*
                name: keyword.control.query.protea
              - include: "#query-body"
              - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#function"
      - include: "#procedure"
      - include: "#class"
      - include: "#data"
      - include: "#enum"
      - include: "#module"
      - include: "#iterator"
      - include: "#macro"
      - include: "#structure"
      - include: "#object"
      - include: "#trait"
      - include: "#component"
      - include: "#property"

    repository:
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.style.protea}
        patterns:
          - include: "#style-rules"
          - include: "#style-block"
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.protea

      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.variable.protea}
      declare:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.other.declare.protea}

      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.function.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.protea
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.procedure.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.protea
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.class.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.protea
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.data.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.protea
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.enum.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.protea
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.module.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.protea
      iterator:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.iterator.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.iterator.protea
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.macro.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.protea
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.structure.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.protea
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.object.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.protea
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.trait.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.protea
      component:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.component.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.component.protea
      property:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.property.protea}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.property.protea

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: *function-params
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: *function-params

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|[,;]\s*|\#?[({\[]\s*
      |(?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+
      |\b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.protea}
    end: (?<!\|)(\|)(?!\|)
    patterns: *function-params

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#params-clause"
      - include: "#function-clause"

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: "#function-params"
      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?![\w\p{Pd}])
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.protea}
        patterns:
          - match: *entity-name
            name: entity.name.instance.protea
          - include: "#type-keywords"
          - include: "#illegal-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"
      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.protea}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?![\w\p{Pd}])\s*
            end: (?=.)|$
            captures:
              1: {name: keyword.other.typedef.protea}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.protea}
              - include: "#types"
      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|after)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.catch.protea
        captures:
          1: {name: keyword.control.error.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
                name: keyword.control.error.protea
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
            name: keyword.control.error.protea
          - include: $self
      do-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(do)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.do.protea
        captures:
          1: {name: keyword.control.do.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - include: $self
      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.for.protea
        captures:
          1: {name: keyword.control.loop.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - &for-clause-keywords
            match: \s*\b(in|of)\b
            name: keyword.control.loop.protea
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - *for-clause-keywords
              - include: $self
          - include: $self
      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif|else)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.if.protea
        captures:
          1: {name: keyword.control.conditional.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - include: $self
      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?![\w\p{Pd}])\s*
        end: (?<=;|})|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.switch.protea
        captures:
          1: {name: keyword.control.switch.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.section.class.protea}
            patterns:
              - &case-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.protea}
                  2: {name: punctuation.separator.colon.protea}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?![\w\p{Pd}])\s*
                    end: (?=.)|$
                    beginCaptures:
                      1: {name: keyword.control.switch.protea}
                    patterns:
                      - include: "#types"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.protea
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.protea
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                    name: keyword.control.switch.protea
                  - include: "#type-keywords"
                  - include: $self
              - &default-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.protea}
                  2: {name: punctuation.separator.colon.protea}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.block.protea}
            patterns:
              - *case-clause
              - *default-clause
              - include: $self
          - include: $self
      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?![\w\p{Pd}])\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.with.protea
        captures:
          1: {name: keyword.control.with.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?![\w\p{Pd}])\s*
            name: keyword.control.with.protea
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - *with-clause-keywords
              - include: $self
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: *function-params
      - match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
        name: meta.object-literal.key.protea
        captures:
          1:
            name: constant.other.object.key.protea
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"
          2: {name: punctuation.separator.key-value.protea}

  # Punctuation

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#semicolon"

  line-continuation:
    match: \\\n*|(\\)\s*(?=/[/*+]|$)
    name: punctuation.separator.continuation.line.protea
  comma:
    match: \s*(,)
    name: punctuation.separator.comma.protea
  double-semi:
    match: \s*(;;)
    name: punctuation.terminator.expression.protea
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.protea

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.protea
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.protea
      closures:
        patterns:
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?![\w\p{Pd}])\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.switch.protea}
              2: {name: punctuation.separator.colon.protea}
            patterns:
              - include: "#params-clause"
              - applyEndPatternLast: 1
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?![\w\p{Pd}])\s*
                end: (?=.)|$
                beginCaptures:
                  1: {name: keyword.control.switch.protea}
                patterns:
                  - include: "#types"
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?![\w\p{Pd}])\s*
                name: keyword.control.switch.protea
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?![\w\p{Pd}])\s*
                name: keyword.control.switch.protea
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?![\w\p{Pd}])\s*
                name: keyword.control.switch.protea
              - include: "#type-keywords"
              - include: $self
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?![\w\p{Pd}])\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?![\w\p{Pd}])|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.switch.protea}
              2: {name: punctuation.separator.colon.protea}
            patterns:
              - include: $self
          - include: $self
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.typeparameters.protea}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|[,;({\[]|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|[,;({\[]|[)}\]\w'"`]:\s|\s[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: "#closures"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: "#closures"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.protea
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: "#punctuation"
          - include: "#function-params"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
            captures:
              1: {name: punctuation.separator.slice.protea}
          - match: ","
            name: punctuation.separator.sequence.protea
    patterns:
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.protea}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.protea}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.protea
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.protea
          - include: $self

name: Trinity
scopeName: source.dart
fileTypes: [dart, trin]
patterns: [include: "#core"]

Information for Contributors: |
  Trinity is a typed, multi-paradigm and multi-faceted programming language, and can be used to safely
  build and test complex software, apps and libraries for web, desktop and mobile; or for the frontend,
  API and backend. Trinity will be entirely implemented and integrated with JavaScript and the web
  ecosystem.

  The language is very similar to Go, Swift, Kotlin or Scala, tied with a unified, comprehensive and
  clean API with minimal abstractions, supported out of the box.

  Should you want to provide a fix or improvement, or perhaps to change or add a new feature, or even
  some general constructive feedback, make a pull request, or an issue on this very repository, and I will
  be very happy to receive it/them.

  This grammar is still under construction, and there would be a couple of features being planned. I'm
  currently working on the language spec, so hold a while.

  Go visit my Trello to find out what I'm working on:
  https://trello.com/b/A3NDX7qY/trinity-language

  Some parts such as numeric literals, HTML character entities and more are partially
  or entirely generated through code by means of compressed tries and DFA minimization
  (Brzozowski algorithm).

comment: |
  To-Do:

  - Add keywords for types from SQL
  - Add grammars for Unicode character entities
    - HTML5, AGL and LaTeX
    - Locale and Unicode script codes (done)
    - Transformation directives (%)

  - Add standard library functions, types, classes,
    modules, properties, variables in this order:
    - JavaScript/TypeScript
    - Swift
    - Java, Scala, Kotlin, Flix
    - Haskell, OCaml
    - Go, Rust
    - R
    - Python (names, methods, etc), Perl, Ruby, Lua
    - C, Objective C(++)
    - PHP (needs a bit of cleanup)

  Done:
  - Reworked keywords. Should be enough; added support for decorators too.
  - Syntax changed, mirrors C# now.
  - Oniguruma uses \w to refer to _\d\p{L}\p{M}, use character
    set operations && and ^ to perform set subtractions
  - Added extended JSX syntax (might still need some modifications)

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.trin}
    2: {name: punctuation.separator.decimal.period.trin}
    3: {name: punctuation.separator.decimal.fraction.trin}
    4: {name: constant.numeric.other.exponent.trin}
    5: {name: constant.numeric.other.density.trin}
    6: {name: storage.type.numeric.trin}

  entity-name-clause: &entity-name-clause |
    (?x)\s*\b
    (?<=(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:ext|impl)\b|\s*[<>]\s+)\s*

    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|new|to|til|thru|by|del|unset
    |var|val|let|const|decl|def|fun|type|sin
    |class|enum|mod|pack|struct|inter|space|prag
    |proc|proto|macro|given|style|elem|field
    |ext|pred|data|trait|lemma|iter|sub|prop
    |if|un|elif|elun|else|then
    |for|each|loop|while|until|when
    |with|do|from
    |try|throw|catch|fix
    |switch|match|case|fail
    |tandem|unison|series|spawn|kill|lock
    |break|next|redo|retry|return|await|label|yield|goto|pass
    |import|export|using
    |debug|assert|where
    )\b
    )
    ([\p{Pc}\p{L}]\w*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|new|to|til|thru|by|del|unset
    |var|val|let|const|decl|def|fun|type|sin
    |class|enum|mod|pack|struct|inter|space|prag
    |proc|proto|macro|given|style|elem|field
    |ext|pred|data|trait|lemma|iter|sub|prop
    |if|un|elif|elun|else|then
    |for|each|loop|while|until|when
    |with|do|from
    |try|throw|catch|fix
    |switch|match|case|fail
    |tandem|unison|series|spawn|kill|lock
    |break|next|redo|retry|return|await|label|yield|goto|pass
    |import|export|using
    |debug|assert|where
    )\b
    )
    ([\p{Pc}\p{L}]\w*)
    \b

  posix-class: &posix-class |
    (?xi)
    \\o|
    \\p(?:
    # POSIX
    alpha|alnum|ascii|blank|cntrl|x?digit
    |graph|lower|print|punct|space|prag|upper|word
    # Extended-POSIX
    |symbol|open|close|dash|link|start|final|math|money
    |number|letter|title|mark|modify
    |bin|qua|sen|oct|dec|doz|hex
    )

repository:
  core:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.other.trin
      - match: '[\w]+?'
        name: invalid.illegal.variable.other.trin
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.trin
      - match: \S+?
        name: invalid.illegal.syntax.trin

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|fun|type|sin
      |class|enum|mod|pack|struct|inter|space|prag
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|fix
      |switch|match|case|fail
      |tandem|unison|series|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b\s*
    name: invalid.illegal.keyword.trin

  # Support

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|Nat)
          |Imaginary|Complex|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          )\b
        name: support.type.builtin.primitive.trin
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map|Bag)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          )\b
        name: support.type.builtin.trin
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit
          |Any|Mixed|Just|Some|None|Never|Const|(Im)?pure
          |Class|Enum|Mod|Pkg|Inter|Struct|Obj|Rec
          |Frag|Nspace|Data|Trait|Proto|Proc|Macro|Type|Given
          |Raw|Style|Comp|Elem|Decl|Ext|Impl|Sub|Chan
          )\b
        name: support.type.primitive.trin

      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.trin
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.trin
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.trin
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.trin

      - comment: Swift
      - include: source.swift#builtin-types
      - comment: Python
      - include: source.python#builtin-types
      - comment: JS
      - include: "#support-js"
      - comment: PHP
      - include: source.php#class-builtin

  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.trin
      - comment: magic functions
        match: (?x)\s*\b_+([\p{Pc}\p{L}]\w*)+_+\b\s*
        name: support.function.magic.trin
      - comment: Swift
      - include: source.swift#builtin-functions
      - comment: JavaScript
      - include: source.js#support-objects
      - comment: Python
      - include: source.python#builtin-functions
      - comment: PHP
      - include: source.php#support
      - comment: SASS
      - include: source.css.sass#constant_sass_functions
      - comment: Other (coming soon!)
      - match: |
          (?x)\b(?:
          (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties (note all properties are by default, symbols)
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          |
          (?:# Objects and maps
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
          |
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.trin}
          2: {name: entity.name.tag.trin support.class.component.trin}
          3: {name: entity.name.class.builtin.trin}
          4: {name: entity.name.function.method.trin}
          5: {name: variable.other.global.trin}
          6: {name: variable.other.constant.object.trin}
          7: {name: variable.other.conditional.trin}
          8: {name: variable.other.object.trin}
          9: {name: entity.name.function.tagged-template.trin}
          10: {name: entity.name.type.trin}
          11: {name: entity.name.class.trin}
          12: {name: entity.name.function.trin}
      - include: $self

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns:
      - comment: Python
      - include: source.python#magic-variable-names

  variable-names:
    comment: Standard Library variable names
    patterns:
      - comment: Python
      - include: source.python#magic-function-names

  property-names:
    comment: Standard Library property names
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )\b\s*
        captures:
          1: {name: constant.language.boolean.true.trin}
          2: {name: constant.language.boolean.false.trin}
          3: {name: constant.language.null.trin}
          4: {name: constant.language.undefined.trin}
          5: {name: constant.language.nan.trin}
          6: {name: constant.language.infinity.trin}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (it|this|that|super|self|target)#1
          |(params)#2
          |(ctor)#3
          |(prot)#4
          |(pro)#5
          )\b\s*
        captures:
          1: {name: variable.language.$1.trin}
          2: {name: variable.language.arguments.trin}
          3: {name: variable.language.constructor.trin}
          4: {name: variable.language.prototype.trin}
          5: {name: variable.language.proto.trin}

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.trin
      - match: (?<=(^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.trin
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix/base prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# integer & numerator part
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional part
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?|# repeating part
          (\/)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)# radix prefix
          (?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?# integer/numerator
          (?:
          (\.)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*)?(?:# fractional
          (\~)(?:\p{Alnum}+(?:\p{Pc}*\p{Alnum}+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0b)# radix/base prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)# integer & numerator part
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional part
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?|# repeating part
          (\/)(?:[01]+(?:\p{Pc}*[01]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0b)# radix prefix
          (?:[01]+(?:\p{Pc}*[01]+)*)?# integer/numerator
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:# fractional
          (\~)(?:[01]+(?:\p{Pc}*[01]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.binary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0q)# radix/base prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional part
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?|# repeating part
          (\/)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0q)# radix prefix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:# fractional
          (\~)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0s)# radix/base prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional part
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?|# repeating part
          (\/)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0s)# radix prefix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:# fractional
          (\~)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.senary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0o)# radix/base prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)# integer & numerator part
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional part
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?|# repeating part
          (\/)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0o)# radix prefix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)?# integer/numerator
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:# fractional
          (\~)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.octal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0z)# radix/base prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)# integer & numerator part
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional part
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?|# repeating part
          (\/)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0z)# radix prefix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)?# integer/numerator
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:# fractional
          (\~)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0x)# radix/base prefix
          (?:\h+(?:\p{Pc}*\h+)*)# integer & numerator part
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional part
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?|# repeating part
          (\/)(?:\h+(?:\p{Pc}*\h+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (0x)# radix prefix
          (?:\h+(?:\p{Pc}*\h+)*)?# integer/numerator
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:# fractional
          (\~)(?:\h+(?:\p{Pc}*\h+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          ()# radix/base prefix
          (?:\d+(?:\p{Pc}*\d+)*)# integer & numerator part
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional part
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?|# repeating part
          (\/)(?:\d+(?:\p{Pc}*\d+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          ()# radix prefix
          (?:\d+(?:\p{Pc}*\d+)*)?# integer/numerator
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:# fractional
          (\~)(?:\d+(?:\p{Pc}*\d+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix/base prefix
          (?:\w+(?:\p{Pc}*\w+)*)# integer & numerator part
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional part
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?|# repeating part
          (\/)(?:\w+(?:\p{Pc}*\w+)*)# denominator part
          )?
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))# radix prefix
          (?:\w+(?:\p{Pc}*\w+)*)?# integer/numerator
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:# fractional
          (\~)(?:\w+(?:\p{Pc}*\w+)*))?# repeating
          ()# denominator
          )
          ((?:\*(?:0|[1-9]\d*))?\^[+-]?(?:0|[1-9]\d*))?# exponential part
          (\=\!?[+-]?(?:0|[1-9]\d*))?# significant figure part
          (\:[\p{Pc}\p{L}]\w*)?# type suffix
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: punctuation.separator.decimal.repeating.trin}
          4: {name: punctuation.separator.decimal.fraction.trin}
          5: {name: constant.numeric.other.exponent.trin}
          6: {name: constant.numeric.other.precision.trin}
          7: {name: storage.type.numeric.trin}

  strings-quoted:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#embedded-raw"
      - comment: single quoted string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - match: "''"
            name: constant.character.escape.trin
          - include: "#embedded-raw"
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.trin
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#string-content"
      - comment: double quoted string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.trin
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#string-content"

  strings-unquoted:
    patterns:
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.trin
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.trin
            patterns:
              - include: "#string-content"
              - include: text.html.markdown#inline
          - include: $self
      - begin: \s*(\\)
        beginCaptures:
          1: {name: punctuation.definition.string.trin}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/>|::|!:|\?:|\.|!\.|\?\.)
        name: string.unquoted.trin
        patterns:
          - include: "#string-content"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: (?ix)\\b[01]{1,21}
        name: constant.character.escape.binary.trin
      - comment: Binary escape sequences
        begin: (?ix)\\b{
        end: \s*}
        name: constant.character.escape.binary.trin
        patterns:
          - match: \b[01]{1,21}\b
            name: constant.character.escape.binary.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Quaternary escape sequences
        match: (?ix)\\q[0-3]{1,11}
        name: constant.character.escape.quaternary.trin
      - comment: Quaternary escape sequences
        begin: (?ix)\\q{
        end: \s*}
        name: constant.character.escape.quaternary.trin
        patterns:
          - match: \b[0-3]{1,11}\b
            name: constant.character.escape.quaternary.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Senary escape sequences
        match: (?ix)\\s[0-5]{1,8}
        name: constant.character.escape.senary.trin
      - comment: Senary escape sequences
        begin: (?ix)\\s{
        end: \s*}
        name: constant.character.escape.senary.trin
        patterns:
          - match: \b[0-5]{1,8}\b
            name: constant.character.escape.senary.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Octal escape sequences
        match: (?ix)\\o[0-7]{1,7}
        name: constant.character.escape.octal.trin
      - comment: Octal escape sequences
        begin: (?ix)\\o{
        end: \s*}
        name: constant.character.escape.octal.trin
        patterns:
          - match: \b[0-7]{1,7}\b
            name: constant.character.escape.octal.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Decimal escape sequences
        match: (?ix)\\d?\d{1,7}
        name: constant.character.escape.decimal.trin
      - comment: Decimal escape sequences
        begin: (?ix)\\d{
        end: \s*}
        name: constant.character.escape.decimal.trin
        patterns:
          - match: \b\d{1,7}\b
            name: constant.character.escape.decimal.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Duodecimal escape sequences
        match: (?ix)\\z[\dab]{1,6}
        name: constant.character.escape.duodecimal.trin
      - comment: Duodecimal escape sequences
        begin: (?ix)\\z{
        end: \s*}
        name: constant.character.escape.duodecimal.trin
        patterns:
          - match: \b[\dab]{1,6}\b
            name: constant.character.escape.duodecimal.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin
      - comment: Hexadecimal escape sequences
        match: (?ix)\\[ux]\h{1,6}
        name: constant.character.escape.hexadecimal.trin
      - comment: Hexadecimal escape sequences
        begin: (?ix)\\[ux]{
        end: \s*}
        name: constant.character.escape.hexadecimal.trin
        patterns:
          - match: \b\h{1,6}\b
            name: constant.character.escape.hexadecimal.trin
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.trin

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.trin
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.trin
        patterns:
          - include: "#named-char-notation"
      - include: "#numeric-escapes"
      - match: (?i)\\[a-z]
        name: constant.character.escape.trin
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.trin
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.trin
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.trin

  embedded:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [include: $self]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: ([$%#])\1
        name: constant.character.escape.trin
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [include: $self]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: $self

  # Format Specifier Language

  format-specifiers:
    comment: Grammar for Trinity's format specifier language, inspired by
      MS-DOS, Bash and Python's f-strings.
    repository:
      attribute-values:
        patterns:
          - include: "#constants"
          - include: "#string-content"
          - include: source.yaml#flow-scalar-plain-out-implicit-type
          - include: source.css#numeric-values
          - include: source.css#property-keywords
          - include: source.css#color-keywords
          - include: source.css#property-names
          - include: source.css.scss#constant_functions
          - include: source.css.scss#constant_sass_functions
          - include: source.css.scss#constant_important
          - include: source.css.scss#constant_default
          - include: source.css.scss#constant_optional
          - include: "#numbers"
    patterns:
      - comment: type specifier
        match: (?<=[^\\%]%)\w+
        name: entity.other.attribute-name.trin
      - comment: Format switch with value /x:24
        match: (?<!\\)(/)([\p{Pc}\p{L}]\w*)(:)((?:[^\s'"`<=>\\/]|\\.|(?<!\w)/(?!>))*)
        captures:
          1: {name: punctuation.separator.mapping.trin}
          2: {name: entity.other.attribute-name.class.trin}
          3: {name: punctuation.separator.key-value.trin}
          4:
            name: string.unquoted.attribute-name.trin
            patterns: [include: "#attribute-values"]
      - comment: Format switch with value /x:24
        match: (?<!\\)(/)([\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.separator.mapping.trin}
          2: {name: entity.other.attribute-name.id.trin}

  # Unicode Named Character Language

  named-char-notation:
    comment: Grammar for the Unicode Named Character Mini-Language.
    repository:
      character-names:
        patterns:
          - match: (?x)\b([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?=[.:])
            name: entity.name.tag.namespace.trin
          - match: ([\p{Pc}\p{L}][\p{Pd}\w]*)
            name: entity.name.tag.trin
          - match: ":"
            name: punctuation.separator.namespace.trin
          - match: \.
            name: punctuation.accessor.trin
      latex-notation:
        patterns:
          - name: comment.line.math.trin
            match: (%)(.+)$
            captures:
              1: {name: punctuation.definition.comment.math.trin}
          - name: line.separator.math.trin
            match: (\\\\)$
            captures:
              1: {name: punctuation.line.separator.math.trin}
          - name: meta.function.math.trin
            begin: ((\\)([\p{Pc}\p{L}][\p{Pd}\w]*))(\{)
            beginCaptures:
              1: {name: storage.type.function.math.trin}
              2: {name: punctuation.definition.function.math.trin}
              3: {name: entity.name.function.math.trin}
              4: {name: punctuation.definition.arguments.begin.math.trin}
            end: \}
            endCaptures:
              0: {name: punctuation.definition.arguments.end.math.trin}
            patterns:
              - include: "#named-char-notation"
          - captures:
              1: {name: punctuation.definition.constant.math.trin}
            match: (\\)([\p{Pc}\p{L}][\p{Pd}\w]*)\b
            name: constant.character.math.trin
          - captures:
              1: {name: punctuation.definition.constant.math.trin}
            match: (\\)(?!begin\{|verb)([\p{Pc}\p{L}][\p{Pd}\w]*)
            name: constant.other.general.math.trin
          - match: (?<!\\)\{
            name: meta.brace.curly.trin
          - match: (?<!\\)\}
            name: meta.brace.curly.trin
          - match: \(
            name: meta.brace.round.trin
          - match: \)
            name: meta.brace.round.trin
          - match: (([0-9]*[\.][0-9]+)|[0-9]+)
            name: constant.numeric.math.trin
          - match: "[-+*/^]"
            name: punctuation.math.operator.latex
    patterns:
      - include: "#character-names"
      - include: "#latex-notation"
      - include: "#regexp-patterns"

  # Symbols

  symbols:
    patterns:
      - match: \s*(:)(?=['"])
        name: punctuation.definition.symbol.trin
      - begin: \s*(:)(\w|\\.)
        beginCaptures:
          1: {name: punctuation.definition.symbol.trin}
          2: {name: constant.other.symbol.trin}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/>|::|!:|\?:|\.|!\.|\?\.)
        name: constant.other.symbol.trin
        patterns:
          - include: "#string-content"

  # Regular expressions

  regexps:
    patterns:
      - comment: Block regex
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        contentName: string.replace.regexp.trin
        captures:
          1: {name: punctuation.section.regexp.end.trin}
          2: {name: keyword.other.flag.trin}
        patterns:
          - include: "#back-references"
          - include: "#string-content"
      - comment: Block regex
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        contentName: string.pattern.regexp.trin
        beginCaptures:
          1: {name: keyword.modifier.trin}
          2: {name: punctuation.section.regexp.begin.trin}
        endCaptures:
          1: {name: punctuation.section.regexp.end.trin}
          2: {name: keyword.other.flag.trin}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
      - begin: |
          (?x)\s*
          (\\\=)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.replace.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.replace.regexp.trin
            patterns:
              - include: "#back-references"
              - include: "#string-content"
          - include: $self
      - begin: |
          (?x)\s*
          (\\\<)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.pattern.regexp.trin
            patterns:
              - include: "#regexp-patterns"
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+|[&+-])
        name: keyword.other.back-reference.trin
      - match: \${2}
        name: constant.character.escape.trin
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.trin
        captures:
          1: {name: keyword.other.back-reference.trin}
        patterns: &regex-back-references
          - include: "#function-names"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.trin
        captures:
          1: {name: keyword.other.back-reference.trin}
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.trin
      - match: \&
        name: keyword.operator.compose.trin
      - match: \.
        name: constant.character.all.trin
      - match: (?i)\\[mM]({\p{L}+})?
        name: keyword.control.anchor.trin
      - match: \$|(?i)\\[yz]({\p{L}+})?
        name: keyword.control.end.trin}
      - match: \^|(?i)\\[ab]({\p{L}+})?
        name: keyword.control.begin.trin
      - match: \\K
        name: keyword.control.keepout.trin
      - match: \\G
        name: keyword.control.search.trin
      - match: \\[XO]
        name: constant.character.unicode.trin
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.trin}
          2: {name: keyword.operator.quantifier.lazy.trin}
          3: {name: keyword.operator.quantifier.eager.trin}
          4: {name: keyword.operator.quantifier.greedy.trin}
      - match: \\\d+
        name: keyword.other.back-reference.trin
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.trin
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.trin
        captures:
          1: {name: keyword.other.back-reference.trin}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.trin
        captures:
          1: {name: keyword.other.subroutine.trin}
        patterns: *regex-back-references
      - begin: (\\k(['"]))
        end: \s*(\2)
        name: constant.other.back-reference.trin
        captures:
          1: {name: keyword.other.back-reference.trin}
        patterns: *regex-back-references
      - begin: (\\g(['"]))
        end: \s*(\2)
        name: constant.other.subroutine.trin
        captures:
          1: {name: keyword.other.subroutine.trin}
        patterns: *regex-back-references
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.trin}
          2: {name: keyword.operator.modifier.eager.trin}
          3: {name: keyword.operator.modifier.greedy.trin}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.trin}
          2: {name: keyword.operator.quantifier.eager.trin}
          3: {name: keyword.operator.quantifier.greedy.trin}
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: \\.
        name: constant.character.escape.other.trin

    repository:
      regexp-groups:
        patterns:
          - comment: Embedded expression
            begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.trin
            captures:
              0: {name: punctuation.section.expression.trin}
            patterns:
              - include: $self
          - comment: Block comment
            begin: (\()(\?#)
            contentName: comment.block.regexp.trin
            end: \s*(\))
            name: comment.block.regexp.trin
            captures:
              1: {name: punctuation.definition.comment.trin}
            patterns:
              - match: \\.
                name: comment.block.regexp.trin
          - comment: Lookahead assertion
            begin: (\(\?=)
            end: \s*(\))
            name: meta.group.look-ahead.trin
            captures:
              1: {name: punctuation.definition.group.look-ahead.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Lookbehind assertion
            begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.look-behind.trin
            captures:
              1: {name: punctuation.definition.group.look-behind.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Negative lookahead assertion
            begin: (\(\?!)
            end: \s*(\))
            name: meta.group.negative-look-ahead.trin
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Negative lookbehind assertion
            begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.negative-look-behind.trin
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Match directive
            begin: (\(\?%)((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?(/)?
            end: \s*(\))
            name: meta.group.directive.trin
            captures:
              1: {name: punctuation.definition.group.directive.trin}
              2:
                name: storage.type.format.trin
                patterns: [include: "#format-specifiers"]
              3: {name: punctuation.separator.slash.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Longest match
            begin: (\(\?/)
            end: \s*(\))
            name: meta.group.longest.trin
            captures:
              1: {name: punctuation.definition.group.longest.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Flag modifier group
            begin: (\(\?\^?(?:([+-]?\d+?)|(\p{Upper}+(?:[+-]\p{Upper}+)*)|(\p{Lower}+(?:[+-]\p{Lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.flag.trin
            captures:
              0: {name: punctuation.definition.group.flag.trin}
              1: {name: punctuation.definition.group.flag.trin}
              2: {name: constant.numeric.index.trin}
              3: {name: keyword.control.recursion.trin}
              4: {name: keyword.other.flag.trin}
              5: {name: punctuation.separator.colon.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Callouts
            begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.call-out.trin
            captures:
              1: {name: punctuation.definition.group.call-out.trin}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.trin
                captures:
                  1: {name: punctuation.definition.group.call-out.trin}
                  2: {name: keyword.operator.range.trin}
                  3: {name: punctuation.definition.tag.trin}
                  4: {patterns: [include: "#function-names"]}
                  5: {name: punctuation.definition.tag.trin}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - comment: Atomic groups
            begin: (\(\?>)
            end: \s*(\))
            name: meta.group.atomic.trin
            captures:
              1: {name: punctuation.definition.group.atomic.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Non-capturing groups
            begin: (\(\?:)
            end: \s*(\))
            name: meta.group.non-capturing.trin
            captures:
              1: {name: punctuation.definition.group.non-capturing.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Branch groups
            begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.branch.trin
            captures:
              1: {name: punctuation.definition.group.branch.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Atomic groups
            begin: (\(\?~)
            end: \s*(\))
            name: meta.group.absent.trin
            captures:
              1: {name: punctuation.definition.group.absent.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Back-reference groups
            begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)))(:)?
            end: \s*\)
            name: meta.group.back-reference.trin
            captures:
              0: {name: punctuation.definition.group.back-reference.trin}
              1: {name: punctuation.definition.group.back-reference.trin}
              2: {name: constant.numeric.index.trin}
              3: {patterns: [include: "#function-names"]}
              4: {name: punctuation.separator.colon.trin}
            patterns:
              - include: "#regexp-patterns"
          - comment: Named groups (angle-brackets)
            begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.named.trin
            captures:
              0: {name: punctuation.definition.group.named.trin}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: constant.other.group.trin
                captures:
                  1: {name: punctuation.definition.group.named.trin}
                patterns: *regex-back-references
              - include: "#regexp-patterns"
          - comment: Named groups (single or double-quotes)
            begin: \(\?(?=['"])
            end: \s*(\))
            name: meta.group.named.trin
            captures:
              0: {name: punctuation.definition.group.named.trin}
            patterns:
              - begin: (?<=\(\?)(['"])
                end: \s*(\1)
                name: constant.other.group.trin
                captures:
                  1: {name: punctuation.definition.group.named.trin}
                patterns: *regex-back-references
              - include: "#regexp-patterns"
          - comment: Unnamed groups
            begin: (\()
            end: (\s*\))
            name: meta.group.trin
            captures:
              1: {name: punctuation.definition.group.trin}
            patterns:
              - include: "#regexp-patterns"

      regexp-char-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.trin
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.trin
            patterns:
              - include: "#unicode-query"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.trin
            patterns:
              - include: "#named-char-notation"
          - include: "#numeric-escapes"
          - match: (?i)\\([cm][a-z]|r)
            name: constant.character.control.trin
          - match: *posix-class
            name: constant.other.character-class.posix.trin
          - match: (?i)\\p(c[cfos]?|l[motlu]?|m[cen]?|n[dlo]?|p[c-fios]?|s[mock]?|z[lps]?)
            name: constant.other.character-class.unicode.trin
          - match: (?i)\\[ci]({\w+})?
            name: constant.other.character-class.xml.trin
          - match: (?x)\\[a-z]
            name: constant.other.character-class.trin
          - match: (?x)\\[A-Z]
            name: constant.other.character-class.negated.trin
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.trin
          - match: (?i)\\[a-z]
            name: constant.character.escape.trin
          - match: (?x)\\[\p{S}\p{P}]
            name: constant.character.escape.symbol.trin
          - match: (?x)\\\p{Z}
            name: constant.character.escape.other.trin
          - match: (?x)\\[\p{L}\p{N}\p{C}]
            name: invalid.illegal.unknown-escape.trin
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: (?<!\|)\|\|(?!\|)
            name: keyword.operator.union.trin
          - match: (?<!&)&&(?!&)
            name: keyword.operator.intersection.trin
          - match: (?<!\^)\^\^(?!\^)
            name: keyword.operator.symmetric.trin
          - match: (?<!~)~~(?!~)
            name: keyword.operator.negation.trin
          - match: (?<!-)--(?!-)
            name: keyword.operator.difference.trin
          - match: (?<![^\\][\\\[])-(?![-\[\]])
            name: keyword.operator.range.trin
          - match: ([^-\\\[\]]|\\.)(?<!-+)(?=(?<!\\)-)
            name: constant.other.character-class.range.from.trin
          - match: (?<=[^\\]-)(?!-+)([^-\\\[\]]|\\.)
            name: constant.other.character-class.range.to.trin
          - match: \\.
            name: constant.character.escape.other.trin

      regexp-char-set:
        patterns:
          - begin: (\[[.:=])
            end: (\])
            name: constant.other.character-class.posix.trin
            captures:
              1: {name: punctuation.definition.character-class.posix.trin}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[[!~^])
            end: (\])
            name: constant.other.character-class.negated.trin
            captures:
              1: {name: punctuation.definition.character-class.negated.trin}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"
          - begin: (\[)
            end: (\])
            name: constant.other.character-class.trin
            captures:
              1: {name: punctuation.definition.character-class.trin}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"

  unicode-query:
    patterns:
      - include: "#comments"
      - include: "#operators"
      - include: "#expression-keywords"
      - include: "#literals"
      - captures:
          1: {name: storage.modifier.ignore-case.trin}
        match: (?<=["'\s]|^|[*+/]/)\s*([iI])\s*(?=[\s}]|/\*|$)
      - captures:
          1:
            name: string.unquoted.attribute-value.trin
            patterns: [include: "#string-escapes"]
        match: (?x)(?<==)\s*((?!/[*+/])(?:[^\\`"'\s}]|\\.)+)
      - include: "#string-escapes"
      - match: "[~|^$!&*=]?="
        name: keyword.operator.pattern.trin
      - match: \|
        name: punctuation.separator.trin
      - captures:
          1:
            name: entity.other.namespace-prefix.trin
            patterns: [include: "#string-escapes"]
        match: |-
          (?x)
          # Qualified namespace prefix
          (-?(?!\d)(?:[\w-]|[^\x00-\x7F]|\\(?:\h{1,6}|.))+|\*)
          # Lookahead to ensure there's a valid identifier ahead
          (?=\|(?!\s|=|$|\])(?:-?(?!\d)|[\\\w-]|[^\x00-\x7F]))
      - captures:
          1:
            name: entity.other.attribute-name.trin
            patterns: [include: "#string-escapes"]
        match: |-
          (?x)
          (-?(?!\d)(?>[\w-]|[^\x00-\x7F]|\\(?:\h{1,6}|.))+)\s*
          (?=[}~|^$!&*=]|/[*+/])

  # Markdown

  markdown:
    comment:
      Only inline Markdown syntax would be supported, plus some enhancements
      HAML, Textile and more.
      Coming soon.
    patterns: []

  # JSX

  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    begin: |
      (?x)
      (?<=(?:
      ^\s*|,\s*|;\s*|
      \#?[({\[]\s*|
      [\p{Pc}\p{L}]\w*|
      (?:[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+)\s+|
      \b(?:#keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|fun|type|sin
      |class|enum|mod|pack|struct|inter|space|prag
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|fix
      |switch|match|case|fail
      |tandem|unison|series|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b)\s*)
      (?=<[\p{Pc}\p{L}])
    end: (?=.)|$
    applyEndPatternLast: 1
    patterns:
      - include: "#tag-element-name"

  jsx-values:
    patterns:
      - include: source.yaml#flow-scalar-plain-out-implicit-type
      - include: source.css#numeric-values
      - include: source.css#property-keywords
      - include: source.css#color-keywords
      - include: source.css#property-names
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional
      - include: "#constants"
      - include: "#numbers"
      - include: "#string-content"

  tag-names:
    patterns:
      - match: (?x)\b([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?=[.:])
        name: entity.name.tag.namespace.trin
      - match: |
          (?x)\b
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\p{Pd}\w&&\P{Pc}]*\p{Pc}+)|
          ([\p{L}&&\P{Ll}][\p{Pd}\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\p{Pd}\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\p{Pd}\w]*)
          )\b
        captures:
          1: {name: entity.name.tag.style.trin}
          2: {name: entity.name.tag.script.trin}
          3: {name: entity.name.tag.trin support.class.component.trin}
          4: {name: entity.name.tag.trin}
      - match: ":"
        name: punctuation.separator.namespace.trin
      - match: \.
        name: punctuation.accessor.trin

  tag-element-name:
    patterns:
      - comment: JSX Fragment
        name: meta.tag.trin
        contentName: meta.tag.trin
        begin: \s*+(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.trin}
        endCaptures:
          1: {name: punctuation.definition.tag.trin}
        patterns:
          - include: "#tag-termination"
      - comment: "Tags that end > are trapped in #tag-termination"
        name: meta.tag.trin
        contentName: meta.tag.trin
        begin: |
          (?x)\s*+(<)#start tag begin
          ([\p{Pc}\p{L}]\w*(?:[:.\p{Pd}][\p{Pc}\p{L}]\w*)*)#tag name
          (?=[\/>\s])(?![:])(?<!\.|:)
        end: \s*(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>
        beginCaptures:
          1: {name: punctuation.definition.tag.trin}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.trin}
          3: {name: punctuation.definition.tag.trin}
          4: {name: invalid.illegal.termination.trin}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.trin
    name: meta.jsx.children.trin
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.trin}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-element-name"
      - include: "#string-content"
      - include: markdown.math.block
      - include: text.html.markdown#inline

  tag-attributes:
    patterns:
      - include: "#evaluated-code"
      - include: "#attribute-name"
      - include: source.css.scss#selectors
      - include: source.yaml#flow-collection
      - include: "#spread-attribute"
      - include: "#string-content"
      - include: "#numbers"
      - include: "#strings-quoted"
      - include: "#regexes"
      - include: "#brackets"
      - include: "#comments"
      - include: "#punctuation"

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.trin

  attribute-name:
    patterns:
      - begin: (?<=<|\s|,|;|\)|\]|\})([\p{Pc}\p{L}][\p{Pd}\w]*)(=)
        beginCaptures:
          1: {name: entity.other.attribute-name.trin}
          2: {name: punctuation.separator.key-value.trin}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/>|::|!:|\?:|\.|!\.|\?\.)
        name: string.unquoted.trin
        patterns: [include: "#jsx-values"]
      - comment: Attribute names
        match: (?<=<|\s|,|;|\)|\]|\})([\p{Pc}\p{L}][\p{Pd}\w]*)(=)?
        captures:
          1: {name: entity.other.attribute-name.trin}
          2: {name: punctuation.separator.key-value.trin}

  evaluated-code:
    patterns:
      - comment: Style attribute
        begin: \s*(#{)\s*
        end: \s*(})\s*
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: source.css.scss#flow_control
          - include: source.css.scss#rules
          - include: source.css.scss#properties
          - include: source.css.scss
      - begin: \s*(\${)\s*
        end: \s*(})\s*
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: $self

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.trin}
          2: {name: punctuation.definition.entity.trin}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.trin
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.trin
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.trin
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.trin
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.trin
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.trin
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.trin
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.trin
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.trin
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.trin

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"

  nested-comments:
    patterns:
      - begin: \s*((/\+\+))
        end: (\s*(\+/))
        name: comment.block.documentation.nested.trin
        captures:
          1: {name: comment.block.documentation.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*((/\+))
        end: (\s*(\+/))
        name: comment.block.nested.trin
        captures:
          1: {name: comment.block.nested.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested"

  block-comments:
    patterns:
      - begin: \s*((/\*\*))
        end: (\s*(\*/))
        name: comment.block.documentation.trin
        captures:
          1: {name: comment.block.documentation.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*((/\*))
        end: (\s*(\*/))
        name: comment.block.trin
        captures:
          1: {name: comment.block.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: text.html.markdown#inline

  line-comments:
    patterns:
      - begin: ((^\s*)|\s*)((///))
        end: \s*$
        name: comment.line.documentation.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.documentation.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.documentation.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//))
        end: \s*$
        name: comment.line.number-sign.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.double-slash.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.number-sign.trin}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\+\+?)\s*
    end: \s*(\+/)
    name: comment.block.documentation.nested.trin
    captures:
      1: {name: punctuation.definition.comment.trin}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"

  nested:
    begin: (/\+)\s*
    end: \s*(\+/)
    name: comment.block.nested.trin
    captures:
      1: {name: punctuation.definition.comment.trin}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested"

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match:
          (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss
          mixin|singleton|template|uses|xtype)\b
        name: storage.type.class.jsdoc

    repository:
      jsdoc-access:
        comment: "@tag protected...."
        match: (@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-module:
        comment: "@tag {optional type} module:file"
        begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - match: (?:(module)(:))?(((?!\*/)\S)+)
            captures:
              1: {name: keyword.module.jsdoc}
              2: {name: punctuation.jsdoc}
              3: {name: string.modulename.jsdoc}
      jsdoc-as-name-path:
        comment: to terminate the block
        begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-name-path-scopes"
      jsdoc-simple:
        comment: "@tag"
        match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-name-path:
        comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
        begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-name-path-scopes"
      jsdoc-type-name:
        comment: "@tag {optional type} name"
        begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-name-scopes"
      jsdoc-type-no-name:
        comment: "@tag {types}"
        begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
      jsdoc-inline-tags:
        name: meta.tag.inline.jsdoc
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.jsdoc}
              3: {name: string.jsdoc}
      jsdoc-typedef-scopes:
        name: entity.name.type.instance.jsdoc
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - include: "#jsdoc-name-path-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-obj:
        comment: typedef object
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - match: \b([\p{Pc}\p{L}]\w*)\s*(:)
            captures:
              1: {name: variable.other.readwrite.jsdoc}
          - include: "#jsdoc-name-path-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-name-scopes:
        patterns:
          - match: ((?!\*/)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.jsdoc}
          - name: variable.other.jsdoc
            begin: \[
            end: \]|^
            patterns:
              - include: "#jsdoc-string"
              - include: "#jsdoc-name-scopes"
      jsdoc-name-path-scopes:
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
            captures:
              1: {name: keyword.as.jsdoc}
          - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
            captures:
              1: {name: entity.name.class.jsdoc}
              2: {name: entity.name.function.jsdoc}
          - match: (\.)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.static.jsdoc}
          - match: (\#)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.instance.jsdoc}
          - match: (~|-)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.inner.jsdoc}
          - match: (\#)(event)(:)
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: keyword.event.jsdoc}
              3: {name: keyword.operator.jsdoc}
          - name: string.method.jsdoc
            begin: \.(?="|')
            end: (?=.)
            applyEndPatternLast: 1
            patterns:
              - include: "#jsdoc-string"
      jsdoc-string:
        name: string.jsdoc
        match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - comment: |
          Function calls (with spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|new|to|til|thru|by|del|unset
          |var|val|let|const|decl|def|fun|type|sin
          |class|enum|mod|pack|struct|inter|space|prag
          |proc|proto|macro|given|style|elem|field
          |ext|pred|data|trait|lemma|iter|sub|prop
          |if|un|elif|elun|else|then
          |for|each|loop|while|until|when
          |with|do|from
          |try|throw|catch|fix
          |switch|match|case|fail
          |tandem|unison|series|spawn|kill|lock
          |break|next|redo|retry|return|await|label|yield|goto|pass
          |import|export|using
          |debug|assert|where
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b\s+
          (?=<\|{1,3}\s+|<\+\s+)
        captures:
          1: {patterns: [include: "#function-names"]}
      - comment: |
          Function calls (optional spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|new|to|til|thru|by|del|unset
          |var|val|let|const|decl|def|fun|type|sin
          |class|enum|mod|pack|struct|inter|space|prag
          |proc|proto|macro|given|style|elem|field
          |ext|pred|data|trait|lemma|iter|sub|prop
          |if|un|elif|elun|else|then
          |for|each|loop|while|until|when
          |with|do|from
          |try|throw|catch|fix
          |switch|match|case|fail
          |tandem|unison|series|spawn|kill|lock
          |break|next|redo|retry|return|await|label|yield|goto|pass
          |import|export|using
          |debug|assert|where
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b
          (?=
          (?:[!?]?\.=?|[?!:]:=?)?\#?\(|
          (?:[!?]?\.=?|[?!:]:=?)?['"`\\]|
          (?:[!?]?\.=?|[?!:]:=?)?<[\p{Pc}\p{L}]
          )
        captures:
          1: {patterns: [include: "#function-names"]}

  # Variables

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.trin
      - match: (?i)\s*\*[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.trin
      - match: (?i)\s*[&~][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.trin
      - match: (?i)\s*\%[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.trin
      - match: (?i)\s*\$[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.trin
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.trin

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties (note all properties are by default, symbols)
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.trin}
      2: {name: variable.other.constant.property.trin}
      3: {name: variable.other.property.static.trin}
      4: {name: variable.other.property.trin}
      5: {name: variable.other.global.trin}
      6: {name: variable.other.constant.object.trin}
      7: {name: variable.other.conditional.trin}
      8: {name: variable.other.object.trin}
      9: {name: variable.other.dollar.trin}
      10: {name: variable.other.constant.trin}
      11: {name: variable.other.class.trin}
      12: {name: variable.other.readwrite.trin}

  # Operators

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|[\s'"`\\({\[])([\p{S}\p{P}&&[^!:~.<=>,;'"`\\(){}\[\]\p{Pc}]][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*=)(?=$|[\s'"`\\)}\]])
            name: keyword.operator.assignment.augmented.trin

          - comment: |
              BUILT-IN OPERATORS

              1: assignment : :=
              2: arithmetic + - * ** *** / // /// % %% *> <*
              3: increment/decrement ++ --
              4: logical && || ^^ !& !| !^ &| &!
              5: bitwise & | ^ ~
              6: bitwise shift << >> <<< >>>
              7: function pipeline <| |> <|| ||> <||| |||>
              8: function composition +> <+
              9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
              10: relational < > <= >=
              11: regex =< <> </ /> <$ $> <+> <*> </> <$>
              12: equality == != === !==
              13: wavy operators ~> <~ ~~> <~~
              14: fat arrow-like => ==> <==
              15: skinny arrow-like -> --> <- <--
              16: null-coalescing ??
              17: non-null coalescing !!
              18: compact ternary operator ?:
              19: inverse ternary operator !:
              20: infix function call $:
            captures:
              1: {name: keyword.operator.assignment.trin}
              2: {name: keyword.operator.arithmetic.trin}
              3: {name: keyword.operator.successor.trin}
              4: {name: keyword.operator.logical.trin}
              5: {name: keyword.operator.bitwise.trin}
              6: {name: keyword.operator.bitwise.shift.trin}
              7: {name: keyword.operator.pipeline.trin}
              8: {name: keyword.operator.compose.trin}
              9: {name: keyword.operator.class.trin}
              10: {name: keyword.operator.relational.trin}
              11: {name: keyword.operator.regexp.trin}
              12: {name: keyword.operator.comparison.trin}
              13: {name: keyword.operator.similarity.trin}
              14: {name: keyword.operator.arrow.fat.trin}
              15: {name: keyword.operator.arrow.skinny.trin}
              16: {name: keyword.operator.null-coalescing.trin}
              17: {name: keyword.operator.coalescing.trin}
              18: {name: keyword.operator.conditional.trin}
              19: {name: keyword.operator.ternary.trin}
              20: {name: keyword.operator.macro.dollar.trin}
            match: |
              (?x)
              (?<=^|[\s'"`\\({\[])# opening
              (?:
              (:?=)#1
              |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
              |(\+\+|--)#3
              |(&&|\|\||\^\^)#4
              |([&|^~])#5
              |(<<<?|>>>?)#6
              |(\|{1,3}>|<\|{1,3})#7
              |(\+>|<\+)#8
              |([<>][!:]|[!:][<>])#9
              |([<>]=?|<=?>)#10
              |(=<|<?[/*|+$:]>?)#11
              |([!=]==?|[!=]~|~[!=])#12
              |([\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*~>|
              <~[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*)#13
              |([\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*=>|
              <=[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*)#14
              |([\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*->|
              <-[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*)#15
              |(\?\?)#16
              |(!!)#17
              |(\?:)#18
              |(!:)#19
              |(\$:)#20
              )
              (?=$|[\s'"`\\)}\]])# closing

          - comment: |
              CUSTOM OPERATORS

              1: custom bitwise (& | ^ ~)
              2: custom arithmetic (+ - * / %)
              3: custom prototype (:)
              4: custom accessor (.)
              5: custom equality (= !)
              6: custom comparison (< >)
              7: custom private (? #)
              8: custom mathematical (Unicode Sm)
              9: custom currency (Unicode Sc)
              10: custom ASCII (between \x80 and \xff)
              11: custom infix operators (all other chars)
            captures:
              1: {name: keyword.operator.bitwise.custom.trin}
              2: {name: keyword.operator.arithmetic.custom.trin}
              3: {name: keyword.operator.prototype.custom.trin}
              4: {name: keyword.operator.accessor.custom.trin}
              5: {name: keyword.operator.comparison.custom.trin}
              6: {name: keyword.operator.relational.custom.trin}
              7: {name: keyword.operator.private.custom.trin}
              8: {name: keyword.operator.math.custom.trin}
              9: {name: keyword.operator.currency.custom.trin}
              10: {name: keyword.operator.ascii.custom.trin}
              11: {name: keyword.operator.infix.custom.trin}
            match: |
              (?x)
              (?<=^|[\s'"`\\({\[])# opening
              (?:
              ([&|^~][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#1
              |([+\-*/%][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#2
              |([@:][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#3
              |(\.[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#3
              |([!=][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#4
              |([<>][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#5
              |([?\#][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#6
              |(\p{Sm}[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#7
              |(\p{Sc}[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#8
              |([\p{S}\p{P}&&[\x80-\xFF]][\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#9
              |([\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#10
              )
              (?=$|[\s'"`\\)}\]])# closing

      unary-ops:
        patterns:
          - &primary-operators
            comment: Primary binary operators
            match: |
              (?x)(?<=\b|['"`\\)}\]])# closing
              (?:
              ([>.]\.[.<])#1
              |(\?[.:]=?)#2
              |(![.:]=?)#3
              |((?:::|\.)=?)#4
              |([\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)#5
              )
              (?=\b|['"`\\({\[])# opening
            captures:
              1: {name: keyword.operator.range.trin}
              2: {name: keyword.operator.optional.trin}
              3: {name: keyword.operator.assert.trin}
              4: {name: keyword.operator.accessor.trin}
              5: {name: keyword.operator.primary.trin}

          - &prefix-operators
            comment: Prefix operators
            match: |
              (?x)
              (?:([*/])#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]])#15
              (?=[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*
              [\w({\['"`])
            name: keyword.operator.prefix.trin
            captures:
              1: {name: keyword.operator.module.all.trin}
              2: {name: keyword.operator.increment.trin}
              3: {name: keyword.operator.decrement.trin}
              4: {name: keyword.operator.intersection.trin}
              5: {name: keyword.operator.union.trin}
              6: {name: keyword.operator.symmetric.trin}
              7: {name: keyword.operator.logical.trin}
              8: {name: keyword.operator.private.trin}
              9: {name: keyword.operator.decorator.trin}
              10: {name: keyword.operator.bitwise.not.trin}
              11: {name: keyword.operator.existential.trin}
              12: {name: keyword.operator.assignment.trin}
              13: {name: keyword.operator.pipeline.trin}
              14: {name: keyword.operator.private.trin}
              15: {name: keyword.operator.prefix.trin}

          - &suffix-operators
            comment: Suffix operators
            match: |
              (?x)
              (?<=['"`\w)}\]]
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*)
              (?:([*/])#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]])#15
            name: keyword.operator.suffix.trin
            captures:
              1: {name: keyword.operator.module.all.trin}
              2: {name: keyword.operator.increment.trin}
              3: {name: keyword.operator.decrement.trin}
              4: {name: keyword.operator.intersection.trin}
              5: {name: keyword.operator.union.trin}
              6: {name: keyword.operator.symmetric.trin}
              7: {name: keyword.operator.assert.trin}
              8: {name: keyword.operator.private.trin}
              9: {name: keyword.operator.decorator.trin}
              10: {name: keyword.operator.bitwise.trin}
              11: {name: keyword.operator.optional.trin}
              12: {name: keyword.operator.assignment.trin}
              13: {name: keyword.operator.pipeline.trin}
              14: {name: keyword.operator.private.trin}
              15: {name: keyword.operator.suffix.trin}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\+>)|(\|{1,3}>))(?=\s*(
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# prefix
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
              \b(?:# don't match keywords
              in|of|as|is|new|to|til|thru|by|del|unset
              |var|val|let|const|decl|def|fun|type|sin
              |class|enum|mod|pack|struct|inter|space|prag
              |proc|proto|macro|given|style|elem|field
              |ext|pred|data|trait|lemma|iter|sub|prop
              |if|un|elif|elun|else|then
              |for|each|loop|while|until|when
              |with|do|from
              |try|throw|catch|fix
              |switch|match|case|fail
              |tandem|unison|series|spawn|kill|lock
              |break|next|redo|retry|return|await|label|yield|goto|pass
              |import|export|using
              |debug|assert|where
              )\b
              )
              [\w]+
              (?:[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# primary
              [\w]+)*
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# suffix
              )\s*([^(]|$|;))
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.compose.trin}
              2: {name: keyword.operator.pipeline.trin}
            patterns:
              - match: |
                  (?x)\s*\b
                  (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
                  \b(?:# don't match keywords
                  in|of|as|is|new|to|til|thru|by|del|unset
                  |var|val|let|const|decl|def|fun|type|sin
                  |class|enum|mod|pack|struct|inter|space|prag
                  |proc|proto|macro|given|style|elem|field
                  |ext|pred|data|trait|lemma|iter|sub|prop
                  |if|un|elif|elun|else|then
                  |for|each|loop|while|until|when
                  |with|do|from
                  |try|throw|catch|fix
                  |switch|match|case|fail
                  |tandem|unison|series|spawn|kill|lock
                  |break|next|redo|retry|return|await|label|yield|goto|pass
                  |import|export|using
                  |debug|assert|where
                  )\b
                  )
                  (?:
                  (?:# Objects and maps
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
                  |
                  (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
                  (?:# Properties (note all properties are by default, symbols)
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  |
                  (?:# Regular variables
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  )\b
                captures:
                  1: {name: variable.other.global.trin}
                  2: {name: variable.other.constant.object.trin}
                  3: {name: variable.other.conditional.trin}
                  4: {name: variable.other.object.trin}
                  5: {name: entity.name.tag.trin}
                  6: {name: entity.name.tag.trin support.class.component.trin}
                  7: {name: entity.name.class.builtin.trin}
                  8: {name: entity.name.function.method.trin}
                  9: {name: entity.name.function.tagged-template.trin}
                  10: {name: entity.name.type.trin}
                  11: {name: entity.name.class.trin}
                  12: {name: entity.name.function.trin}
              - *primary-operators

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.trin
              - include: $self

  # Types

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=.)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.trin}
    patterns:
      - include: "#types"

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.trin
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.trin

        patterns:
          - begin: \s*(?<=^|;|,|(?<=['"`\w)}\]]):|[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+|[({\[])(?<![\w,;'"`)}\]]\|)\s*(\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.mapping.trin}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|;|,|(?<=['"`\w)}\]]):|[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+|[({\[])(?<![\w,;'"`)}\]]\|)\s*(\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.trin}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.trin
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.trin}
            patterns:
              - include: "#punctuation"
              - include: "#function-params"
              - include: "#types"
              - include: $self
          - begin: \s*(\#?\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)
                captures:
                  1: {name: punctuation.separator.slice.trin}
              - match: ","
                name: punctuation.separator.sequence.trin
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.attribute-selector.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.sequence.trin}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.trin
              - include: "#types"
              - include: $self
          - begin: \s*(\[)\s*
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.trin}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.trin
              - include: "#types"
              - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#type-embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - match: "''"
            name: constant.character.escape.trin
          - include: "#type-embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.trin
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.trin
            patterns:
              - include: "#type-embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*~=<>])?\s*
          ((?:\w|\\.)+(?:(?:[^\s'"`\\\[\](){}<>]|\\.)*(?:\w|\\.)+)?)?\s*
          \s*
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3:
            name: storage.type.format.trin
            patterns: [include: "#format-specifiers"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - include: "#comments"
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.trin
            patterns:
              - include: "#type-embedded"
              - include: text.html.markdown#inline
          - include: $self
      - begin: \s*(\\)
        beginCaptures:
          1: {name: punctuation.definition.string.trin}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/>|::|!:|\?:|\.|!\.|\?\.)
        name: string.unquoted.trin
        patterns:
          - include: "#type-embedded"

  type-embedded-raw:
    patterns:
      - match: ([$%#])\1
        name: constant.character.escape.trin
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2: {name: storage.type.format.trin}
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [{include: "#types"}, {include: "#self"}]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: "#types"
          - include: "#self"

  type-embedded:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2: {name: storage.type.format.trin}
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [{include: "#types"}, {include: "#self"}]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: "#types"
          - include: "#self"

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        name: storage.type.extends.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        name: storage.type.implements.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|pairof|infer|as|is)\b\s*
        name: keyword.operator.expression.$1.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(instof)\b\s*
        name: keyword.operator.expression.instanceof.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(valof)\b\s*
        name: keyword.operator.expression.valueof.trin

  type-operators:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`\\)}\]])
          (?:
          ([>.]\.[.<])
          |(\?[.:]=?)
          |(![.:]=?)
          |((?:::|\.)=?)
          )
          (?=\b|['"`\\({\[])
        captures:
          1: {name: keyword.operator.range.trin}
          2: {name: keyword.operator.optional.trin}
          3: {name: keyword.operator.assert.trin}
          4: {name: keyword.operator.accessor.trin}

      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.trin}
          2: {name: keyword.operator.difference.trin}
          3: {name: keyword.operator.product.trin}
          4: {name: keyword.operator.quotient.trin}
          5: {name: keyword.operator.remainder.trin}
          6: {name: keyword.operator.only.trin}
          7: {name: keyword.operator.maybe.trin}
          8: {name: keyword.operator.intersection.trin}
          9: {name: keyword.operator.union.trin}
          10: {name: keyword.operator.symmetric.trin}
          11: {name: keyword.operator.negation.trin}
          12: {name: keyword.operator.macro.dollar.trin}
          13: {name: keyword.operator.private.trin}
          14: {name: keyword.operator.class.trin}

  types:
    patterns:
      - match: \s*(==?>|--?>|~~?>)
        name: keyword.operator.type.function.trin
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.trin
      - include: "#params-clause"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#type-strings"
      - include: "#literals"

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.trin}
    patterns: &function-params
      - include: "#clauses"
      - include: "#constants"
      - include: "#declarations"
      - include: "#keywords"
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\?[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.optional.trin
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\*[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.spread.trin
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\&[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.name.trin
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\%[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.reference.trin
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\$[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.other.trin
      - match: |
          (?xi)\s*
          (?<=(?:^|[^|])\||[({\[;,])
          \s*\b[\p{Pc}\p{L}]\w*\b\s*
          (?=\s*(?:
          [,;)}\]]|:\s+|\|(?!\|)
          )|\s+:?=\s+)
        name: variable.parameter.trin
      - include: "$self"

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
      \b(?:# don't match keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|fun|type|sin
      |class|enum|mod|pack|struct|inter|space|prag
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|fix
      |switch|match|case|fail
      |tandem|unison|series|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b
      )
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties (note all properties are by default, symbols)
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.trin}
      2: {name: entity.name.tag.trin}
      3: {name: entity.name.namespace.trin}
      4: {name: entity.name.interface.trin}
      5: {name: entity.name.tag.block.trin}
      6: {name: entity.name.tag.script.trin}
      7: {name: entity.name.tag.style.trin}
      8: {name: entity.name.tag.inline.trin}
      9: {name: entity.name.label.trin}
      10: {name: entity.name.project.trin}
      11: {name: entity.name.class.trin}
      12: {name: entity.name.type.trin}

  # Clauses and Keywords

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#code-block"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.trin
      - include: "#type-operators"
      - include: "#operators"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]))
        end: (?=.)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.trin}
        patterns:
          - include: "#types"

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      # access modifiers
      pub|priv|prot|inline|final|mut|immut|ghost
      |seal|abs|intern|extern|imply|exply|global|local

      # concurrency modifiers
      |a?sync|stat|dyn|lazy|eager|strong|weak|swap
      |vol|unsafe|unfix|bound|free|opaque|trans

      # property or method modifiers
      |rec|gen|oper|get|set|post|put|rem|new|del|patch|early|late|joint|contra
      |prefix|suffix|infix|binary|unary|left|right
      )
      )\b\s*
      |# Decorators
      @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}]\w*)*\s*
      )*
      )

      (?=
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      var|val|let|const|decl|def|fun|type|sin
      |class|enum|mod|pack|struct|inter|space|prag
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - &decorators
            match: (?x)\s*@[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}]\w*)*\s*
            name: entity.name.class.decorator.trin
          - &modifiers
            match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|inline|final|mut|immut|ghost
              |seal|abs|intern|extern|imply|exply|global|local
              )|
              (# Function or method modifiers
              a?sync|stat|dyn|lazy|eager|strong|weak|swap
              |vol|unsafe|unfix|bound|free|opaque|trans
              )|
              (# Property modifiers
              rec|gen|oper|get|set|post|put|rem|new|del|patch|early|late|joint|contra
              |prefix|suffix|infix|binary|unary|left|right
              )
              )\b\s*
            captures:
              1: {name: storage.modifier.trin}
              2: {name: storage.type.accessor.trin}
              3: {name: storage.type.property.trin}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)\b\s*
        name: keyword.other.declare.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        name: storage.type.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        name: storage.type.style.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fun)\b\s*
        name: storage.type.function.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)\b\s*
        name: storage.type.method.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        name: storage.type.class.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        name: storage.type.enum.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(mod)\b\s*
        name: storage.type.module.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pack)\b\s*
        name: storage.type.package.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)\b\s*
        name: storage.type.interface.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(space)\b\s*
        name: storage.type.namespace.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        name: storage.type.structure.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sin)\b\s*
        name: storage.type.singleton.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        name: storage.type.data.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        name: storage.type.trait.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        name: storage.type.procedure.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)\b\s*
        name: storage.type.protocol.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        name: storage.type.macro.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
        name: storage.type.type.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)\b\s*
        name: storage.type.given.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)\b\s*
        name: storage.type.element.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        name: storage.type.extends.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)\b\s*
        name: storage.type.subroutine.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pred)\b\s*
        name: storage.type.predicate.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(lemma)\b\s*
        name: storage.type.lemma.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        name: storage.type.iterator.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)\b\s*
        name: storage.type.field.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)\b\s*
        name: storage.type.property.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prag)\b\s*
        name: storage.type.pragma.trin

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)\b\s*
        name: keyword.control.conditional.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)\b\s*
        name: keyword.control.loop.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|fix)\b\s*
        name: keyword.control.trycatch.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|fail)\b\s*
        name: keyword.control.switch.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|when)\b\s*
        name: keyword.control.match.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(tandem|unison|series|spawn|kill|lock)\b\s*
        name: keyword.control.thread.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)\b\s*
        name: keyword.control.flow.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|using)\b\s*
        name: keyword.control.module.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from)\b\s*
        name: keyword.control.$1.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|where)\b\s*
        name: keyword.other.$1.trin

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)\b\s*
        name: keyword.operator.expression.$1.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)\b\s*
        name: keyword.operator.expression.delete.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)\b\s*
        name: keyword.operator.expression.range.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.trin

  keywords:
    patterns:
      - include: "#validation-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.control.flow.trin}
        patterns:
          - match: *entity-name
            name: constant.other.label.trin

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|using)\b\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.control.module.trin}
            patterns:
              - include: source.yaml#flow-collection
              - *modifiers
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)\b\s*
                name: keyword.control.module.trin
              - include: "#type-keywords"
              - include: "#declarations"
              - include: "#strings-quoted"
              - include: "#strings-unquoted"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.trin
              - match: *entity-name
                name: variable.other.readwrite.alias.trin

      validation-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)\b\s*
        beginCaptures:
          1: {name: keyword.control.validate.trin}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)\b\s*
            name: keyword.control.validate.trin
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)\b\s*
            name: keyword.control.validate.trin
          - include: $self

      query-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
        beginCaptures:
          1: {name: keyword.control.query.trin}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.trin}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - include: "#query-body"
          - include: $self
      query-body:
        patterns:
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"
        repository:
          join-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part)?\b\s*\b(?:inner|outer|left|right)?\b\s*\bjoin)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(on|equals|into)\b\s*
                name: keyword.control.query.trin
              - include: "#query-body"
              - include: $self
          where-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          sort-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sort\b\s*\b(?:asc|desc)?\b\s*\b(?:by|with)?)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          select-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(select\b\s*\b(?:unique|any|all)?)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
                name: keyword.control.query.trin
              - include: "#query-body"
              - include: $self
          limit-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit)\b\s*\b(?:first|last|head|tail)?)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
                name: keyword.control.query.trin
              - include: "#query-body"
              - include: $self
          reduce-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)\b\s*\b(?:left|right)?)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
                name: keyword.control.query.trin
              - include: "#query-body"
              - include: $self
          group-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)\b\s*
            beginCaptures:
              1: {name: keyword.control.query.trin}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)\b\s*
                name: keyword.control.query.trin
              - include: "#query-body"
              - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#function"
      - include: "#method"
      - include: "#class"
      - include: "#enum"
      - include: "#module"
      - include: "#package"
      - include: "#interface"
      - include: "#namespace"
      - include: "#structure"
      - include: "#singleton"
      - include: "#data"
      - include: "#trait"
      - include: "#procedure"
      - include: "#protocol"
      - include: "#macro"
      - include: "#type"
      - include: "#given"
      - include: "#element"
      - include: "#extends"
      - include: "#subroutine"
      - include: "#predicate"
      - include: "#lemma"
      - include: "#iterator"
      - include: "#field"
      - include: "#property"
      - include: "#pragma"

    repository:
      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.variable.trin}
      declare:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.other.declare.trin}
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.style.trin}
        patterns:
          - include: "#style-block"
          - include: "#tag-attributes"
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.trin
      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fun)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.function.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.trin
      method:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.method.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.method.trin
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.class.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.trin
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.enum.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.trin
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(mod)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.module.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.trin
      package:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pack)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.package.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.package.trin
      interface:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.interface.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.interface.trin
      namespace:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(space)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.namespace.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.namespace.trin
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.structure.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.trin
      singleton:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sin)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.singleton.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.singleton.trin
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.data.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.trin
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.trait.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.trin
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.procedure.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.trin
      protocol:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.protocol.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.protocol.trin
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.macro.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.trin
      type:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.type.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.type.trin
      given:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.given.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.given.trin
      element:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.element.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.element.trin
      extends:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.extends.trin
      subroutine:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.subroutine.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.subroutine.trin
      predicate:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pred)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.predicate.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.predicate.trin
      lemma:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(lemma)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.lemma.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.lemma.trin
      iterator:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.iterator.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.iterator.trin
      field:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.field.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.field.trin
      property:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.property.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.property.trin
      pragma:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prag)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.pragma.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.pragma.trin

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|\#?[({\[]\s*|(?:[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+)\s+|\b(?:#keywords
      in|of|as|is|new|to|til|thru|by|del|unset
      |var|val|let|const|decl|def|fun|type|sin
      |class|enum|mod|pack|struct|inter|space|prag
      |proc|proto|macro|given|style|elem|field
      |ext|pred|data|trait|lemma|iter|sub|prop
      |if|un|elif|elun|else|then
      |for|each|loop|while|until|when
      |with|do|from
      |try|throw|catch|fix
      |switch|match|case|fail
      |tandem|unison|series|spawn|kill|lock
      |break|next|redo|retry|return|await|label|yield|goto|pass
      |import|export|using
      |debug|assert|where
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.trin}
    end: (?<!\|)(\|)(?!\|)
    patterns: *function-params

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#params-clause"

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.trin}
        patterns:
          - include: "#function-params"

      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)\b
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.trin}
        patterns:
          - match: *entity-name
            name: entity.name.instance.trin
          - include: "#code-block"
          - include: "#type-keywords"
          - include: "#illegal-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.trin}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
            end: (?=.)|$
            captures:
              1: {name: keyword.other.typedef.trin}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.trin}
              - include: "#types"

      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|fix)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.catch.trin
        captures:
          1: {name: keyword.control.error.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
                name: keyword.control.error.trin
              - include: "#code-block"
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.error.trin
          - include: "#code-block"
          - include: $self

      thread-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(tandem|unison|series|spawn|kill|lock)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.thread.trin
        captures:
          1: {name: keyword.control.thread.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - &thread-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.thread.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *thread-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      do-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(do)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.do.trin
        captures:
          1: {name: keyword.control.do.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.for.trin
        captures:
          1: {name: keyword.control.loop.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - &for-clause-keywords
            match: \s*\b(in|of)\b
            name: keyword.control.loop.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *for-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.if.trin
        captures:
          1: {name: keyword.control.conditional.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      match-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.match.trin
        captures:
          1: {name: keyword.control.match.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.section.class.trin}
            patterns:
              - &when-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)\b\s*
                end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.match.trin}
                  2: {name: punctuation.separator.colon.trin}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
                    end: (?=.)|$
                    beginCaptures:
                      1: {name: keyword.control.match.trin}
                    patterns:
                      - include: "#types"
                  - include: "#type-keywords"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)\b\s*
                    name: keyword.control.match.trin
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)\b\s*
                    name: keyword.control.match.trin
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)\b\s*
                    name: keyword.control.match.trin
                  - include: $self
              - &else-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)\b\s*
                end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.match.trin}
                  2: {name: punctuation.separator.colon.trin}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.block.trin}
            patterns:
              - *when-clause
              - *else-clause
              - include: $self
          - include: $self

      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.switch.trin
        captures:
          1: {name: keyword.control.switch.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.section.class.trin}
            patterns:
              - &case-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)\b\s*
                end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.trin}
                  2: {name: punctuation.separator.colon.trin}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
                    end: (?=.)|$
                    beginCaptures:
                      1: {name: keyword.control.switch.trin}
                    patterns:
                      - include: "#types"
                  - include: "#type-keywords"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)\b\s*
                    name: keyword.control.switch.trin
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)\b\s*
                    name: keyword.control.switch.trin
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)\b\s*
                    name: keyword.control.switch.trin
                  - include: $self
              - &default-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)\b\s*
                end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.trin}
                  2: {name: punctuation.separator.colon.trin}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.block.trin}
            patterns:
              - *case-clause
              - *default-clause
              - include: $self
          - include: $self

      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)\b\s*
        end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
        name: meta.with.trin
        captures:
          1: {name: keyword.control.with.trin}
          2: {name: punctuation.separator.colon.trin}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.with.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *with-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
          ((?:
          \s*(?:
          (?:# access modifiers
          pub|priv|prot|inline|final|mut|immut|ghost
          |seal|abs|intern|extern|imply|exply|global|local

          # concurrency modifiers
          |a?sync|stat|dyn|lazy|eager|strong|weak|swap
          |vol|unsafe|unfix|bound|free|opaque|trans

          # property or method modifiers
          |rec|gen|oper|get|set|post|put|rem|new|del|patch|early|late|joint|contra
          |prefix|suffix|infix|binary|unary|left|right
          |# Decorators
          @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}]\w*)*\s*
          ))
          \s*)*)
          (?=\s*\b
          (?:
          def|fun|proc|macro
          )\b
          )
        name: meta.object-literal.key.trin
        captures:
          1: {name: entity.name.function.trin}
          2: {name: punctuation.separator.key-value.trin}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
          (
          (?:
          (?:# access modifiers
          pub|priv|prot|inline|final|mut|immut|ghost
          |seal|abs|intern|extern|imply|exply|global|local

          # concurrency modifiers
          |a?sync|stat|dyn|lazy|eager|strong|weak|swap
          |vol|unsafe|unfix|bound|free|opaque|trans

          # property or method modifiers
          |rec|gen|oper|get|set|post|put|rem|new|del|patch|early|late|joint|contra
          |prefix|suffix|infix|binary|unary|left|right
          |# Decorators
          @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}]\w*)*\s*
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.trin
        captures:
          1: {name: entity.name.function.trin}
          2: {name: punctuation.separator.key-value.trin}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.trin}
        endCaptures:
          1: {name: punctuation.separator.arguments.trin}
        patterns: *function-params
      - match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (
          |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*# prefix
          (?:\w|\\.)# identifier
          (?:[^\s\\(){}\[\]<>.,:;]|\\.)*?# remainder
          )
          (:)\s+
        name: meta.object-literal.key.trin
        captures:
          1:
            name: constant.other.object.key.trin
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#string-content"
          2: {name: punctuation.separator.key-value.trin}

  # Punctuation

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#semicolon"

    repository:
      line-continuation:
        match: (\\)\s*(?=/[/*+]|$)
        name: punctuation.separator.continuation.line.trin
      comma:
        match: \s*(,)
        name: punctuation.separator.comma.trin
      double-semi:
        match: \s*(;;)
        name: punctuation.terminator.expression.trin
      semicolon:
        match: \s*(;)
        name: punctuation.terminator.statement.trin

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#code-block"
      - include: "#square-brackets"
      - include: "#round-brackets"

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})
    captures:
      1: {name: punctuation.definition.block.trin}
    patterns:
      - begin: ^\s*([\p{Pc}\p{L}][\p{Pd}\w]*)(:)\s*
        beginCaptures:
          1: {name: support.type.property-name.trin}
          2: {name: punctuation.separator.key-value.trin}
        end: (?=\s|,|:|;|'|"|`|<|>|$|\(|\)|\[|\]|\{|\}|/>|::|!:|\?:|\.|!\.|\?\.)
        name: string.unquoted.trin
        patterns: [include: "#jsx-values"]
      - comment: Attribute names
        match: ^\s*([\p{Pc}\p{L}][\p{Pd}\w]*)(:)?\s*
        captures:
          1: {name: support.type.property-name.trin}
          2: {name: punctuation.separator.key-value.trin}
      - include: "#jsx-values"
      - include: source.css.scss#property_list
      - include: $self

  code-block:
    repository:
      closures:
        patterns:
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|case)\b\s*
            end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.trin}
              2: {name: punctuation.separator.colon.trin}
            patterns:
              - include: "#params-clause"
              - applyEndPatternLast: 1
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
                end: (?=.)|$
                beginCaptures:
                  1: {name: keyword.control.trin}
                patterns:
                  - include: "#types"
              - include: "#type-keywords"
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|un|elif|elun|else)\b\s*
                name: keyword.control.trin
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)\b\s*
                name: keyword.control.trin
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|as|all|any|some|none|in|of)\b\s*
                name: keyword.control.switch.trin
              - include: $self
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)\b\s*
            end: (?<=}|;)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)\b|(?<=['"`\w)}\]])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.trin}
              2: {name: punctuation.separator.colon.trin}
            patterns:
              - include: $self

    patterns:
      - begin: (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.trin}
        patterns:
          - include: "#closures"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.trin}
        patterns:
          - include: "#closures"
          - include: $self

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.trin
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.trin
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.typeparameters.trin}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|;|,|(?<=['"`\w)}\]]):|[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+|[({\[])(?<![\w,;'"`)}\]]\|)\s*(\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|;|,|(?<=['"`\w)}\]]):|[\p{S}\p{P}&&[^,;'"`\\p{Pc}(){}\[\]]]+|[({\[])(?<![\w,;'"`)}\]]\|)\s*(\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.trin
      function-params:
        patterns: *function-params
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.trin}
        patterns:
          - include: "#punctuation"
          - include: "#function-params"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.trin}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)
            captures:
              1: {name: punctuation.separator.slice.trin}
          - match: ","
            name: punctuation.separator.sequence.trin
    patterns:
      - begin: \s*(?<=\b(?:var|val|let|const|in|of|as|is|new|to|til|thru|by|del|unset)\b\s*)(\#?\{)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.trin}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.trin}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.trin
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.trin}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.trin
          - include: $self

  support-js:
    patterns:
      - begin: \s*+\b(WeakSet|weak|swapMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<=\.)\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.mutator.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.error.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(debugger)\b
        captures:
          1: {name: keyword.other.js}
      - match: (?<!\.)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.js}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.js}
      - begin: (?<!\.)\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.console.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.console.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.process.js}
      - begin: (?<!\.)\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.process.js}
        patterns:
          - include: "#round-brackets"
      - match: (((?<!\.)\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.module.js}
      - match: (?<!\.)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.js}
      - begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.node.js}
        patterns:
          - include: "#round-brackets"
      - match: |-
          (?<=\.|::)\s*\b
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: |-
          (?x)(?<=\.|::)\s*\b
          (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName
          |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop
          |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor
          |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption
          |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear
          |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete
          |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset
          |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
          |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
          |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
          |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
          |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
          |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
          |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
          |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
          |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
          |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
          |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
          |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
          |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|relat|responseText
          |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
          |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
          |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
          |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
          |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
          |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: (?x)(?<=\.|::)\s*\b(module|exports|id|filename|loaded|parent|children)\b\s*
        name: support.type.object.module.js

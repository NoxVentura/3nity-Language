name: Sombra
scopeName: source.coffee
fileTypes: [so, sombra, coffee]
patterns: [include: "#core"]

information_for_contributors: |
  Sombra is a modern functional, imperative and object-oriented programming language
  with a syntax inspired by Python, and compile(s) to JavaScript and WebAssembly.

  Sombra is additionally inspired by Ruby, Elixir, Clojure, LiveScript, Haskell, OCaml, Go,
  Scala, Flix, Nim, Bash and YAML.

  Should you want to provide a fix or improvement, or even a new feature,
  please create a pull request against this repo: https://github.com/nxltm/sombra-lang
  and I will be very happy to receive them.

  Once accepted, I am happy to receive your request and feedback.

  This document is always under construction, and there's still a couple of things that
  need to be fixed. All this info would be on my Trello which I will be posting very soon.
  I will come back to fix them if I have the time.

comment: |
  To-Do:

  - Add function labels
  - Add keywords for types from SQL
  - Add grammars for Unicode character entities
    - HTML5, AGL and LaTeX
    - Locale and Unicode script codes
    - Transformation rules

  - Add standard library functions, types, classes,
    modules, properties, variables in this order:
    - JavaScript/TypeScript
    - Swift
    - Java, Scala, Kotlin, Flix
    - Haskell, OCaml
    - Go, Rust
    - R
    - Python (names, methods, etc), Perl, Ruby, Lua
    - C, Objective C(++)
    - PHP (needs a bit of cleanup)

  Done:
  - Standardized modifier and declaration keywords
  - Syntax changed, mirrors C# now.
  - Oniguruma uses \w to refer to _\d\p{L}\p{M}, use character
    set operations && and ^ to perform set subtractions
  - Added extended JSX syntax (might still need some modifications)

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.so}
    2: {name: punctuation.separator.decimal.period.so}
    3: {name: constant.numeric.other.separator.so}
    4: {name: constant.numeric.other.exponent.so}
    5: {name: constant.numeric.other.density.so}
    6: {name: storage.type.numeric.so}

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
    \b(?:# don't match keywords
    in|of|as|is|new|infer|unset
    |typeof|nameof|sizeof|pairof|keyof|valueof
    |length|delete|to|til|thru|at|by
    |n?and|x?n?or|not|parallel|series|spawn|discard
    |func?|function|proc|process|macro
    |let|var|val|const|declare
    |class|given|constraint|enum|relation|lattice
    |project|attribute|protocol|member|extend|fragment|interface|struct
    |module|package|namespace|object|record|label
    |raw|data|query|schema|style|component|element|trait|friend|alias|type
    |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
    |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
    |switch|case|fail|default|match|when|pass|fallthru
    |try|retry|throw|raise|catch|rescue|finally
    |with|ref|defer|refer|show|hide|enter|exit
    |then|begin|end|debug|check|assert
    |break|continue|halt|skip|fixed|lock
    |(?:return|give|await|yield|throw|raise)s?
    |import|export|show|hide|open|close
    |from|where|join|equals?|[io]nto|order
    |take|drop|fold|scan|select|group|use|using
    )\b
    )
    ([\p{Pc}\p{L}]\w*)
    \b

  posix-class: &posix-class |
    (?xi)
    \\o|
    \\p(?:
    # POSIX
    alpha|alnum|ascii|blank|cntrl|x?digit
    |graph|lower|print|punct|space|upper|word
    # Extended-POSIX
    |symbol|open|close|dash|link|start|final|math|money
    |number|letter|title|mark|modify
    |bin|qua|sen|oct|dec|doz|hex
    )

repository:
  core:
    patterns:
      - comment: The following are placeholders.
          Will redo embedded HTML and CSS syntax later.
      - include: "#jsx"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#literals"
      - include: "#support"
      - include: "#calls"
      - include: "#variables"
      - include: "#operators"
      - include: "#illegal"

  illegal:
    patterns:
      - match: '\p{N}[\w.+-/\\]*?'
        name: invalid.illegal.numeric.other.so
      - match: '[\w]+?'
        name: invalid.illegal.variable.other.so
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.so
      - match: '\S+?'
        name: invalid.illegal.syntax.so

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|pairof|keyof|valueof
      |length|delete|to|til|thru|at|by
      |n?and|x?n?or|not|parallel|series|spawn|discard
      |func?|function|proc|process|macro
      |let|var|val|const|declare
      |class|given|constraint|enum|relation|lattice
      |project|attribute|protocol|member|extend|fragment|interface|struct
      |module|package|namespace|object|record|label
      |raw|data|query|schema|style|component|element|trait|friend|alias|type
      |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
      |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |import|export|show|hide|open|close
      |from|where|join|equals?|[io]nto|order
      |take|drop|fold|scan|select|group|use|using
      )\b\s*
    name: invalid.illegal.keyword.so

  unicode-named-chars:
    comment: Support for the Unicode Named Character encoding, inspired
      by LaTeX, HTML, AGL, Unicode and regular expressions.
    repository:
    patterns:
      - include: "#string-escapes"
      - comment: Yes this is a bit ridiculous, there are quite a lot of these
        name: constant.character.html.so
        match: "(?x)\\b
          (
          (a(s(ymp(eq)?|cr|t)|n(d(slope|d|v|and)?|g(s(t\
          |ph)|zarr|e|le|rt(vb(d)?)?|msd(a(h|c|d|e|f|a|g|b))?)?)|c(y|irc|d|ute|\
          E)?|tilde|o(pf|gon)|uml|p(id|os|prox(eq)?|e|E|acir)?|elig|f(r)?|w(con\
          int|int)|l(pha|e(ph|fsym))|acute|ring|grave|m(p|a(cr|lg))|breve)|A(s(\
          sign|cr)|nd|MP|c(y|irc)|tilde|o(pf|gon)|uml|pplyFunction|fr|Elig|lpha\
          |acute|ring|grave|macr|breve))
          |
          (B(scr|cy|opf|umpeq|e(cause|ta|rnoullis)|fr|a(ckslash|r(v|wed))|reve)\
          |b(s(cr|im(e)?|ol(hsub|b)?|emi)|n(ot|e(quiv)?)|c(y|ong)|ig(s(tar|qcup\
          )|c(irc|up|ap)|triangle(down|up)|o(times|dot|plus)|uplus|vee|wedge)|o\
          (t(tom)?|pf|wtie|x(h(d|u|D|U)?|times|H(d|u|D|U)?|d(R|l|r|L)|u(R|l|r|L\
          )|plus|D(R|l|r|L)|v(R|h|H|l|r|L)?|U(R|l|r|L)|V(R|h|H|l|r|L)?|minus|bo\
          x))|Not|dquo|u(ll(et)?|mp(e(q)?|E)?)|prime|e(caus(e)?|t(h|ween|a)|psi\
          |rnou|mptyv)|karow|fr|l(ock|k(1(2|4)|34)|a(nk|ck(square|triangle(down\
          |left|right)?|lozenge)))|a(ck(sim(eq)?|cong|prime|epsilon)|r(vee|wed(\
          ge)?))|r(eve|vbar)|brk(tbrk)?))
          |
          (c(s(cr|u(p(e)?|b(e)?))|h(cy|i|eck(mark)?)|ylcty|c(irc|ups(sm)?|edil|\
          a(ps|ron))|tdot|ir(scir|c(eq|le(d(R|circ|S|dash|ast)|arrow(left|right\
          )))?|e|fnint|E|mid)?|o(n(int|g(dot)?)|p(y(sr)?|f|rod)|lon(e(q)?)?|m(p\
          (fn|le(xes|ment))?|ma(t)?))|dot|u(darr(l|r)|p(s|c(up|ap)|or|dot|brcap\
          )?|e(sc|pr)|vee|wed|larr(p)?|r(vearrow(left|right)|ly(eq(succ|prec)|v\
          ee|wedge)|arr(m)?|ren))|e(nt(erdot)?|dil|mptyv)|fr|w(conint|int)|lubs\
          (uit)?|a(cute|p(s|c(up|ap)|dot|and|brcup)?|r(on|et))|r(oss|arr))|C(sc\
          r|hi|c(irc|onint|edil|aron)|ircle(Minus|Times|Dot|Plus)|Hcy|o(n(tourI\
          ntegral|int|gruent)|unterClockwiseContourIntegral|p(f|roduct)|lon(e)?\
          )|dot|up(Cap)?|OPY|e(nterDot|dilla)|fr|lo(seCurly(DoubleQuote|Quote)|\
          ckwiseContourIntegral)|a(yleys|cute|p(italDifferentialD)?)|ross))
          |
          (d(s(c(y|r)|trok|ol)|har(l|r)|c(y|aron)|t(dot|ri(f)?)|i(sin|e|v(ide(o\
          ntimes)?|onx)?|am(s|ond(suit)?)?|gamma)|Har|z(cy|igrarr)|o(t(square|p\
          lus|eq(dot)?|minus)?|ublebarwedge|pf|wn(harpoon(left|right)|downarrow\
          s|arrow)|llar)|d(otseq|a(rr|gger))?|u(har|arr)|jcy|e(lta|g|mptyv)|f(i\
          sht|r)|wangle|lc(orn|rop)|a(sh(v)?|leth|rr|gger)|r(c(orn|rop)|bkarow)\
          |b(karow|lac)|Arr)|D(s(cr|trok)|c(y|aron)|Scy|i(fferentialD|a(critica\
          l(Grave|Tilde|Do(t|ubleAcute)|Acute)|mond))|o(t(Dot|Equal)?|uble(Righ\
          t(Tee|Arrow)|ContourIntegral|Do(t|wnArrow)|Up(DownArrow|Arrow)|Vertic\
          alBar|L(ong(RightArrow|Left(RightArrow|Arrow))|eft(RightArrow|Tee|Arr\
          ow)))|pf|wn(Right(TeeVector|Vector(Bar)?)|Breve|Tee(Arrow)?|arrow|Lef\
          t(RightVector|TeeVector|Vector(Bar)?)|Arrow(Bar|UpArrow)?))|Zcy|el(ta\
          )?|D(otrahd)?|Jcy|fr|a(shv|rr|gger)))
          |
          (e(s(cr|im|dot)|n(sp|g)|c(y|ir(c)?|olon|aron)|t(h|a)|o(pf|gon)|dot|u(\
          ro|ml)|p(si(v|lon)?|lus|ar(sl)?)|e|D(ot|Dot)|q(s(im|lant(less|gtr))|c\
          (irc|olon)|u(iv(DD)?|est|als)|vparsl)|f(Dot|r)|l(s(dot)?|inters|l)?|a\
          (ster|cute)|r(Dot|arr)|g(s(dot)?|rave)?|x(cl|ist|p(onentiale|ectation\
          ))|m(sp(1(3|4))?|pty(set|v)?|acr))|E(s(cr|im)|c(y|irc|aron)|ta|o(pf|g\
          on)|NG|dot|uml|TH|psilon|qu(ilibrium|al(Tilde)?)|fr|lement|acute|grav\
          e|x(ists|ponentialE)|m(pty(SmallSquare|VerySmallSquare)|acr)))
          |
          (f(scr|nof|cy|ilig|o(pf|r(k(v)?|all))|jlig|partint|emale|f(ilig|l(ig|\
          lig)|r)|l(tns|lig|at)|allingdotseq|r(own|a(sl|c(1(2|8|3|4|5|6)|78|2(3\
          |5)|3(8|4|5)|45|5(8|6)))))|F(scr|cy|illed(SmallSquare|VerySmallSquare\
          )|o(uriertrf|pf|rAll)|fr))
          |
          (G(scr|c(y|irc|edil)|t|opf|dot|T|Jcy|fr|amma(d)?|reater(Greater|Slant\
          Equal|Tilde|Equal(Less)?|FullEqual|Less)|g|breve)|g(s(cr|im(e|l)?)|n(\
          sim|e(q(q)?)?|E|ap(prox)?)|c(y|irc)|t(c(c|ir)|dot|quest|lPar|r(sim|do\
          t|eq(qless|less)|less|a(pprox|rr)))?|imel|opf|dot|jcy|e(s(cc|dot(o(l)\
          ?)?|l(es)?)?|q(slant|q)?|l)?|v(nE|ertneqq)|fr|E(l)?|l(j|E|a)?|a(cute|\
          p|mma(d)?)|rave|g(g)?|breve))
          |
          (h(s(cr|trok|lash)|y(phen|bull)|circ|o(ok(leftarrow|rightarrow)|pf|ar\
          r|rbar|mtht)|e(llip|arts(uit)?|rcon)|ks(earow|warow)|fr|a(irsp|lf|r(d\
          cy|r(cir|w)?)|milt)|bar|Arr)|H(s(cr|trok)|circ|ilbertSpace|o(pf|rizon\
          talLine)|ump(DownHump|Equal)|fr|a(cek|t)|ARDcy))
          |
          (i(s(cr|in(s(v)?|dot|v|E)?)|n(care|t(cal|prod|e(rcal|gers)|larhk)?|od\
          ot|fin(tie)?)?|c(y|irc)?|t(ilde)?|i(nfin|i(nt|int)|ota)?|o(cy|ta|pf|g\
          on)|u(kcy|ml)|jlig|prod|e(cy|xcl)|quest|f(f|r)|acute|grave|m(of|ped|a\
          (cr|th|g(part|e|line))))|I(scr|n(t(e(rsection|gral))?|visible(Comma|T\
          imes))|c(y|irc)|tilde|o(ta|pf|gon)|dot|u(kcy|ml)|Ocy|Jlig|fr|Ecy|acut\
          e|grave|m(plies|a(cr|ginaryI))?))
          |
          (j(s(cr|ercy)|c(y|irc)|opf|ukcy|fr|math)|J(s(cr|ercy)|c(y|irc)|opf|uk\
          cy|fr))
          |
          (k(scr|hcy|c(y|edil)|opf|jcy|fr|appa(v)?|green)|K(scr|c(y|edil)|Hcy|o\
          pf|Jcy|fr|appa))
          |
          (l(s(h|cr|trok|im(e|g)?|q(uo(r)?|b)|aquo)|h(ar(d|u(l)?)|blk)|n(sim|e(\
          q(q)?)?|E|ap(prox)?)|c(y|ub|e(il|dil)|aron)|Barr|t(hree|c(c|ir)|imes|\
          dot|quest|larr|r(i(e|f)?|Par))?|Har|o(ng(left(arrow|rightarrow)|right\
          arrow|mapsto)|times|z(enge|f)?|oparrow(left|right)|p(f|lus|ar)|w(ast|\
          bar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|r(dhar|ushar))|ur(dshar|uhar)|jcy|\
          par(lt)?|e(s(s(sim|dot|eq(qgtr|gtr)|approx|gtr)|cc|dot(o(r)?)?|g(es)?\
          )?|q(slant|q)?|ft(harpoon(down|up)|threetimes|leftarrows|arrow(tail)?\
          |right(squigarrow|harpoons|arrow(s)?))|g)?|v(nE|ertneqq)|f(isht|loor|\
          r)|E(g)?|l(hard|corner|tri|arr)?|a(ng(d|le)?|cute|t(e(s)?|ail)?|p|emp\
          tyv|quo|rr(sim|hk|tl|pl|fs|lp|b(fs)?)?|gran|mbda)|r(har(d)?|corner|tr\
          i|arr|m)|g(E)?|m(idot|oust(ache)?)|b(arr|r(k(sl(d|u)|e)|ac(e|k))|brk)\
          |A(tail|arr|rr))|L(s(h|cr|trok)|c(y|edil|aron)|t|o(ng(RightArrow|left\
          (arrow|rightarrow)|rightarrow|Left(RightArrow|Arrow))|pf|wer(RightArr\
          ow|LeftArrow))|T|e(ss(Greater|SlantEqual|Tilde|EqualGreater|FullEqual\
          |Less)|ft(Right(Vector|Arrow)|Ceiling|T(ee(Vector|Arrow)?|riangle(Bar\
          |Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeVector|Dow\
          nVector|Vector(Bar)?)|Vector(Bar)?|arrow|rightarrow|Floor|A(ngleBrack\
          et|rrow(RightArrow|Bar)?)))|Jcy|fr|l(eftarrow)?|a(ng|cute|placetrf|rr\
          |mbda)|midot))
          |
          (M(scr|cy|inusPlus|opf|u|e(diumSpace|llintrf)|fr|ap)|m(s(cr|tpos)|ho|\
          nplus|c(y|omma)|i(nus(d(u)?|b)?|cro|d(cir|dot|ast)?)|o(dels|pf)|dash|\
          u(ltimap|map)?|p|easuredangle|DDot|fr|l(cp|dr)|a(cr|p(sto(down|up|lef\
          t)?)?|l(t(ese)?|e)|rker)))
          |
          (n(s(hort(parallel|mid)|c(cue|e|r)?|im(e(q)?)?|u(cc(eq)?|p(set(eq(q)?\
          )?|e|E)?|b(set(eq(q)?)?|e|E)?)|par|qsu(pe|be)|mid)|Rightarrow|h(par|a\
          rr|Arr)|G(t(v)?|g)|c(y|ong(dot)?|up|edil|a(p|ron))|t(ilde|lg|riangle(\
          left(eq)?|right(eq)?)|gl)|i(s(d)?|v)?|o(t(ni(v(c|a|b))?|in(dot|v(c|a|\
          b)|E)?)?|pf)|dash|u(m(sp|ero)?)?|jcy|p(olint|ar(sl|t|allel)?|r(cue|e(\
          c(eq)?)?)?)|e(s(im|ear)|dot|quiv|ar(hk|r(ow)?)|xist(s)?|Arr)?|v(sim|i\
          nfin|Harr|dash|Dash|l(t(rie)?|e|Arr)|ap|r(trie|Arr)|g(t|e))|fr|w(near\
          |ar(hk|r(ow)?)|Arr)|V(dash|Dash)|l(sim|t(ri(e)?)?|dr|e(s(s)?|q(slant|\
          q)?|ft(arrow|rightarrow))?|E|arr|Arr)|a(ng|cute|tur(al(s)?)?|p(id|os|\
          prox|E)?|bla)|r(tri(e)?|ightarrow|arr(c|w)?|Arr)|g(sim|t(r)?|e(s|q(sl\
          ant|q)?)?|E)|mid|L(t(v)?|eft(arrow|rightarrow)|l)|b(sp|ump(e)?))|N(sc\
          r|c(y|edil|aron)|tilde|o(nBreakingSpace|Break|t(R(ightTriangle(Bar|Eq\
          ual)?|everseElement)|Greater(Greater|SlantEqual|Tilde|Equal|FullEqual\
          |Less)?|S(u(cceeds(SlantEqual|Tilde|Equal)?|perset(Equal)?|bset(Equal\
          )?)|quareSu(perset(Equal)?|bset(Equal)?))|Hump(DownHump|Equal)|Nested\
          (GreaterGreater|LessLess)|C(ongruent|upCap)|Tilde(Tilde|Equal|FullEqu\
          al)?|DoubleVerticalBar|Precedes(SlantEqual|Equal)?|E(qual(Tilde)?|lem\
          ent|xists)|VerticalBar|Le(ss(Greater|SlantEqual|Tilde|Equal|Less)?|ft\
          Triangle(Bar|Equal)?))?|pf)|u|e(sted(GreaterGreater|LessLess)|wLine|g\
          ative(MediumSpace|Thi(nSpace|ckSpace)|VeryThinSpace))|Jcy|fr|acute))
          |
          (o(s(cr|ol|lash)|h(m|bar)|c(y|ir(c)?)|ti(lde|mes(as)?)|S|int|opf|d(so\
          ld|iv|ot|ash|blac)|uml|p(erp|lus|ar)|elig|vbar|f(cir|r)|l(c(ir|ross)|\
          t|ine|arr)|a(st|cute)|r(slope|igof|or|d(er(of)?|f|m)?|v|arr)?|g(t|on|\
          rave)|m(i(nus|cron|d)|ega|acr))|O(s(cr|lash)|c(y|irc)|ti(lde|mes)|opf\
          |dblac|uml|penCurly(DoubleQuote|Quote)|ver(B(ar|rac(e|ket))|Parenthes\
          is)|fr|Elig|acute|r|grave|m(icron|ega|acr)))
          |
          (p(s(cr|i)|h(i(v)?|one|mmat)|cy|i(tchfork|v)?|o(intint|und|pf)|uncsp|\
          er(cnt|tenk|iod|p|mil)|fr|l(us(sim|cir|two|d(o|u)|e|acir|mn|b)?|an(ck\
          (h)?|kv))|ar(s(im|l)|t|a(llel)?)?|r(sim|n(sim|E|ap)|cue|ime(s)?|o(d|p\
          (to)?|f(surf|line|alar))|urel|e(c(sim|n(sim|eqq|approx)|curlyeq|eq|ap\
          prox)?)?|E|ap)?|m)|P(s(cr|i)|hi|cy|i|o(incareplane|pf)|fr|lusMinus|ar\
          tialD|r(ime|o(duct|portion(al)?)|ecedes(SlantEqual|Tilde|Equal)?)?))
          |
          (q(scr|int|opf|u(ot|est(eq)?|at(int|ernions))|prime|fr)|Q(scr|opf|UOT\
          |fr))
          |
          (R(s(h|cr)|ho|c(y|edil|aron)|Barr|ight(Ceiling|T(ee(Vector|Arrow)?|ri\
          angle(Bar|Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeV\
          ector|DownVector|Vector(Bar)?)|Vector(Bar)?|arrow|Floor|A(ngleBracket\
          |rrow(Bar|LeftArrow)?))|o(undImplies|pf)|uleDelayed|e(verse(UpEquilib\
          rium|E(quilibrium|lement)))?|fr|EG|a(ng|cute|rr(tl)?)|rightarrow)|r(s\
          (h|cr|q(uo(r)?|b)|aquo)|h(o(v)?|ar(d|u(l)?))|nmid|c(y|ub|e(il|dil)|ar\
          on)|Barr|t(hree|imes|ri(e|f|ltri)?)|i(singdotseq|ng|ght(squigarrow|ha\
          rpoon(down|up)|threetimes|left(harpoons|arrows)|arrow(tail)?|rightarr\
          ows))|Har|o(times|p(f|lus|ar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|ldhar)|ul\
          uhar|p(polint|ar(gt)?)|e(ct|al(s|ine|part)?|g)|f(isht|loor|r)|l(har|a\
          rr|m)|a(ng(d|e|le)?|c(ute|e)|t(io(nals)?|ail)|dic|emptyv|quo|rr(sim|h\
          k|c|tl|pl|fs|w|lp|ap|b(fs)?)?)|rarr|x|moust(ache)?|b(arr|r(k(sl(d|u)|\
          e)|ac(e|k))|brk)|A(tail|arr|rr)))
          |
          (s(s(cr|tarf|etmn|mile)|h(y|c(hcy|y)|ort(parallel|mid)|arp)|c(sim|y|n\
          (sim|E|ap)|cue|irc|polint|e(dil)?|E|a(p|ron))?|t(ar(f)?|r(ns|aight(ph\
          i|epsilon)))|i(gma(v|f)?|m(ne|dot|plus|e(q)?|l(E)?|rarr|g(E)?)?)|zlig\
          |o(pf|ftcy|l(b(ar)?)?)|dot(e|b)?|u(ng|cc(sim|n(sim|eqq|approx)|curlye\
          q|eq|approx)?|p(s(im|u(p|b)|et(neq(q)?|eq(q)?)?)|hs(ol|ub)|1|n(e|E)|2\
          |d(sub|ot)|3|plus|e(dot)?|E|larr|mult)?|m|b(s(im|u(p|b)|et(neq(q)?|eq\
          (q)?)?)|n(e|E)|dot|plus|e(dot)?|E|rarr|mult)?)|pa(des(uit)?|r)|e(swar\
          |ct|tm(n|inus)|ar(hk|r(ow)?)|xt|mi|Arr)|q(su(p(set(eq)?|e)?|b(set(eq)\
          ?|e)?)|c(up(s)?|ap(s)?)|u(f|ar(e|f))?)|fr(own)?|w(nwar|ar(hk|r(ow)?)|\
          Arr)|larr|acute|rarr|m(t(e(s)?)?|i(d|le)|eparsl|a(shp|llsetminus))|bq\
          uo)|S(scr|hort(RightArrow|DownArrow|UpArrow|LeftArrow)|c(y|irc|edil|a\
          ron)?|tar|igma|H(cy|CHcy)|opf|u(c(hThat|ceeds(SlantEqual|Tilde|Equal)\
          ?)|p(set|erset(Equal)?)?|m|b(set(Equal)?)?)|OFTcy|q(uare(Su(perset(Eq\
          ual)?|bset(Equal)?)|Intersection|Union)?|rt)|fr|acute|mallCircle))
          |
          (t(s(hcy|c(y|r)|trok)|h(i(nsp|ck(sim|approx))|orn|e(ta(sym|v)?|re(4|f\
          ore))|k(sim|ap))|c(y|edil|aron)|i(nt|lde|mes(d|b(ar)?)?)|o(sa|p(cir|f\
          (ork)?|bot)?|ea)|dot|prime|elrec|fr|w(ixt|ohead(leftarrow|rightarrow)\
          )|a(u|rget)|r(i(sb|time|dot|plus|e|angle(down|q|left(eq)?|right(eq)?)\
          ?|minus)|pezium|ade)|brk)|T(s(cr|trok)|RADE|h(i(nSpace|ckSpace)|e(ta|\
          refore))|c(y|edil|aron)|S(cy|Hcy)|ilde(Tilde|Equal|FullEqual)?|HORN|o\
          pf|fr|a(u|b)|ripleDot))
          |
          (u(scr|h(ar(l|r)|blk)|c(y|irc)|t(ilde|dot|ri(f)?)|Har|o(pf|gon)|d(har\
          |arr|blac)|u(arr|ml)|p(si(h|lon)?|harpoon(left|right)|downarrow|uparr\
          ows|lus|arrow)|f(isht|r)|wangle|l(c(orn(er)?|rop)|tri)|a(cute|rr)|r(c\
          (orn(er)?|rop)|tri|ing)|grave|m(l|acr)|br(cy|eve)|Arr)|U(scr|n(ion(Pl\
          us)?|der(B(ar|rac(e|ket))|Parenthesis))|c(y|irc)|tilde|o(pf|gon)|dbla\
          c|uml|p(si(lon)?|downarrow|Tee(Arrow)?|per(RightArrow|LeftArrow)|Down\
          Arrow|Equilibrium|arrow|Arrow(Bar|DownArrow)?)|fr|a(cute|rr(ocir)?)|r\
          ing|grave|macr|br(cy|eve)))
          |
          (v(s(cr|u(pn(e|E)|bn(e|E)))|nsu(p|b)|cy|Bar(v)?|zigzag|opf|dash|prop|\
          e(e(eq|bar)?|llip|r(t|bar))|Dash|fr|ltri|a(ngrt|r(s(igma|u(psetneq(q)\
          ?|bsetneq(q)?))|nothing|t(heta|riangle(left|right))|p(hi|i|ropto)|eps\
          ilon|kappa|r(ho)?))|rtri|Arr)|V(scr|cy|opf|dash(l)?|e(e|r(yThinSpace|\
          t(ical(Bar|Separator|Tilde|Line))?|bar))|Dash|vdash|fr|bar))
          |
          (w(scr|circ|opf|p|e(ierp|d(ge(q)?|bar))|fr|r(eath)?)|W(scr|circ|opf|e\
          dge|fr))
          |
          (X(scr|i|opf|fr)|x(s(cr|qcup)|h(arr|Arr)|nis|c(irc|up|ap)|i|o(time|do\
          t|p(f|lus))|dtri|u(tri|plus)|vee|fr|wedge|l(arr|Arr)|r(arr|Arr)|map))
          |
          (y(scr|c(y|irc)|icy|opf|u(cy|ml)|en|fr|ac(y|ute))|Y(scr|c(y|irc)|opf|\
          uml|Icy|Ucy|fr|acute|Acy))
          |
          (z(scr|hcy|c(y|aron)|igrarr|opf|dot|e(ta|etrf)|fr|w(nj|j)|acute)|Z(sc\
          r|c(y|aron)|Hcy|opf|dot|e(ta|roWidthSpace)|fr|acute))
          )\\b"

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  class-names:
    comment: Names for built-in classes
    patterns:
      - comment:

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive data types
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          bool(ean)?|u?int|float|natural|ratio|real|imag|complex|number
          |char|rune|string|symbol|regexp?|function|buffer|binary
          |# numeric types
          ([cifsun]|natural|ratio|u?int|real|imag|complex)
          (8|16|32|64|128)
          |[ci](half|float|double|decimal|octuple)
          )\b
        name: support.type.builtin.primitive.so
      - comment: Constant/algebraic types
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          true|false|null|void|nan|infin
          |any|empty|object|record|unit|mixed
          |just|some|none|never|(im)?pure|channel
          )\b
        name: support.type.builtin.so
      - comment: Data structures
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          array|tuple|(?:mut)?(?:list|set|map)|dict|function
          |process|sequence|generator|range|stack|heap|queue|tree|trie
          )\b
        name: support.type.primitive.so
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          Bool(ean)?|U?Int|Float|Natural|Ratio|Real|Imag|Complex|Number
          |Char|Rune|String|Symbol|RegExp?|Function|Buffer|Binary
          |# Numeric Types
          ([CIFSUN]|Natural|Ratio|U?Int|Real|Imag|Complex)
          (8|16|32|64|128)
          |[CI](Half|Float|Double|Decimal|Octuple)
          )\b
        name: support.class.builtin.primitive.so
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          True|False|Null|Void|NaN|Infin
          |Any|Empty|Object|Record|Unit|Mixed
          |Just|Some|None|Never|(Im)?pure|Channel
          )\b
        name: support.class.builtin.so
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(
          Array|Tuple|(Mut)?(List|Set|Map)|Dict|Function
          |Process|Sequence|Generator|Range|Stack|Heap|Queue|Tree|Trie
          )\b
        name: support.class.primitive.so

      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.so
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.so
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.so
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.so

  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns: []

  variable-names:
    comment: Standard Library variable names
    patterns: []

  property-names:
    comment: Standard Library property names
    patterns: []

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )\b\s*
        captures:
          1: {name: constant.language.boolean.true.so}
          2: {name: constant.language.boolean.false.so}
          3: {name: constant.language.null.so}
          4: {name: constant.language.undefined.so}
          5: {name: constant.language.nan.so}
          6: {name: constant.language.infinity.so}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:
          (it|that|arguments|super|this|self|proto|prototype|constructor|target)
          )\b\s*
        captures:
          1: {name: variable.language.$1.so}

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.so
      - match: (?<=(?:^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.so
      - match: (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:_*\p{Alnum}+)*)
          (?:(\.)(?:\p{Alnum}+(?:_*\p{Alnum}+)*)?)?
          (?:(\*)\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (?:(\.)(?:\p{Alnum}+(?:_*\p{Alnum}+)*)?)
          (?:(\*)\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0b)
          (?:[01]+(?:_*[01]+)*)
          (?:(\.)(?:[01]+(?:_*[01]+)*)?)?
          (?:(\*)[01]+(?:_*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0b)
          (?:[01]+(?:_*[01]+)*)?
          (?:(\.)(?:[01]+(?:_*[01]+)*)?)
          (?:(\*)[01]+(?:_*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:_*[0-3]+)*)
          (?:(\.)(?:[0-3]+(?:_*[0-3]+)*)?)?
          (?:(\*)[0-3]+(?:_*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:_*[0-3]+)*)?
          (?:(\.)(?:[0-3]+(?:_*[0-3]+)*)?)
          (?:(\*)[0-3]+(?:_*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:_*[0-5]+)*)
          (?:(\.)(?:[0-5]+(?:_*[0-5]+)*)?)?
          (?:(\*)[0-5]+(?:_*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:_*[0-5]+)*)?
          (?:(\.)(?:[0-5]+(?:_*[0-5]+)*)?)
          (?:(\*)[0-5]+(?:_*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:_*[0-7]+)*)
          (?:(\.)(?:[0-7]+(?:_*[0-7]+)*)?)?
          (?:(\*)[0-7]+(?:_*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:_*[0-7]+)*)?
          (?:(\.)(?:[0-7]+(?:_*[0-7]+)*)?)
          (?:(\*)[0-7]+(?:_*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:_*[\dab]+)*)
          (?:(\.)(?:[\dab]+(?:_*[\dab]+)*)?)?
          (?:(\*)[\dab]+(?:_*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:_*[\dab]+)*)?
          (?:(\.)(?:[\dab]+(?:_*[\dab]+)*)?)
          (?:(\*)[\dab]+(?:_*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0x)
          (?:\h+(?:_*\h+)*)
          (?:(\.)(?:\h+(?:_*\h+)*)?)?
          (?:(\*)\h+(?:_*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (0x)
          (?:\h+(?:_*\h+)*)?
          (?:(\.)(?:\h+(?:_*\h+)*)?)
          (?:(\*)\h+(?:_*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          ()
          (?:\d+(?:_*\d+)*)
          (?:(\.)(?:\d+(?:_*\d+)*)?)?
          (?:(\*)\d+(?:_*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          ()
          (?:\d+(?:_*\d+)*)?
          (?:(\.)(?:\d+(?:_*\d+)*)?)
          (?:(\*)\d+(?:_*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:_*\w+)*)
          (?:(\.)(?:\w+(?:_*\w+)*)?)?
          (?:(\*)\w+(?:_*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}
      - match: (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:_*\w+)*)?
          (?:(\.)(?:\w+(?:_*\w+)*)?)
          (?:(\*)\w+(?:_*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.so}
          1: {name: storage.type.numeric.so}
          2: {name: punctuation.separator.decimal.period.so}
          3: {name: constant.numeric.other.separator.so}
          4: {name: constant.numeric.other.exponent.so}
          5: {name: constant.numeric.other.density.so}
          6: {name: storage.type.numeric.so}

  strings-quoted:
    patterns:
      - comment: single quoted raw string
        begin: \s*('{3,})
        contentName: string.quoted.single.so
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.so}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: \s*(')
        contentName: string.quoted.single.so
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.so}
        patterns:
          - match: "''"
            name: constant.character.escape.so
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: \s*("{3,}|")
        contentName: string.quoted.double.so
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.so}
        patterns:
          - include: "#string-content"

  strings-unquoted:
    patterns:
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:|->)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.so}
          2: {name: storage.modifier.chomping-indicator.so}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.so}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.so
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.so
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:|->)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.so}
          2: {name: storage.modifier.chomping-indicator.so}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.so}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.syntax.so
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.so
            patterns:
              - include: "#string-content"
              - include: text.html.markdown#inline
          - include: $self
      - match: |
          (?x)
          \s*(\\)
          ((?:\\.|[^({\[)}\]\s.,:;])+?)
          (?=[({\[)}\]\s.,:;]|$)\s*
        name: string.unquoted.so
        captures:
          1: {name: punctuation.definition.string.so}
          2: {patterns: [include: "#string-content"]}

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.so
      - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
        name: constant.character.escape.binary.so
      - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
        name: constant.character.escape.quaternary.so
      - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
        name: constant.character.escape.senary.so
      - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
        name: constant.character.escape.octal.so
      - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
        name: constant.character.escape.decimal.so
      - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
        name: constant.character.escape.duodecimal.so
      - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.hexadecimal.so
      - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.unicode.so
      - begin: \\j{
        end: \s*}
        name: constant.character.entity.named.so
        patterns:
          - include: "#unicode-named-chars"
          - include: "#regexp-patterns"
      - match: (?i)\\[abceflnprtvz]
        name: constant.character.escape.so
      - match: \\[\p{S}\p{P}]
        name: constant.character.escape.symbol.so
      - match: \\[\p{L}\p{N}\p{Z}\p{C}]
        name: constant.character.escape.illegal.so

  embedded:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.section.embedded.so}
          2: {name: constant.numeric.decimal.so}
      - match: (%)((['"`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.so}
          2: {name: storage.type.format.so}
      - match: |
          (?xi)
          (?#?<!\\)# discard escape prefix
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:|->)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.so}
          2: {patterns: [include: $self]}
      - begin: (?#?<!\\)(\${)\s*
        end: (})
        name: entity.quasi.element.so
        captures:
          1: {name: punctuation.section.embedded.so}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.section.embedded.so}
          2: {name: constant.numeric.decimal.so}
      - match: ([$%]){2}
        name: constant.character.escape.so
      - match: (%)((['"`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.so}
          2: {name: storage.type.format.so}
      - match: |
          (?xi)
          (?<!\$)# discard escape prefix
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:|->)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.so}
          2: {patterns: [include: $self]}
      - begin: (?<!\$)(\${)\s*
        end: (})
        name: entity.quasi.element.so
        captures:
          1: {name: punctuation.section.embedded.so}
        patterns:
          - include: $self

  symbols:
    match: |
      (?x)
      \s*
      (:)((?:\\.|[^({\[)}\]\s.,:;])+?)
      (?=[({\[)}\]\s.,:;]|$)\s*
    name: meta.symbol.so
    captures:
      1: {name: punctuation.definition.symbol.so}
      2: {name: constant.other.symbol.so}

  labels:
    match: |
      (?x)
      (?<=^|[({\[\s,;*+-])\s*
      ((?:\w|\\.)(?:\\.|[^({\[)}\]\s.,:;])*?)
      (:)\s+
    name: meta.object-literal.key.so
    captures:
      1:
        name: constant.other.object.key.so
        patterns: [include: "#string-escapes"]
      2: {name: punctuation.separator.key-value.so}

  regexps:
    patterns:
      - begin: (\p{Alnum}*)(`)\s*
        end: \s*(?!\\)(`(?!`))(\p{Alnum}*)
        contentName: string.pattern.regexp.so
        beginCaptures:
          1: {name: keyword.modifier.so}
          2: {name: punctuation.section.regexp.begin.so}
        endCaptures:
          1: {name: punctuation.section.regexp.end.so}
          2: {name: keyword.other.flag.so}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - begin: (`)(`)\s*\n?
            end: \s*(?=(?!\\)`)
            contentName: string.replace.regexp.so
            beginCaptures:
              1: {name: punctuation.section.regexp.end.so}
              2: {name: punctuation.section.regexp.begin.so}
            patterns:
              - include: "#back-references"
      - begin: |
          (?x)\s*
          (\\\<)\s*
          ([-+*/<=>])?\s*
          (?:(\w+)?\b\s*\b
          (
          \w+\s*
          (?:[+-]\s*
          (?:(?:\w+)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.so}
          2: {name: storage.modifier.chomping-indicator.so}
          3: {name: keyword.modifier.so}
          4: {name: keyword.other.flag.so}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.so
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.out.so
            patterns:
              - include: "#regexp-patterns"
          - include: $self

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.so
      - match: \${2}
        name: constant.character.escape.so
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.so
        beginCaptures:
          1: {name: keyword.other.back-reference.so}
        endCaptures:
          1: {name: keyword.other.back-reference.so}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-content"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.so
      - match: \&
        name: keyword.operator.match.so
      - match: \!
        name: keyword.operator.disjunction.so
      - match: \.
        name: constant.character.all.so
      - match: (?i)\\[by]({\p{Alpha}+})?
        name: keyword.control.anchor.so
      - match: (?i)(\^|\\<|\\a(?:{\p{Alpha}+})?)|(\$|\\>|\\z(?:{\p{Alpha}+})?)
        captures:
          1: {name: keyword.control.begin.so}
          2: {name: keyword.control.end.so}
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.so}
          2: {name: keyword.operator.quantifier.lazy.so}
          3: {name: keyword.operator.quantifier.eager.so}
          4: {name: keyword.operator.quantifier.greedy.so}
      - match: \\\d+
        name: keyword.other.back-reference.so
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.so
      - begin: (\\Q)
        contentName: string.quoted.single.so
        end: (\\E)
        name: string.quoted.raw.so
        captures:
          1: {name: punctuation.definition.string.so}
        patterns:
          - include: "#string-content"
      - begin: (\\q)
        contentName: string.quoted.double.so
        end: (\\e)
        name: string.quoted.so
        captures:
          1: {name: punctuation.definition.string.so}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.so
        beginCaptures:
          1: {name: keyword.other.back-reference.so}
        endCaptures:
          1: {name: keyword.other.back-reference.so}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.so
        beginCaptures:
          1: {name: keyword.other.subroutine.so}
        endCaptures:
          1: {name: keyword.other.subroutine.so}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.so}
          2: {name: keyword.control.keepout.so}
          3: {name: keyword.control.search.so}
          4: {name: constant.character.unicode.so}
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.so}
          2: {name: keyword.operator.modifier.eager.so}
          3: {name: keyword.operator.modifier.greedy.so}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.so}
          2: {name: keyword.operator.quantifier.eager.so}
          3: {name: keyword.operator.quantifier.greedy.so}
      - match: \\.
        name: constant.character.escape.other.so

    repository:
      regexp-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.so
            captures:
              0: {name: punctuation.section.expression.so}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.so
            end: \s*(\))
            name: comment.block.regexp.so
            captures:
              1: {name: punctuation.definition.comment.so}
            patterns:
              - match: \\.
                name: comment.block.regexp.so
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.look-ahead.so
            captures:
              1: {name: punctuation.definition.group.look-ahead.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.look-behind.so
            captures:
              1: {name: punctuation.definition.group.look-behind.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.negative-look-ahead.so
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.negative-look-behind.so
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{Lower}+(?:[+-]\p{Lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.flag.so
            captures:
              0: {name: punctuation.definition.group.flag.so}
              1: {name: punctuation.definition.group.flag.so}
              2: {name: entity.name.function.method.so}
              3: {name: keyword.control.recursion.so}
              4: {name: keyword.other.flag.so}
              5: {name: punctuation.separator.colon.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.call-out.so
            captures:
              1: {name: punctuation.definition.group.call-out.so}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.so
                captures:
                  1: {name: punctuation.definition.group.call-out.so}
                  2: {name: keyword.operator.range.so}
                  3: {name: punctuation.definition.tag.so}
                  4: {patterns: [include: "#function-entities"]}
                  5: {name: punctuation.definition.tag.so}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.atomic.so
            captures:
              1: {name: punctuation.definition.group.atomic.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.non-capturing.so
            captures:
              1: {name: punctuation.definition.group.non-capturing.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.branch.so
            captures:
              1: {name: punctuation.definition.group.branch.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.absent.so
            captures:
              1: {name: punctuation.definition.group.absent.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.back-reference.so
            captures:
              0: {name: punctuation.definition.group.back-reference.so}
              1: {name: punctuation.definition.group.back-reference.so}
              2: {name: entity.name.function.method.so}
              3: {name: variable.other.so}
              4: {name: punctuation.separator.colon.so}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.named.so
            beginCaptures:
              0: {name: punctuation.definition.group.named.so}
              1: {patterns: [include: "#variables"]}
            endCaptures:
              0: {name: punctuation.definition.group.named.so}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.so
                beginCaptures:
                  1: {name: punctuation.definition.group.named.so}
                endCaptures:
                  1: {name: punctuation.definition.group.named.so}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            name: meta.group.so
            captures:
              0: {name: punctuation.definition.group.so}
            patterns:
              - include: "#regexp-patterns"

      regexp-char-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.so
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.so
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.so
            patterns:
              - include: "#unicode-named-chars"
              - include: "#regexp-patterns"
          - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
            name: constant.character.escape.binary.so
          - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
            name: constant.character.escape.quaternary.so
          - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
            name: constant.character.escape.senary.so
          - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
            name: constant.character.escape.octal.so
          - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
            name: constant.character.escape.decimal.so
          - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
            name: constant.character.escape.duodecimal.so
          - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.hexadecimal.so
          - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.unicode.so
          - match: (?i:\\[cm][a-z])|\\R
            name: constant.character.control.so
          - match: *posix-class
            name: constant.other.character-class.posix.so
          - match: (?i:\\p(c[cfos]?|l[lmotu]?|m[cen]?|n[dlo]?|p[c-fios]?|s[ckmo]?|z[lps]))
            name: constant.other.character-class.unicode.so
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.so
          - match: \.|\\[dhlns-w]
            name: constant.other.character-class.so
          - match: \\[DHLNS-W]
            name: constant.other.character-class.negated.so
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.so
          - match: (?i)\\[abceflnprtvz]
            name: constant.character.escape.so
          - match: \\[\p{S}\p{P}]
            name: constant.character.escape.symbol.so
          - match: \\\p{Z}
            name: constant.character.escape.symbol.so
          - match: \\[\p{L}\p{N}\p{Z}\p{C}]
            name: constant.character.escape.illegal.so
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: \.
            name: constant.other.character-class.range.so
          - match: (?<!\|)\|\|(?!\|)
            name: keyword.operator.union.so
          - match: (?<!&)&&(?!&)
            name: keyword.operator.intersection.so
          - match: (?<!\^)\^\^(?!\^)
            name: keyword.operator.symmetric.so
          - match: (?<!~)~~(?!~)
            name: keyword.operator.negation.so
          - match: (?<!-)--(?!-)
            name: keyword.operator.difference.so
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.so
          - match: \\.
            name: constant.character.escape.other.so

      regexp-char-set:
        patterns:
          - begin: (\[=)
            end: \s*(\])
            name: constant.other.character-class.posix.so
            captures:
              1: {name: punctuation.definition.character-class.posix.so}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\.)
            end: \s*(\])
            name: constant.other.character-class.posix.so
            captures:
              1: {name: punctuation.definition.character-class.posix.so}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[:)
            end: \s*(\])
            name: constant.other.character-class.posix.so
            captures:
              1: {name: punctuation.definition.character-class.posix.so}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.negated.so
            captures:
              1: {name: punctuation.definition.character-class.negated.so}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.so
            captures:
              1: {name: punctuation.definition.character-class.so}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"

  tag-names:
    patterns:
      - match: (?x)\b([\p{Pc}\p{L}]\w*)\b(?=[.:])
        name: entity.name.tag.namespace.so
      - match: |
          (?x)\b
          (?:# Regular variables
          (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )\b
        captures:
          1: {name: entity.name.tag.style.so}
          2: {name: entity.name.tag.script.so}
          3: {name: entity.name.tag.so support.class.component.so}
          4: {name: entity.name.tag.so}
      - match: ":"
        name: punctuation.separator.namespace.so
      - match: \.
        name: punctuation.accessor.so

  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    patterns:
      - begin: (?=<[\p{Pc}\p{L}])
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#tag-element-name"
    repository:
      tag-element-name:
        patterns:
          - comment: JSX Fragment
            name: meta.tag.so
            contentName: meta.tag.so
            begin: \s*+(<)\s*(?=>)
            end: (?<=</)(>)
            beginCaptures:
              1: {name: punctuation.definition.tag.so}
            endCaptures:
              1: {name: punctuation.definition.tag.so}
            patterns:
              - include: "#tag-termination"
          - comment: "Tags that end > are trapped in #tag-termination"
            name: meta.tag.so
            contentName: meta.tag.so
            begin: |
              (?x)\s*+(<)#start tag begin
              ([\p{Pc}\p{L}]\w*(?:[:.][\p{Pc}\p{L}]\w*)*)#tag name
              (?=[\/>\s])(?![:])(?<!\.|:)
            end: \s*(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>
            beginCaptures:
              1: {name: punctuation.definition.tag.so}
              2: {patterns: [include: "#tag-names"]}
            endCaptures:
              1: {patterns: [include: "#tag-names"]}
              2: {name: punctuation.definition.tag.so}
              3: {name: punctuation.definition.tag.so}
              4: {name: invalid.illegal.termination.so}
            patterns:
              - include: "#tag-termination"
              - include: "#tag-attributes"
      tag-termination:
        comment: uses non consuming search for </ in </tag>
        contentName: meta.jsx.children.so
        name: meta.jsx.children.so
        begin: (>)
        end: (</)
        captures:
          0: {name: punctuation.definition.tag.so}
        patterns:
          - include: "#evaluated-code"
          - include: "#entities"
          - include: "#tag-element-name"
          - include: "#string-content"
          - include: markdown.math.block
          - include: text.html.markdown#inline
      attribute-expression:
        begin: (?<==)\(
        end: \)
        captures:
          0: {name: punctuation.section.embedded.so}
        patterns:
          - include: $self
      tag-attributes:
        patterns:
          - include: source.yaml#flow-collection
          - include: "#evaluated-code"
          - include: "#attribute-name"
          - include: "#attribute-expression"
          - include: "#spread-attribute"
          - include: "#strings-unquoted"
          - include: "#strings-quoted"
          - include: "#numbers"
          - include: "#regexps"
          - include: "#string-content"
          - include: "#tag-element-name"
          - include: "#comments"
      spread-attribute:
        comment: Spread attribute { ... AssignmentExpression }
        match: (?<!\*)\*(?!\*)
        name: keyword.operator.spread.so
      attribute-name:
        patterns:
          - comment: Style attribute
            begin: (?<!\S)(style)(=)?({)
            end: \s*(})\s*
            beginCaptures:
              1: {name: entity.other.attribute-name.so}
              2: {name: punctuation.separator.key-value.so}
              3: {name: punctuation.section.embedded.so}
            endCaptures:
              1: {name: punctuation.section.embedded.so}
            patterns:
              - include: source.css.scss#flow_control
              - include: source.css.scss#rules
              - include: source.css.scss#properties
              - include: source.css.scss
          - comment: Attribute names
            match: (?<=[)\]}])(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
            captures:
              1: {name: punctuation.separator.key-value.so}
              2:
                name: string.unquoted.html.so
                patterns:
                  - include: "#string-content"
                  - include: source.yaml#flow-scalar-plain-out-implicit-type
          - comment: Attribute names
            match: (?<!\S)([\p{Pc}\p{L}]\w*)(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
            captures:
              1: {name: entity.other.attribute-name.so}
              2: {name: punctuation.separator.key-value.so}
              3:
                name: string.unquoted.html.so
                patterns:
                  - include: "#string-content"
                  - include: source.yaml#flow-scalar-plain-out-implicit-type
      evaluated-code:
        begin: "{"
        end: "}"
        captures:
          0: {name: punctuation.section.embedded.so}
        patterns:
          - include: "#spread-attribute"
          - include: $self
      entities:
        patterns:
          - include: text.html.basic#entities
          - include: text.xml#entity
          - comment: Entity with & and invalid name
            match: "&\\s*+;"
            name: invalid.illegal.bad-ampersand.so

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-namepath"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-namepath"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-noname"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match:
          (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss
          mixin|singleton|template|uses|xtype)\b
        name: storage.type.class.jsdoc

    repository:
      jsdoc-access:
        comment: "@tag protected...."
        match: (@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-module:
        comment: "@tag {optional type} module:file"
        begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - match: (?:(module)(:))?(((?!\*/)\S)+)
            captures:
              1: {name: keyword.module.jsdoc}
              2: {name: punctuation.jsdoc}
              3: {name: string.modulename.jsdoc}
      jsdoc-as-namepath:
        comment: to terminate the block
        begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-namepath-scopes"
      jsdoc-simple:
        comment: "@tag"
        match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-namepath:
        comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
        begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-namepath-scopes"
      jsdoc-type-name:
        comment: "@tag {optional type} name"
        begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-name-scopes"
      jsdoc-type-noname:
        comment: "@tag {types}"
        begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
      jsdoc-inline-tags:
        name: meta.tag.inline.jsdoc
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.jsdoc}
              3: {name: string.jsdoc}
      jsdoc-typedef-scopes:
        name: entity.name.type.instance.jsdoc
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - include: "#jsdoc-namepath-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-obj:
        comment: typedef object
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - match: \b([$_A-Za-z][$_A-Za-z0-9]*)\s*(:)
            captures:
              1: {name: variable.other.readwrite.jsdoc}
          - include: "#jsdoc-namepath-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-name-scopes:
        patterns:
          - match: ((?!\*/)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.jsdoc}
          - name: variable.other.jsdoc
            begin: \[
            end: \]|^
            patterns:
              - include: "#jsdoc-string"
              - include: "#jsdoc-name-scopes"
      jsdoc-namepath-scopes:
        patterns:
          - match: \s*\b(as)\b\s*(?=[$_A-Za-z])
            captures:
              1: {name: keyword.as.jsdoc}
          - match: \s*(?:([A-Z][$_A-Za-z0-9]*)|([$_A-Za-z][$_A-Za-z0-9]*))(?=[\s\-~.#]|$)
            captures:
              1: {name: entity.name.class.jsdoc}
              2: {name: entity.name.function.jsdoc}
          - match: (\.)([$_A-Za-z][$_A-Za-z0-9]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.static.jsdoc}
          - match: (\#)([$_A-Za-z][$_A-Za-z0-9]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.instance.jsdoc}
          - match: (~|-)([$_A-Za-z][$_A-Za-z0-9]*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.inner.jsdoc}
          - match: (\#)(event)(:)
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: keyword.event.jsdoc}
              3: {name: keyword.operator.jsdoc}
          - name: string.method.jsdoc
            begin: \.(?="|')
            end: (?=.)
            applyEndPatternLast: 1
            patterns:
              - include: "#jsdoc-string"
      jsdoc-string:
        name: string.jsdoc
        match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  comments:
    patterns:
      - begin: \s*((/\+\+))
        end: (\s*(\+/))
        name: comment.block.documentation.nested.so
        captures:
          1: {name: comment.block.documentation.so}
          2: {name: punctuation.definition.comment.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-block-jsdoc"
      - begin: \s*((/\+))
        end: (\s*(\+/))
        name: comment.block.nested.so
        captures:
          1: {name: comment.block.nested.so}
          2: {name: punctuation.definition.comment.so}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*((/\*\*))
        end: (\s*(\*/))
        name: comment.block.documentation.so
        captures:
          1: {name: comment.block.documentation.so}
          2: {name: punctuation.definition.comment.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*((/\*))
        end: (\s*(\*/))
        name: comment.block.so
        captures:
          1: {name: comment.block.so}
          2: {name: punctuation.definition.comment.so}
        patterns:
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//=))
        end: \s*$
        name: comment.line.special.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.special.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          1: {name: punctuation.definition.comment.so}
        patterns:
          - include: "#comment-special"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//\+))
        end: \s*$
        name: comment.line.playground.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.playground.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          0: {name: comment.line.playground.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((///))
        end: \s*$
        name: comment.line.documentation.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.documentation.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          0: {name: comment.line.documentation.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//!|\A#!))
        end: \s*$
        name: comment.line.shebang.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.shebang.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          0: {name: comment.line.shebang.so}
        patterns:
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//\*))
        end: \s*$
        name: comment.line.doctype.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.doctype.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          0: {name: comment.line.doctype.so}
        patterns:
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//))
        end: \s*$
        name: comment.line.number-sign.so
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.so}
          3: {name: comment.line.double-slash.so}
          4: {name: punctuation.definition.comment.so}
        endCaptures:
          0: {name: comment.line.number-sign.so}
        patterns:
          - include: text.html.markdown#inline

    repository:
      nested-block-jsdoc:
        begin: (/\+\+)\s*
        end: \s*(\+/)
        name: comment.block.documentation.nested.so
        captures:
          1: {name: punctuation.definition.comment.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-block-jsdoc"
      nested-block:
        begin: (/\+)\s*
        end: \s*(\+/)
        name: comment.block.nested.so
        captures:
          1: {name: punctuation.definition.comment.so}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"
      nested-special:
        begin: (/\+)\s*
        end: \s*(\+/)
        captures:
          1: {name: punctuation.definition.comment.so}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-special"

  calls:
    patterns:
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|component|element|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b\s+
          (?=
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|component|element|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [\w]+|\[(?!<)|<\|(?!>)(?=\|*)|<\+(?!>)(?=\+*))
        captures:
          1: {patterns: [include: "#function-entities"]}
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|component|element|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b
          (?=
          !(?:\.=?)?\s*|
          \s+[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|component|element|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )

          [\w]+|\[<|
          (?:[!?~]?\.=?|[?!:]:=?|->)?\s*\(|
          (?:[!?~]?\.=?|[?!:]:=?|->)?\s+['"`\\\[]
          )
        captures:
          1: {patterns: [include: "#function-entities"]}

  function-entities:
    patterns:
      - match: |
          (?x)\b(?:
          (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          |
          (?:# Objects and maps
          (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
          |
          (?:# Regular variables
          (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.so}
          2: {name: entity.name.tag.so support.class.component.so}
          3: {name: entity.name.class.builtin.so}
          4: {name: entity.name.function.method.so}
          5: {name: variable.other.global.so}
          6: {name: variable.other.constant.object.so}
          7: {name: variable.other.conditional.so}
          8: {name: variable.other.object.so}
          9: {name: entity.name.function.tagged-template.so}
          10: {name: entity.name.type.so}
          11: {name: entity.name.class.so}
          12: {name: entity.name.function.so}
      - include: $self

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
      |
      (?:# Regular variables
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.so}
      2: {name: variable.other.constant.property.so}
      3: {name: variable.other.property.static.so}
      4: {name: variable.other.property.so}
      5: {name: variable.other.global.so}
      6: {name: variable.other.constant.object.so}
      7: {name: variable.other.conditional.so}
      8: {name: variable.other.object.so}
      9: {name: variable.other.dollar.so}
      10: {name: variable.other.constant.so}
      11: {name: variable.other.class.so}
      12: {name: variable.other.readwrite.so}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops-builtin:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|['"`\\({\[\s])([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+(?<![!:~.<=>])=)(?=$|['"`\\\s)}\]])
            name: keyword.operator.assignment.augmented.so

          - comment: |
              BUILTIN OPERATORS

              1: assignment : :=
              2: arithmetic + - * ** *** / // /// % %% *> <*
              3: increment/decrement ++ --
              4: logical && || ^^ !& !| !^ &| &!
              5: bitwise & | ^ ~
              6: bitwise shift << >> <<< >>>
              7: function pipeline <| |> <|| ||> <||| |||>
              8: function composition +> <+ <++ +>>
              9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
              10: relational < > <= >=
              11: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
              12: equality == != === !==
              13: wavy operators ~> <~ ~~> <~~
              14: fat arrow-like => ==> <==
              15: skinny arrow-like -> --> <- <--
              16: null-coalescing ??
              17: non-null coalescing !!
              18: compact ternary operator ?:
              19: inverse ternary operator !:
              20: infix function call $:
            captures:
              1: {name: keyword.operator.assignment.so}
              2: {name: keyword.operator.arithmetic.so}
              3: {name: keyword.operator.successor.so}
              4: {name: keyword.operator.logical.so}
              5: {name: keyword.operator.bitwise.so}
              6: {name: keyword.operator.bitwise.shift.so}
              7: {name: keyword.operator.pipeline.so}
              8: {name: keyword.operator.compose.so}
              9: {name: keyword.operator.class.so}
              10: {name: keyword.operator.relational.so}
              11: {name: keyword.operator.regexp.so}
              12: {name: keyword.operator.comparison.so}
              13: {name: keyword.operator.similarity.so}
              14: {name: keyword.operator.arrow.fat.so}
              15: {name: keyword.operator.arrow.skinny.so}
              16: {name: keyword.operator.null-coalescing.so}
              17: {name: keyword.operator.coalescing.so}
              18: {name: keyword.operator.conditional.so}
              19: {name: keyword.operator.ternary.so}
              20: {name: keyword.operator.macro.dollar.so}
            match: |
              (?x)
              (?<=^|['"`\\({\[\s])# spacing
              (?:
              (:?=)#1
              |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
              |(\+\+|--)#3
              |([&|^~]{2})#4
              |([&|^~])#5
              |(<<<?|>>>?)#6
              |(\|{1,3}>|<\|{1,3})#7
              |(\+>|<\+)#8
              |([<>]?[!:][<>]?)#9
              |([<>]=?)#10
              |(<>|=<|<?[/*|+$]>?)#11
              |([!=]==?)#12
              |(~>|<~|~~>|<~~)#13
              |(<==|==?>)#14
              |(--?>|<--?)#15
              |(\?\?)#16
              |(!!)#17
              |(\?:)#18
              |(!:)#19
              |(\$:)#20
              )
              (?=$|['"`\\\s)}\]])

          - comment: |
              CUSTOM OPERATORS

              1: custom bitwise (& | ^ ~)
              2: custom arithmetic (+ - * / %)
              3: custom prototype (:)
              4: custom accessor (.)
              5: custom equality (= !)
              6: custom comparison (< >)
              7: custom private (? #)
              8: custom mathematical (Unicode Sm)
              9: custom currency (Unicode Sc)
              10: custom ASCII (between \x80 and \xff)
              11: custom infix operators (all other chars)
            captures:
              1: {name: keyword.operator.bitwise.custom.so}
              2: {name: keyword.operator.arithmetic.custom.so}
              3: {name: keyword.operator.prototype.custom.so}
              4: {name: keyword.operator.accessor.custom.so}
              5: {name: keyword.operator.comparison.custom.so}
              6: {name: keyword.operator.relational.custom.so}
              7: {name: keyword.operator.private.custom.so}
              8: {name: keyword.operator.math.custom.so}
              9: {name: keyword.operator.currency.custom.so}
              10: {name: keyword.operator.ascii.custom.so}
              11: {name: keyword.operator.infix.custom.so}
            match: |
              (?x)
              (?<=^|['"`\\({\[\s])# spacing
              (?:
              ([&|^~][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#1
              |([+\-*/%][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#2
              |(:[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#3
              |(\.[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#3
              |([!=][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#4
              |([<>][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#5
              |([?\#][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#6
              |(\p{Sm}[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#7
              |(\p{Sc}[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#8
              |([\p{S}\p{P}&&[\x80-\xff]][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#9
              |([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#10
              )
              (?=$|['"`\\\s)}\]])

      binary-ops:
        match: (?<=^|['"`\\\s({\[])([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)(?=$|['"`\\\s)}\]])
        captures:
          0: {patterns: [include: "#binary-ops-builtin"]}

      unary-ops:
        patterns:
          - &transfix-operators
            comment: Transfix binary operators
            match: |
              (?x)(?<=\b|^|[)}\]'"`\\])
              (?:
              ([>.]\.[.<])
              |(\?\.=?)
              |(~\.=?)
              |(!\.=?)
              |((?:::|\.)=?)
              |(->))
              (?=\b|$|[({\['"`\\])
            captures:
              1: {name: keyword.operator.range.so}
              2: {name: punctuation.accessor.optional.so}
              3: {name: punctuation.accessor.cascade.so}
              4: {name: punctuation.accessor.call.so}
              5: {name: punctuation.accessor.so}
              6: {name: punctuation.accessor.module.so}

          - &prefix-operators
            comment: Prefix operators
            match: |
              (?x)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]])#15
              (?=[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*
              [\w({\[_,;'"`])
            name: keyword.operator.prefix.so
            captures:
              1: {name: keyword.operator.module.all.so}
              2: {name: keyword.operator.increment.so}
              3: {name: keyword.operator.decrement.so}
              4: {name: keyword.operator.intersection.so}
              5: {name: keyword.operator.union.so}
              6: {name: keyword.operator.symmetric.so}
              7: {name: keyword.operator.logical.so}
              8: {name: keyword.operator.private.so}
              9: {name: keyword.operator.decorator.so}
              10: {name: keyword.operator.bitwise.not.so}
              11: {name: keyword.operator.existential.so}
              12: {name: keyword.operator.assignment.so}
              13: {name: keyword.operator.pipeline.so}
              14: {name: keyword.operator.private.so}
              15: {name: keyword.operator.prefix.so}

          - &suffix-operators
            comment: Suffix operators
            match: |
              (?x)
              (?<=[\w)}\]_,;'"`]
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]])#15
            name: keyword.operator.suffix.so
            captures:
              1: {name: keyword.operator.module.all.so}
              2: {name: keyword.operator.increment.so}
              3: {name: keyword.operator.decrement.so}
              4: {name: keyword.operator.intersection.so}
              5: {name: keyword.operator.union.so}
              6: {name: keyword.operator.symmetric.so}
              7: {name: punctuation.accessor.call.so}
              8: {name: keyword.operator.private.so}
              9: {name: keyword.operator.decorator.so}
              10: {name: keyword.operator.bitwise.so}
              11: {name: punctuation.accessor.optional.so}
              12: {name: keyword.operator.assignment.so}
              13: {name: keyword.operator.pipeline.so}
              14: {name: keyword.operator.private.so}
              15: {name: keyword.operator.suffix.so}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# prefix
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
              \b(?:# don't match keywords
              in|of|as|is|new|infer|unset
              |typeof|nameof|sizeof|pairof|keyof|valueof
              |length|delete|to|til|thru|at|by
              |n?and|x?n?or|not|parallel|series|spawn|discard
              |func?|function|proc|process|macro
              |let|var|val|const|declare
              |class|given|constraint|enum|relation|lattice
              |project|attribute|protocol|member|extend|fragment|interface|struct
              |module|package|namespace|object|record|label
              |raw|data|query|schema|style|component|element|trait|friend|alias|type
              |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
              |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
              |switch|case|fail|default|match|when|pass|fallthru
              |try|retry|throw|raise|catch|rescue|finally
              |with|ref|defer|refer|show|hide|enter|exit
              |then|begin|end|debug|check|assert
              |break|continue|halt|skip|fixed|lock
              |(?:return|give|await|yield|throw|raise)s?
              |import|export|show|hide|open|close
              |from|where|join|equals?|[io]nto|order
              |take|drop|fold|scan|select|group|use|using
              )\b
              )
              [\w]+
              (?:[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# transfix
              [\w]+)*
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# suffix
              )\s*([^(]|$|;))
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.compose.so}
              2: {name: keyword.operator.pipeline.so}
            patterns:
              - match: |
                  (?x)\s*\b
                  (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|pairof|keyof|valueof
                  |length|delete|to|til|thru|at|by
                  |n?and|x?n?or|not|parallel|series|spawn|discard
                  |func?|function|proc|process|macro
                  |let|var|val|const|declare
                  |class|given|constraint|enum|relation|lattice
                  |project|attribute|protocol|member|extend|fragment|interface|struct
                  |module|package|namespace|object|record|label
                  |raw|data|query|schema|style|component|element|trait|friend|alias|type
                  |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
                  |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
                  |switch|case|fail|default|match|when|pass|fallthru
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|fixed|lock
                  |(?:return|give|await|yield|throw|raise)s?
                  |import|export|show|hide|open|close
                  |from|where|join|equals?|[io]nto|order
                  |take|drop|fold|scan|select|group|use|using
                  )\b
                  )
                  (?:
                  (?:# Objects and maps
                  (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                  |
                  (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
                  (?:# Properties (note all properties are by default, symbols)
                  (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  |
                  (?:# Regular variables
                  (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  )\b
                captures:
                  1: {name: variable.other.global.so}
                  2: {name: variable.other.constant.object.so}
                  3: {name: variable.other.conditional.so}
                  4: {name: variable.other.object.so}
                  5: {name: entity.name.tag.so}
                  6: {name: entity.name.tag.so support.class.component.so}
                  7: {name: entity.name.class.builtin.so}
                  8: {name: entity.name.function.method.so}
                  9: {name: entity.name.function.tagged-template.so}
                  10: {name: entity.name.type.so}
                  11: {name: entity.name.class.so}
                  12: {name: entity.name.function.so}
              - *transfix-operators

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.so}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.so}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.so}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.so
              - include: $self

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
      \b(?:# don't match keywords
      in|of|new|unset|length|delete|to|til|thru|at|by
      |n?and|x?n?or|not|parallel|series|spawn|discard
      |func?|function|proc|process|macro
      |let|var|val|const|declare
      |class|given|constraint|enum|relation|lattice
      |project|attribute|protocol|member|extend|fragment|interface|struct
      |module|package|namespace|object|record|label
      |raw|data|query|schema|style|component|element|trait|friend|alias|type
      |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
      |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |import|export|show|hide|open|close
      |from|where|join|equals?|[io]nto|order
      |take|drop|fold|scan|select|group|use|using
      )\b
      )
      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
      |
      (?:# Regular variables
      (_+[\p{Pc}\p{L}]\w*(?!_+)|[\p{Pc}\p{L}][\w&&[^_]]*_+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.so}
      2: {name: entity.name.tag.so}
      3: {name: entity.name.namespace.so}
      4: {name: entity.name.interface.so}
      5: {name: entity.name.tag.block.so}
      6: {name: entity.name.tag.script.so}
      7: {name: entity.name.tag.style.so}
      8: {name: entity.name.tag.inline.so}
      9: {name: entity.name.label.so}
      10: {name: entity.name.project.so}
      11: {name: entity.name.class.so}
      12: {name: entity.name.type.so}

  type-brackets:
    patterns:
      - include: "#code-block"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.so
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.so
              - match: (?<=^|[({\[])\s*([*+-](?:\s+[*+-])*)
                name: punctuation.definition.block.sequence.item.so

        patterns:
          - begin: (?<=(?::|:?=|->)\s+|[({\[]\s*|\b(?:var|let|const)\b\s*)(\{\|)\s*
            end: \s*(\|\})
            captures:
              1: {name: punctuation.definition.mapping.so}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: (?<=(?::|:?=|->)\s+|[({\[]\s*|\b(?:var|let|const)\b\s*)(\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.so}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.so
        patterns:
          - begin: \s*(\(\|)
            end: \s*(\|\))
            captures:
              1: {name: punctuation.definition.parameters.so}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<=\b|^|[)}\]'"`\\\s])(:)(?=\b|$|[({\['"`\\\s])
                captures:
                  1: {name: punctuation.separator.slice.so}
              - match: ","
                name: punctuation.separator.sequence.so
        patterns:
          - begin: \s*(\[<)
            end: \s*(>\])
            captures:
              1: {name: punctuation.definition.typeparameters.so}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[\|)
            end: \s*(\|\])
            captures:
              1: {name: punctuation.definition.sequence.so}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.so}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(extends|implements)\b\s*
        name: storage.type.$1.so
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(typeof|nameof|sizeof|keyof|valueof|pairof|infer|as|is)\b\s*
        name: keyword.operator.expression.$1.so

  type-operators:
    patterns:
      - comment: transfix binary operators
        match: |
          (?x)(?<=^|[)}\]\w'"`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[({\[\w'"`])
        captures:
          1: {name: punctuation.accessor.optional.so}
          2: {name: punctuation.accessor.cascade.so}
          3: {name: punctuation.accessor.call.so}
          4: {name: punctuation.accessor.so}
          5: {name: punctuation.accessor.module.so}

      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.so}
          2: {name: keyword.operator.difference.so}
          3: {name: keyword.operator.product.so}
          4: {name: keyword.operator.quotient.so}
          5: {name: keyword.operator.remainder.so}
          6: {name: keyword.operator.only.so}
          7: {name: keyword.operator.maybe.so}
          8: {name: keyword.operator.intersection.so}
          9: {name: keyword.operator.union.so}
          10: {name: keyword.operator.symmetric.so}
          11: {name: keyword.operator.negation.so}
          12: {name: keyword.operator.macro.dollar.so}
          13: {name: keyword.operator.private.so}
          14: {name: keyword.operator.class.so}

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=\O)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.so}
    patterns:
      - include: "#types"

  types:
    patterns:
      - match: \s*(==?>|-->|~~?>)
        name: keyword.operator.type.function.so
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.so
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#modifier-keywords"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#literals"

  modifier-keywords:
    match: |
      (?x)
      ((?:
      \s*(?:
      (?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:# Access modifiers
      public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
      |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
      # Function or method modifiers
      |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
      |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
      |# Function or method modifiers
      (?:pre|in|post|suf|af|trans|interface)fix|
      (?:u|bi|ter|)nary|oper
      |# Decorators
      @(?:
      [\p{Pc}\p{L}]\w*
      (?:(?:[?!]?\.|[?!:]:|->)
      (?:(?:[\p{Pc}\p{L}]\w*)))*
      )
      )
      )
      \s*)*)
      (?=\s*\b
      (?:
      class|extend
      |given|constraint
      |enum|relation
      |fragment|struct
      |func?|function|proc|process|macro
      |interface|schema
      |module|package
      |namespace|lattice
      |object|record
      |protocol|member
      |project|attribute
      |raw
      |data|query
      |style|component|element
      |trait|friend
      )\b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - match: |
              (?x)\s*@(?:
              [\p{Pc}\p{L}]\w*
              (?:(?:[?!]?\.|[?!:]:|->)
              (?:(?:[\p{Pc}\p{L}]\w*)))*
              )\s*
            name: entity.name.class.decorator.so
          - match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              )|
              (# Function or method modifiers
              [gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
              )|
              (# Property modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              )
              )\b\s*
            captures:
              1: {name: storage.modifier.so}
              2: {name: storage.type.accessor.so}
              3: {name: storage.type.property.so}

  support:
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties
      - include: source.swift#builtin-types
      - include: source.swift#builtin-functions

      - comment: JavaScript
      - include: source.js#support-objects
      - include: "#support-js"

      - comment: Python
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
      - include: source.python#magic-variable-names

      - comment: PHP
      - include: source.php#support
      - include: source.php#class-builtin
      - include: "#support-php"

      - comment: Other

  declaration-keywords:
    comment: clause keywords
    match: |
      (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:
      (func?|function|proc|process|macro)# function
      |(let|va[rl]|const)# variable
      |(class|extend)# class
      |(given|constraint)# constraint
      |(enum|relation)# enumeration
      |(project|attribute)# project
      |(fragment|struct)# fragment
      |(interface|schema)# interface
      |(module|package)# module
      |(namespace|lattice)# function
      |(object|record)# object
      |(raw)# markup
      |(data|query)# indented GraphQL
      |(style|component|element)# inline CSS
      |(trait|friend)# trait
      |(type|alias)# type alias
      |(declare)# declaration
      )\b\s*
    captures:
      1: {name: storage.type.function.so}
      2: {name: storage.type.so}
      3: {name: storage.type.class.so}
      4: {name: storage.type.constraint.so}
      5: {name: storage.type.enum.so}
      6: {name: storage.type.project.so}
      7: {name: storage.type.fragment.so}
      8: {name: storage.type.interface.so}
      9: {name: storage.type.module.so}
      10: {name: storage.type.namespace.so}
      11: {name: storage.type.object.so}
      12: {name: storage.type.raw.so}
      13: {name: storage.type.schema.so}
      14: {name: storage.type.style.so}
      15: {name: storage.type.trait.so}
      16: {name: keyword.other.typedef.so}
      17: {name: keyword.other.declare.so}

  general-keywords:
    comment: general keywords
    match: |
      (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:
      (if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard)#1
      |(for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat)#2
      |(switch|case|fail|default|fallthru)#3
      |(match|when|pass)#4
      |(try|retry|throw|raise|catch|rescue|finally)#5
      |(with)#6
      |(ref|[dr]efer|show|hide|enter|exit)#7
      |(then)#8
      |(debug|check|assert)#9
      |(break|continue|halt|skip|return|give|label|await|yield|throw|raise|yield\b\s+\bfrom)# 10
      |((?:im|ex)port|show|hide)# 11
      |(parallel|series|spawn|discard)#12
      |(do|redo)#13
      |(begin|end)#14
      )\b\s*
    captures:
      1: {name: keyword.control.conditional.so}
      2: {name: keyword.control.loop.so}
      3: {name: keyword.control.switch.so}
      4: {name: keyword.control.match.so}
      5: {name: keyword.control.error.so}
      6: {name: keyword.control.with.so}
      7: {name: keyword.control.so}
      8: {name: keyword.control.then.so}
      9: {name: keyword.other.$10.so}
      10: {name: keyword.control.flow.so}
      11: {name: keyword.control.module.so}
      12: {name: keyword.control.thread.so}
      13: {name: keyword.control.do.so}
      14: {name: keyword.control.$14.so}

  expression-keywords:
    comment: expression keywords
    match: |
      (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(?:
      (in|of|as|is|new|infer
      |typeof|nameof|sizeof|keyof|pairof|valueof)
      |(length)|(delete)|(to|til|thru|at|by)|(unset)
      |(n?and|x?n?or|not)
      )\b\s*
    captures:
      1: {name: keyword.operator.expression.$1.so}
      2: {name: keyword.operator.expression.length.so}
      3: {name: keyword.operator.expression.delete.so}
      4: {name: keyword.operator.expression.range.so}
      5: {name: keyword.operator.expression.void.so}
      6: {name: keyword.operator.expression.logical.so}

  keywords:
    patterns:
      - include: "#sql-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(let|va[rl]|const)\b\s*
        name: storage.type.so
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(declare)\b\s*
        name: keyword.other.$1.so
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      sql-expression:
        patterns:
          - captures:
              1: {name: keyword.other.create.so}
              2: {name: keyword.other.table.so}
              5: {name: entity.name.function.so}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(create(?:\s+or\s+replace)?|replace)\s+(aggregate|conversion|database|domain|function|group|(unique\s+)?index|language|operator
              class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)(['"`]?)(\w+)\4
            name: meta.create.so
          - captures:
              1: {name: keyword.other.drop.so}
              2: {name: keyword.other.table.so}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(drop|delete)\s+(aggregate|conversion|database|domain|function|group|index|language|operator
              class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view))
            name: meta.drop.so
          - captures:
              1: {name: keyword.other.drop.so}
              2: {name: keyword.other.table.so}
              3: {name: entity.name.function.so}
              4: {name: keyword.other.cascade.so}
            match: (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(drop|delete)\s+(table)\s+(\w+)(\s+cascade)?\b)
            name: meta.drop.so
          - captures:
              1: {name: keyword.other.alter.so}
              2: {name: keyword.other.table.so}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(alter|update)\s+(aggregate|conversion|database|domain|function|group|index|language|operator
              class|operator|proc(edure)?|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)
            name: meta.alter.so

      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(halt|skip|break|continue|goto|label)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.flow.so}
        patterns:
          - match: \s*([\p{Pc}\p{L}]\w*)\s*
            name: constant.other.label.so

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(import|export|open|close|use|using)\b\s*
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.module.so}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(from|to|as|all|any|show|hide|to|n?and|x?n?or|not)\b\s*
                name: keyword.control.module.so
              - match: \s*\*
                name: keyword.operator.module.all.so
              - include: "#modifier-keywords"
              - include: "#declaration-keywords"
              - include: "#type-keywords"
              - match: *entity-name
                name: variable.other.readwrite.alias.so
              - include: "#strings-unquoted"
              - include: "#strings-quoted"
              - include: "#operators"
              - include: "#punctuation"
              - include: source.yaml#flow-collection

      query-expression:
        patterns:
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(from)\b\s*
            end: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.so}
            patterns:
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.so
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(group)\b\s*
            end: \s*\b(by)\b\s*
            captures:
              1: {name: keyword.query.so}
            patterns:
              - include: $self
          - begin: (?x)\s*\b(join)\b\s*
            end: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.so}
            patterns:
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(equals?|[io]nto)\b\s*
            name: keyword.query.so
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b((\b(order)\b)\s*(\b((a|de)sc)\b)?\s*(\b(by)\b)?)\b\s*
            name: keyword.query.so
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(select)\b\s*
            name: keyword.query.so
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.so
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(where)\b\s*
            name: keyword.query.so

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.so}
    patterns: &function-params
      - include: "#clauses"
      - include: "#keywords"
      - match: (?i)\s*\?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.so
      - match: (?i)\s*\*[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.so
      - match: (?i)\s*[&~][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.so
      - match: (?i)\s*\%[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.so
      - match: (?i)\s*\$[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.so
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.so
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#definition-keywords"
      - include: "#code-block"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.so
      - include: "#operators"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]))
        end: (?=\O)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.so}
        patterns:
          - include: "#types"

  declarations:
    patterns:
      - include: "#function"
      - include: "#raw"
      - include: "#schema"
      - include: "#style"
      - include: "#class"
      - include: "#enum"
      - include: "#interface"
      - include: "#trait"
      - include: "#fragment"
      - include: "#module"
      - include: "#namespace"
      - include: "#object"
      - include: "#constraint"
      - include: "#project"
      - include: "#protocol"

    repository:
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(class|extend)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.class.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.so
      constraint:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(given|constraint)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.constraint.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.constraint.so
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(enum|relation)\b\s*
        end: (?<=})|(?=\O)|$
        name: meta.enum.declaration.so
        beginCaptures:
          1: {name: storage.type.enum.so}
          2: {name: entity.name.enum.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.so
      fragment:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(fragment|struct)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.fragment.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.fragment.so
      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(func?|function|proc|process|macro)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.function.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.so
      interface:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(interface|schema)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.interface.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.interface.so
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(module|package)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.module.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.so
      namespace:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(namespace|lattice)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.namespace.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.namespace.so
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(object|record)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.object.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.so
      protocol:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(protocol|member)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.protocol.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.protocol.so
      project:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(project|attribute)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.protocol.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.project.so
      raw:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(raw)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.raw.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.raw.so
      schema:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(data|query)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.schema.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.schema.so
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(style|component|element)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.style.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.so
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(trait|friend)\b\s*
        end: (?<=})|(?=\O)|$
        beginCaptures:
          1: {name: storage.type.trait.so}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.so

  clauses:
    patterns:
      - include: "#arguments-clause"
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      arguments-clause:
        patterns:
          - begin: |
              (?x)
              (?<=(?:[({\[]\|?|\b(?:#keywords
              (?:re)?do|equals?|[io]nto|select|where|when|case
              |(?:\b(?:fold|scan)\b)\s*(?:\b(?:left|right)\b)?\s*(?:\b(?:by|while|until|with)\b)?
              |(?:\b(?:take|drop)\b)\s*(?:\b(?:left|right|init|head|tail|last)\b)?\s*(?:\b(?:by|while|until|with)\b)?
              )\b)\s*)
              (\|)
              (?!\|)
            captures:
              1: {name: punctuation.separator.arguments.so}
            end: (?<!\|)(\|)(?!\|)
            patterns:
              - include: "#function-params"

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.so}
        patterns:
          - include: "#function-params"

      method-clause:
        patterns:
          - begin: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              (
              (?:(?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [\p{Pc}\p{L}]\w*
              (?:(?:[?!]?\.|[?!:]:|->)
              (?:(?:[\p{Pc}\p{L}]\w*)))*
              )
              )\s*\b)*
              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.method.so}
              2: {name: keyword.operator.assignment.so}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.so}
            endCaptures:
              1: {name: punctuation.separator.arguments.so}
            patterns:
              - include: "#function-params"
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              ((?:
              \s*(?:
              (?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [\p{Pc}\p{L}]\w*
              (?:(?:[?!]?\.|[?!:]:|->)
              (?:(?:[\p{Pc}\p{L}]\w*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              func?|function|proc|process|macro
              )\b
              )
            captures:
              1: {name: entity.name.function.method.so}
              2: {name: keyword.operator.assignment.so}
              3: {patterns: *modifier-keywords}

      function-clause:
        patterns:
          - begin: |
              (?x)\s*
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              (
              (?:(?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [\p{Pc}\p{L}]\w*
              (?:(?:[?!]?\.|[?!:]:|->)
              (?:(?:[\p{Pc}\p{L}]\w*)))*
              )
              )\s*\b)*
              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.so}
              2: {name: keyword.operator.assignment.so}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.so}
            endCaptures:
              1: {name: punctuation.separator.arguments.so}
            patterns:
              - include: "#function-params"
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              ((?:
              \s*(?:
              (?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound|sealed)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [\p{Pc}\p{L}]\w*
              (?:(?:[?!]?\.|[?!:]:|->)
              (?:(?:[\p{Pc}\p{L}]\w*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              func?|function|proc|process|macro
              )\b
              )
            captures:
              1: {name: entity.name.function.so}
              2: {name: keyword.operator.assignment.so}
              3: {patterns: *modifier-keywords}

      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(new)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.so}
        patterns:
          - match: \s*([\p{Pc}\p{L}]\w*)
            name: entity.name.instance.so
          - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.so}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(type|alias)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.typedef.so}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.so}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b((?:return|give|await|yield|throw|raise)s)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.modifier.so}
            patterns:
              - include: "#types"

      case-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(case|fail|default)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        beginCaptures:
          1: {name: keyword.control.switch.so}
        patterns:
          - include: "#code-block"
          - include: $self

      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(try|retry|catch|rescue|finally)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.catch.so
        beginCaptures:
          1: {name: keyword.control.error.so}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.error.so
              - include: "#code-block"
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.error.so
          - include: "#code-block"
          - include: $self

      thread-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(parallel|series|spawn|discard|fixed|lock)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.thread.so
        beginCaptures:
          1: {name: keyword.control.thread.so}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.thread.so
              - include: "#code-block"
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.thread.so
          - include: "#code-block"
          - include: $self

      do-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(do|redo)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.do.so
        beginCaptures:
          1: {name: keyword.control.do.so}
        patterns:
          - include: "#code-block"
          - include: $self

      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.for.so
        beginCaptures:
          1: {name: keyword.control.loop.so}
        patterns:
          - &for-clause-keywords
            match: \s*\b(in|of|to|til|thru|at|by)\b
            name: keyword.control.loop.so
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - *for-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.if.so
        beginCaptures:
          1: {name: keyword.control.conditional.so}
        patterns:
          - include: "#code-block"
          - include: $self

      match-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(match)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.match.so
        beginCaptures:
          1: {name: keyword.control.match.so}
        patterns:
          - include: "#code-block"
          - include: $self

      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(switch)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.switch.so
        beginCaptures:
          1: {name: keyword.control.switch.so}
        patterns:
          - include: "#code-block"
          - include: $self

      when-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(when)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        beginCaptures:
          1: {name: keyword.control.match.so}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - include: "#type-operators"
              - include: "#code-block"
              - include: $self
          - include: "#type-operators"
          - include: "#code-block"
          - include: $self

      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\b(with)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|(?<!(?:(?<!\.)\.|[?!:]:)=?|->)\bthen\b)|$)
        name: meta.with.so
        beginCaptures:
          1: {name: keyword.control.with.so}
        patterns:
          - &with-clause-keywords
            match: \s*\b(as)\b
            name: keyword.control.with.so
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.so}
            patterns:
              - *with-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#semicolon"
      - include: "#double-semi"

    repository:
      line-continuation:
        match: (\\)\s*(?=/[/*+]|$)
        captures:
          1: {name: punctuation.separator.continuation.line.so}
      comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.separator.comma.so}
      right-arrow:
        match: (?:^|['"`\\({\[\s]*)(->)(?:$|['"`\\\s)}\]])
        captures:
          1: {name: punctuation.definition.arrow.so}
      double-semi:
        match: \s*(;;)
        captures:
          1: {name: punctuation.terminator.statement.so}
      semicolon:
        match: \s*(;)(?!;)
        captures:
          1: {name: punctuation.terminator.expression.so}

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#code-block"
      - include: "#square-brackets"
      - include: "#round-brackets"

  code-block:
    patterns:
      - begin: (\{\|)\s*
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.function.so}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.so}
        patterns:
          - include: $self

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.so
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.so
          - match: (?<=^|[({\[])\s*([*+-](?:\s+[*+-])*)
            name: punctuation.definition.block.sequence.item.so

    patterns:
      - begin: (?<=(?::|:?=|->)\s+|[({\[]\s*|\b(?:var|let|const)\b\s*)(\{\|)\s*
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.mapping.so}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (?<=(?::|:?=|->)\s+|[({\[]\s*|\b(?:var|let|const)\b\s*)(\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.so}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.so

    patterns:
      - begin: (\(\|)\s*
        end: \s*(\|\))
        captures:
          1: {name: punctuation.definition.parameters.so}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.so}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<=\b|^|[)}\]'"`\\\s])(:)(?=\b|$|[({\['"`\\\s])
            captures:
              1: {name: punctuation.separator.slice.so}
          - match: ","
            name: punctuation.separator.sequence.so

    patterns:
      - begin: (\[<)\s*
        end: \s*(>\])
        captures:
          1: {name: punctuation.definition.typeparameters.so}
        patterns:
          - include: "#types"
          - include: $self
      - begin: (\[\|)\s*
        end: \s*(\|\])
        captures:
          1: {name: punctuation.definition.sequence.so}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.so}
        patterns:
          - include: "#punctuation"
          - include: $self

  support-js:
    patterns:
      - begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<=\.)\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.mutator.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.error.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(debugger)\b
        captures:
          1: {name: keyword.other.js}
      - match: (?<!\.)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.js}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.js}
      - begin: (?<!\.)\s*+\b(Console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.console.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.console.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(Process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.process.js}
      - begin: (?<!\.)\s*+\b(Process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.process.js}
        patterns:
          - include: "#round-brackets"
      - match: (((?<!\.)\s*+\bModule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.module.js}
      - match: (?<!\.)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.js}
      - begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.node.js}
        patterns:
          - include: "#round-brackets"

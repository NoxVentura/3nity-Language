{
  "name": "Trinity",
  "scopeName": "source.coffee",
  "fileTypes": [
    "coffee",
    "3n",
    "trin"
  ],
  "patterns": [
    {
      "include": "#core"
    }
  ],
  "information for contributors": "This is the grammar for the Trinity programming language. It is primarily\nbased on Ruby, Python, Haskell and ML, but is intended for building cross-\nplatform apps and software with the web.\n\nThe grammar is nearing completion but needs to be thoroughly refactored\nand reorganized. There also are some bugfixes which are on the verge of\nbeing performed.\n\nShould any fix or improvements have to be made, or even some general\nconstructive feedback, make a pull request or an issue on this repo,\nand I will be very happy to receive it/them.\n",
  "fixes": "Changes in 2022:\n\n- Added back backslash strings.\n- Removed JSX and style blocks, replaced them with indentation.\n- Comments have been standardized into C/Swift-style comments.\n  - // line comment\n  - /* block comment */\n  - /// doc line comment\n  - /** doc block comment */\n- Added '/' (full) and '//' (shorthand) command flags\n- Numbers and escape sequences have been reworked; bases 4, 6, and 12\n  have been scrapped.\n- Interpolation and formatting syntax have been reworked and fixed.\n  Spacing around identifiers have also been removed.\n- Function call syntax has been reworked and is still sometimes buggy.\n  Still some improvements have to be made.\n- Removed '\\' from valid operator characters.\n- Added/removed a few more keywords: use, show, hide;\n  removed import, export, var, val, let, const;\n  shortened some to three or four letters:\n    'struct' -> 'inter', 'module' -> 'mod', 'markup' -> 'mark', 'object' -> 'obj'\n- Fixed regular expression highlighting:\n  - Added and expanded quantifiers and range highlighting\n  - Add support for fuzzy matching (edits, insertions, deletions, etc.)\n\nFixes:\n\n- Match unquoted glob patterns in routes without quotes\n- Fix type strings and symbol-quoted strings to match properly\n- Add new keywords to end blocks:\n  - if/elif then else fi\n  - for/loop/while do done\n  - match with exit\n  - case then ouse esac\n  - try catch after yrt\n  - with away\n  - do done\n- Percent literals inspired by Ruby (this time using dollar signs as the\n  percent sign is used for string formatting).\n- Grammar is a bit messy at the moment, so adding comments to some regexes\n  would help a lot. I'll be fixing this soon.\n- Rewrite complex regular expressions and add some comments to make them more\n  readable and less confusing.\n  - [x] Markdown syntax\n  - [x] function parameters\n  - [x] function calls\n  - [ ] identifiers and variables\n  - [x] operators\n  - [ ] object literals\n  - [ ] object labels\n  - [x] pipeline functions\n  - [ ] modifier keywords\n  - [ ] function assignments\n  - [x] anonymous functions\n  - [ ] embedded content\n- Add some more Markdown syntax:\n  - Citations\n  - Strike-through\n  - Deleted and inserted text\n  - Superscript\n  - Subscript\n  - Citation\n  - Spans\n  - Selectors and anchors\n  - Code blocks\n  - Definition blocks\n  - Tables\n  - Headings and subheadings\n- Unify function call variables to 9 groups instead of 12:\n  - Objects, properties and variables\n  - UPPERCASE, PascalCase and camelCase\n",
  "define": {
    "class-name": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
    "entity-name": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
    "parameter-brackets": {
      "begin": "\\s*(\\()",
      "end": "\\s*(\\))",
      "captures": {
        "1": {
          "name": "punctuation.definition.parameters.trin"
        }
      },
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.as.trin"
        },
        {
          "match": "(?<=[\\w\\s][(|])\\.",
          "name": "punctuation.definition.metadata.trin"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#constants"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#expression-keywords"
        },
        {
          "include": "#function-params"
        },
        {
          "include": "$self"
        }
      ]
    },
    "html-tag-names": [
      {
        "match": "\\.|:|::",
        "name": "punctuation.separator.namespace.trin"
      },
      {
        "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[:.])",
        "name": "entity.name.tag.namespace.trin"
      },
      {
        "match": "\\b((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\\b",
        "name": "support.class.component.trin"
      },
      {
        "include": "#clauses"
      },
      {
        "include": "#declarations"
      },
      {
        "include": "#keywords"
      },
      {
        "include": "#html-tag-names"
      }
    ]
  },
  "repository": {
    "core": {
      "patterns": [
        {
          "include": "#ignore-long-lines"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#jsx"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#closures"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#keywords"
        },
        {
          "include": "#punctuation"
        },
        {
          "include": "#symbols"
        },
        {
          "include": "#flag-specifier"
        },
        {
          "include": "#format-specifier"
        },
        {
          "include": "#type-annotation"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#operators"
        },
        {
          "include": "#calls"
        },
        {
          "include": "#variables"
        },
        {
          "include": "#illegal"
        },
        {
          "include": "#space"
        }
      ]
    },
    "ignore-long-lines": {
      "comment": "avoid parsing files with long lines of code",
      "match": "^.{1024,}$"
    },
    "space": {
      "match": "\\s+",
      "name": "meta.var.expr.trin"
    },
    "function-params": {
      "patterns": [
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  \\? # optional\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n  \\s*\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.optional.trin"
        },
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  \\* # spread\n  \\?? # optional\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.spread.trin"
        },
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  //? # named\n  \\?? # optional\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.name.trin"
        },
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  \\& # reference\n  \\?? # optional\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.reference.trin"
        },
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  \\% # other\n  \\?? # optional\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.other.trin"
        },
        {
          "match": "(?x)\n(?<=\n  ^ # SOL\n  | (?:^ | [^|]) \\| # open pipe\n  | [({\\[] # open bracket\n  | [;,] # separator\n  | [(|]\\. \\s # uncurried function\n  | (?:^ | \\s) \\b as \\b \\s # as keyword\n)\n  \\s*\n  \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n(?=\n  $ # EOL\n  | # close bracket or pipe\n    \\s* [)}\\]] | \\s* \\|:? [\\w\\s'\"`\\\\({\\[]\n  | # separator\n    \\s* [;,]\n  | # as keyword (aliasing)\n    \\s+ \\b as \\b \\s\n  | # type specifier and assignment\n    (?::|[?:]?=) \\s* [\\w'\"`\\\\({\\[]\n  | \\s+ (?::|[?:]?=) \\s+ [\\w'\"`\\\\({\\[]\n)\n",
          "name": "variable.parameter.trin"
        }
      ]
    },
    "parameter-brackets": {
      "begin": "(\\()\\s*",
      "end": "\\s*(\\))",
      "captures": {
        "1": {
          "name": "punctuation.definition.parameters.trin"
        }
      },
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.as.trin"
        },
        {
          "match": "(?<=[\\w\\s][(|])\\.",
          "name": "punctuation.definition.metadata.trin"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#constants"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#expression-keywords"
        },
        {
          "include": "#function-params"
        },
        {
          "include": "$self"
        }
      ]
    },
    "illegal": {
      "patterns": [
        {
          "match": "\\p{N}[\\w.+-/\\\\]*?",
          "name": "invalid.illegal.number.trin"
        },
        {
          "match": "[\\w]+?",
          "name": "invalid.illegal.variable.trin"
        },
        {
          "match": "[(){}\\[\\]]+?",
          "name": "invalid.illegal.missing-bracket.trin"
        },
        {
          "match": "[\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+",
          "name": "invalid.illegal.operator.trin"
        },
        {
          "match": "\\S+?",
          "name": "invalid.illegal.uncaught.trin"
        }
      ]
    },
    "literals": {
      "patterns": [
        {
          "include": "#regexps"
        },
        {
          "include": "#strings-unquoted"
        },
        {
          "include": "#strings"
        },
        {
          "include": "#numbers"
        },
        {
          "include": "#constants"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "match": "(?x)\n(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n(?:\n  (true|false) # boolean\n  |(null|nan) # null, NaN\n  |(void) # undefined\n  |(infin) # infinity\n)\n(?!\\B|\\p{Pd}+\\b)\n",
          "captures": {
            "1": {
              "name": "constant.language.boolean.$1.trin"
            },
            "2": {
              "name": "constant.language.$2.trin"
            },
            "3": {
              "name": "constant.language.undefined.trin"
            },
            "4": {
              "name": "constant.language.infinity.trin"
            }
          }
        },
        {
          "match": "(?x)\n(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n(?:\n  (it|this|that|self) # special arguments\n  |(args) # arguments\n  |(ctor) # constructor\n  |(proto) # prototype\n)\n(?!\\B|\\p{Pd}+\\b)\n",
          "captures": {
            "1": {
              "name": "variable.language.$1.trin"
            },
            "2": {
              "name": "variable.language.arguments.trin"
            },
            "3": {
              "name": "variable.language.constructor.trin"
            },
            "4": {
              "name": "variable.language.prototype.trin"
            }
          }
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "comment": "hexadecimal integers",
          "name": "constant.numeric.hexadecimal.trin",
          "match": "(?x) \\b\n  (0x) # prefix\n  \\h [\\h_]* # integer part\n  (\\.)? # decimal point\n  [\\h_]* # fractional part\n  (?: # exponent part\n    (p) # delimiter\n    ([+-])? # sign\n    ([\\d_]+) # mantissa\n  )?\n  ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)? # type suffix\n\\b\n",
          "captures": {
            "1": {
              "name": "storage.type.numeric.trin"
            },
            "2": {
              "name": "keyword.other.unit.trin"
            },
            "3": {
              "name": "keyword.operator.expression.exponent.trin"
            },
            "4": {
              "name": "keyword.operator.exponent.sign.trin"
            },
            "5": {
              "name": "constant.numeric.decimal.exponent.mantissa.trin"
            },
            "6": {
              "name": "keyword.other.unit.trin"
            }
          }
        },
        {
          "comment": "octal integers",
          "name": "constant.numeric.octal.trin",
          "match": "(?x) \\b\n  (0o) # prefix\n  [0-7] [0-7_]* # integer part\n  (\\.)? # decimal point\n  [0-7_]* # fractional part\n  (?: # exponent part\n    (p) # delimiter\n    ([+-])? # sign\n    ([\\d_]+) # mantissa\n  )?\n  ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)? # type suffix\n\\b\n",
          "captures": {
            "1": {
              "name": "storage.type.numeric.trin"
            },
            "2": {
              "name": "keyword.other.unit.trin"
            },
            "3": {
              "name": "keyword.operator.expression.exponent.trin"
            },
            "4": {
              "name": "keyword.operator.exponent.sign.trin"
            },
            "5": {
              "name": "constant.numeric.decimal.exponent.mantissa.trin"
            },
            "6": {
              "name": "keyword.other.unit.trin"
            }
          }
        },
        {
          "comment": "binary 0b",
          "name": "constant.numeric.binary.trin",
          "match": "(?x) \\b\n  (0b) # prefix\n  [01] [01_]* # integer part\n  (\\.)? # decimal point\n  [01_]* # fractional part\n  (?: # exponent part\n    (p) # delimiter\n    ([+-])? # sign\n    ([\\d_]+) # mantissa\n  )?\n  ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)? # type suffix\n\\b\n",
          "captures": {
            "1": {
              "name": "storage.type.numeric.trin"
            },
            "2": {
              "name": "keyword.other.unit.trin"
            },
            "3": {
              "name": "keyword.operator.expression.exponent.trin"
            },
            "4": {
              "name": "keyword.operator.exponent.sign.trin"
            },
            "5": {
              "name": "constant.numeric.decimal.exponent.mantissa.trin"
            },
            "6": {
              "name": "keyword.other.unit.trin"
            }
          }
        },
        {
          "comment": "decimal (no prefix)",
          "name": "constant.numeric.decimal.trin",
          "match": "(?x) \\b\n  () # prefix\n  \\d [\\d_]* # integer part\n  (\\.)? # decimal point\n  [\\d_]* # fractional part\n  (?: # exponent part\n    (e) # delimiter\n    ([+-])? # sign\n    ([\\d_]+) # mantissa\n  )?\n  ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)? # type suffix\n\\b\n",
          "captures": {
            "1": {
              "name": "storage.type.numeric.trin"
            },
            "2": {
              "name": "keyword.other.unit.trin"
            },
            "3": {
              "name": "keyword.operator.expression.exponent.trin"
            },
            "4": {
              "name": "keyword.operator.exponent.sign.trin"
            },
            "5": {
              "name": "constant.numeric.decimal.exponent.mantissa.trin"
            },
            "6": {
              "name": "keyword.other.unit.trin"
            }
          }
        }
      ]
    },
    "symbols": {
      "patterns": [
        {
          "match": "\\@[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?:(?:\\.|::)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b)*\\s*",
          "name": "entity.name.class.decorator.trin"
        },
        {
          "match": "\\B(:)(?=['\"])",
          "name": "punctuation.definition.symbol.trin"
        },
        {
          "match": "\\B(:)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b)",
          "captures": {
            "1": {
              "name": "punctuation.definition.symbol.trin"
            },
            "2": {
              "name": "constant.other.symbol.trin"
            }
          }
        }
      ]
    },
    "strings-unquoted": {
      "comment": "Unquoted string",
      "applyEndPatternLast": true,
      "begin": "(\\\\)",
      "end": "(?=[\\p{Z}\\p{P}\\p{S}])|$",
      "name": "string.unquoted.trin",
      "captures": {
        "1": {
          "name": "punctuation.definition.string.trin"
        }
      },
      "patterns": [
        {
          "include": "#string-escapes"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "comment": "multi-single quoted string",
          "begin": "(?<!'+)\\s*('''+)\\s*",
          "contentName": "string.quoted.single.trin",
          "end": "\\s*((\\1)(?!'+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#embedded-verbatim"
            }
          ]
        },
        {
          "comment": "single quoted string",
          "begin": "(?<!'+)\\s*(')\\s*",
          "contentName": "string.quoted.single.trin",
          "end": "\\s*((\\1)(?!'+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "match": "''",
              "name": "constant.character.escape.trin"
            },
            {
              "include": "#embedded-verbatim"
            }
          ]
        },
        {
          "comment": "multi-double quoted string",
          "begin": "(?<!\"+)\\s*(\"\"\"+)\\s*",
          "contentName": "string.quoted.double.trin",
          "end": "\\s*((\\1)(?!\"+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "comment": "double quoted string",
          "begin": "(?<!\"+)\\s*(\")\\s*",
          "contentName": "string.quoted.double.trin",
          "end": "\\s*((\\1)(?!\"+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#string-content"
            }
          ]
        }
      ]
    },
    "string-content": {
      "patterns": [
        {
          "include": "#string-escapes"
        },
        {
          "include": "#embedded"
        }
      ]
    },
    "function-namespace": {
      "patterns": [
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[.:])",
          "name": "support entity.name.tag.namespace.trin"
        },
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
          "name": "support entity.name.function.member.trin"
        }
      ]
    },
    "character-namespace": {
      "patterns": [
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[.:])",
          "name": "constant.other.character-class.trin"
        },
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
          "name": "constant.character.escape.unicode.trin"
        }
      ]
    },
    "character-escapes": {
      "patterns": [
        {
          "applyEndPatternLast": true,
          "name": "constant.other.function.trin",
          "begin": "\\\\:([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b([:.][\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b(?=\\{)",
          "beginCaptures": {
            "1": {
              "patterns": [
                {
                  "include": "#function-namespace"
                }
              ]
            }
          },
          "end": "(?=)|$",
          "patterns": [
            {
              "begin": "(\\{)",
              "end": "(\\})",
              "captures": {
                "1": {
                  "name": "constant.other.function.trin"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            }
          ]
        },
        {
          "match": "\\\\:\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b([:.][\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b([;,]|(?=\\W))",
          "name": "constant.character.escape.trin",
          "captures": {
            "1": {
              "patterns": [
                {
                  "include": "#character-namespace"
                }
              ]
            }
          }
        }
      ]
    },
    "string-escapes": {
      "patterns": [
        {
          "match": "\\\\(?=\\s*$)",
          "name": "constant.character.escape.newline.trin"
        },
        {
          "include": "#character-escapes"
        },
        {
          "include": "#numeric-escapes"
        },
        {
          "match": "\\\\([cm][a-z])",
          "name": "constant.character.control.trin"
        },
        {
          "match": "\\\\[prntfvabe]",
          "name": "constant.character.escape.trin"
        },
        {
          "match": "\\\\[\\p{S}\\p{P}]",
          "name": "constant.character.escape.symbol.trin"
        },
        {
          "match": "\\\\\\p{Z}",
          "name": "constant.character.escape.other.trin"
        },
        {
          "match": "\\\\[\\p{L}\\p{N}\\p{C}]",
          "name": "invalid.deprecated.escape.trin"
        }
      ]
    },
    "numeric-escapes": {
      "patterns": [
        {
          "comment": "Binary escape sequences",
          "match": "\\\\b[01]+",
          "name": "constant.character.escape.binary.trin"
        },
        {
          "comment": "Binary escape sequences",
          "begin": "\\\\b{",
          "end": "\\s*}",
          "name": "constant.character.escape.binary.trin",
          "patterns": [
            {
              "match": "\\b[01]+\\b",
              "name": "constant.character.escape.binary.trin"
            },
            {
              "match": "\\w+",
              "name": "invalid.illegal.escape.trin"
            }
          ]
        },
        {
          "comment": "Octal escape sequences",
          "match": "\\\\o[0-7]+",
          "name": "constant.character.escape.octal.trin"
        },
        {
          "comment": "Octal escape sequences",
          "begin": "\\\\o{",
          "end": "\\s*}",
          "name": "constant.character.escape.octal.trin",
          "patterns": [
            {
              "match": "\\b[0-7]+\\b",
              "name": "constant.character.escape.octal.trin"
            },
            {
              "match": "\\w+",
              "name": "invalid.illegal.escape.trin"
            }
          ]
        },
        {
          "comment": "Decimal escape sequences",
          "match": "\\\\d?\\d+",
          "name": "constant.character.escape.decimal.trin"
        },
        {
          "comment": "Decimal escape sequences",
          "begin": "\\\\d{",
          "end": "\\s*}",
          "name": "constant.character.escape.decimal.trin",
          "patterns": [
            {
              "match": "\\b\\d+\\b",
              "name": "constant.character.escape.decimal.trin"
            },
            {
              "match": "\\w+",
              "name": "invalid.illegal.escape.trin"
            }
          ]
        },
        {
          "comment": "Hexadecimal escape sequences",
          "match": "\\\\[ux]\\h+",
          "name": "constant.character.escape.hexadecimal.trin"
        },
        {
          "comment": "Hexadecimal escape sequences",
          "begin": "\\\\[ux]{",
          "end": "\\s*}",
          "name": "constant.character.escape.hexadecimal.trin",
          "patterns": [
            {
              "match": "\\b\\h+\\b",
              "name": "constant.character.escape.hexadecimal.trin"
            },
            {
              "match": "\\w+",
              "name": "invalid.illegal.escape.trin"
            }
          ]
        }
      ]
    },
    "embedded": {
      "patterns": [
        {
          "include": "#format-specifier"
        },
        {
          "include": "#embedded-placeholder"
        },
        {
          "include": "#embedded-expression"
        }
      ]
    },
    "embedded-verbatim": {
      "patterns": [
        {
          "match": "([#$%])\\1",
          "name": "constant.character.escape.trin"
        },
        {
          "include": "#format-specifier"
        },
        {
          "include": "#embedded-placeholder"
        },
        {
          "include": "#embedded-expression"
        }
      ]
    },
    "embedded-expression": {
      "patterns": [
        {
          "comment": "Interpolated expression",
          "begin": "(\\${)\\s*",
          "end": "\\s*(})",
          "name": "entity.quasi.component.trin",
          "captures": {
            "1": {
              "name": "punctuation.section.embedded.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "Interpolated expression",
          "applyEndPatternLast": true,
          "begin": "(?x)\n(?<=^|\\\\.|[,;'\"`\\\\(){}\\[\\]\\w\\s]>?) # SOL or after a literal or space\n(\\$) # beginning of identifier\n# ignore all keywords\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\\b # next to a word\n",
          "end": "(?=)|$",
          "captures": {
            "1": {
              "name": "punctuation.section.embedded.trin"
            }
          },
          "patterns": [
            {
              "include": "#constants"
            },
            {
              "include": "#brackets"
            },
            {
              "include": "#embedded-calls"
            },
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "comment": "Primary binary operators",
              "match": "(?<=[)}\\]\\w])(?:(\\?[.:]=?)|(![.:]=?)|((?:::|\\.)=?))(?=[({\\[\\w])",
              "captures": {
                "1": {
                  "name": "keyword.operator.optional.trin"
                },
                "2": {
                  "name": "keyword.operator.assert.trin"
                },
                "3": {
                  "name": "keyword.operator.accessor.trin"
                }
              }
            }
          ]
        }
      ]
    },
    "embedded-placeholder": {
      "patterns": [
        {
          "match": "(?x)\n(\\#) # sigil\n(\n  \\?? \\*? # optional and spread\n  [+-]? \\d+ # start of range\n  (?:\n    (?:[>.]\\.[.<]|\\.\\.=?|=\\.=) # range operator\n    [+-]? \\d+ # end of range\n    (?:\n      \\.{1,3}\n      [+-]? \\d+ # increment\n    )?\n  )?\n)\n",
          "captures": {
            "1": {
              "name": "punctuation.definition.anchor.trin"
            },
            "2": {
              "name": "constant.numeric.decimal.trin",
              "patterns": [
                {
                  "match": "[+-]",
                  "name": "keyword.operator.arithmetic.trin"
                },
                {
                  "match": "(?:[>.]\\.[.<]|\\.\\.=?|=\\.=)",
                  "name": "keyword.operator.range.trin"
                }
              ]
            }
          }
        },
        {
          "match": "(?x)\n(\\#) # sigil\n(\n  (?:[*&%]\\??|//?\\??|\\?)\n  \\b\n  [\\p{Pc}\\p{L}][\\w\\p{Pd}]*\n  \\b\n  |\n  # ignore all keywords\n  (?!\n    (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n    (?: # keywords\n      in|of|as|is|new\n      |to|til|thru|by|del\n      |unset|ref|and|or|xor|not\n      |var|val|func?|proc|type\n      |class|data|enum|mod\n      |iter|macro|inter|obj\n      |trait|style|elem|prop|mark\n      |go|defer|do|from|where|with\n      |if|elif|else|then|def\n      |for|each|loop|while\n      |try|throw|catch|after\n      |match|case|pass|fail|goto\n      |break|next|redo|retry\n      |return|yield|await|label\n      |use|show|hide|route\n      |debug|assert|check\n    )\n    (?!\\B|\\p{Pd}+\\b)\n  )\n  \\b\n  [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # identifier\n  \\b\n)\n",
          "captures": {
            "1": {
              "name": "punctuation.definition.anchor.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#placeholder-variables"
                }
              ]
            }
          }
        },
        {
          "begin": "(\\#{)\\s*",
          "end": "\\s*(})",
          "name": "entity.quasi.component.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.anchor.trin"
            }
          },
          "patterns": [
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "flag-specifier": {
      "patterns": [
        {
          "comment": "// for multiple flags at once with single-character aliases",
          "applyEndPatternLast": true,
          "begin": "(?x)(?<=^|\\\\.|[,;'\"`\\\\(){}\\[\\]\\w\\s]>?)(//)\\b",
          "end": "(?=)|$",
          "captures": {
            "1": {
              "name": "punctuation.definition.flag.trin"
            }
          },
          "patterns": [
            {
              "comment": "Format switch without value",
              "match": "([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)",
              "captures": {
                "1": {
                  "name": "keyword.other.flag.trin"
                }
              }
            }
          ]
        },
        {
          "comment": "/ for a single flag, with optional arguments",
          "applyEndPatternLast": true,
          "begin": "(?x)(?<=^|\\\\.|[,;'\"`\\\\(){}\\[\\]\\w\\s]>?)(/)\\b",
          "end": "(?=)|$",
          "captures": {
            "1": {
              "name": "punctuation.definition.flag.trin"
            }
          },
          "patterns": [
            {
              "comment": "Format switch without value",
              "match": "([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)",
              "captures": {
                "1": {
                  "name": "keyword.modifier.trin"
                }
              }
            }
          ]
        }
      ]
    },
    "format-specifier": {
      "comment": "Oniguruma supports only 20 levels of recursion",
      "applyEndPatternLast": true,
      "begin": "(?x)(?<=^|\\\\.|[,;'\"`\\\\(){}\\[\\]\\w\\s]>?)(%)\\b",
      "end": "(?=)|$",
      "captures": {
        "1": {
          "name": "punctuation.definition.directive.trin"
        }
      },
      "patterns": [
        {
          "include": "#format-syntax"
        }
      ]
    },
    "format-syntax": {
      "comment": "Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.",
      "patterns": [
        {
          "comment": "initial format switch with value",
          "applyEndPatternLast": true,
          "begin": "(?<=%)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(:)",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.format.main.trin"
            },
            "2": {
              "name": "punctuation.separator.key-value.trin"
            }
          },
          "name": "entity.other.attribute-name.trin",
          "patterns": [
            {
              "include": "#constants"
            },
            {
              "include": "#embedded-calls"
            },
            {
              "include": "#variables"
            },
            {
              "include": "#brackets"
            },
            {
              "include": "#regexps"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#symbols"
            },
            {
              "comment": "Primary binary operators",
              "match": "(?<=[)}\\]\\w])(?:(\\?[.:]=?)|(![.:]=?)|((?:::|\\.)=?))(?=[({\\[\\w])",
              "captures": {
                "1": {
                  "name": "keyword.operator.optional.trin"
                },
                "2": {
                  "name": "keyword.operator.assert.trin"
                },
                "3": {
                  "name": "keyword.operator.accessor.trin"
                }
              }
            }
          ]
        },
        {
          "comment": "type specifier",
          "match": "(?<=%)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
          "name": "entity.other.attribute-name.trin",
          "captures": {
            "1": {
              "name": "storage.type.format.main.trin"
            }
          }
        },
        {
          "comment": "Format switch with value /x:24",
          "applyEndPatternLast": true,
          "begin": "(\\|)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(:)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.separator.mapping.trin"
            },
            "2": {
              "name": "storage.type.format.sub.trin"
            },
            "3": {
              "name": "punctuation.separator.key-value.trin"
            }
          },
          "end": "(?=)|$",
          "patterns": [
            {
              "include": "#constants"
            },
            {
              "include": "#embedded-calls"
            },
            {
              "include": "#variables"
            },
            {
              "include": "#brackets"
            },
            {
              "include": "#regexps"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#symbols"
            },
            {
              "comment": "Primary binary operators",
              "match": "(?<=[)}\\]\\w])(?:(\\?[.:]=?)|(![.:]=?)|((?:::|\\.)=?))(?=[({\\[\\w])",
              "captures": {
                "1": {
                  "name": "keyword.operator.optional.trin"
                },
                "2": {
                  "name": "keyword.operator.assert.trin"
                },
                "3": {
                  "name": "keyword.operator.accessor.trin"
                }
              }
            }
          ]
        },
        {
          "comment": "Format switch without value",
          "match": "(\\|)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)",
          "captures": {
            "1": {
              "name": "punctuation.separator.mapping.trin"
            },
            "2": {
              "name": "storage.type.format.sub.trin"
            }
          }
        }
      ]
    },
    "latex-sublanguage": {
      "name": "string.unquoted.plain.in.trin",
      "comment": "Grammar for the Unicode Named Character Mini-Language.",
      "patterns": [
        {
          "applyEndPatternLast": true,
          "name": "meta.function.math.trin",
          "begin": "(\\\\)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?:[:.][\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b(?=\\{)",
          "beginCaptures": {
            "1": {
              "name": "constant.other.function.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#function-namespace"
                }
              ]
            }
          },
          "end": "(?=)|$",
          "patterns": [
            {
              "begin": "(\\{)",
              "end": "(\\})",
              "captures": {
                "1": {
                  "name": "constant.other.function.trin"
                }
              },
              "patterns": [
                {
                  "include": "#latex-sublanguage"
                }
              ]
            }
          ]
        },
        {
          "match": "(\\\\)\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?:[:.][\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b",
          "captures": {
            "1": {
              "name": "constant.other.character.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#character-namespace"
                }
              ]
            }
          }
        },
        {
          "include": "#string-content"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#numbers"
        },
        {
          "include": "source.js#expression-operators"
        },
        {
          "include": "source.yaml#flow-collection"
        },
        {
          "match": "([^\\s\\\\(){}\\[\\]]+)",
          "name": "string.unquoted.plain.in.trin"
        }
      ]
    },
    "regexps": {
      "patterns": [
        {
          "comment": "Replacement section",
          "begin": "(?<=`+)\\s*(```+|`)",
          "end": "\\s*(?:(\\1)(?!`+))(\\p{Alnum}*)",
          "contentName": "string.replace.regexp.trin",
          "captures": {
            "1": {
              "name": "punctuation.section.regexp.end.trin"
            },
            "2": {
              "name": "keyword.other.flag.trin"
            }
          },
          "patterns": [
            {
              "include": "#back-references"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "comment": "Pattern section",
          "begin": "\\s*(\\p{Alnum}*)(?<!`+)(```+|`)",
          "end": "\\s*(?:(\\2)(?!`+))(\\p{Alnum}*)",
          "contentName": "string.pattern.regexp.trin",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.trin"
            },
            "2": {
              "name": "punctuation.section.regexp.begin.trin"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.section.regexp.end.trin"
            },
            "2": {
              "name": "keyword.other.flag.trin"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#regexp-patterns"
            }
          ]
        }
      ]
    },
    "fuzzy-expression": {
      "patterns": [
        {
          "include": "#punctuation"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#calls"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#embedded"
        },
        {
          "include": "#operators"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#keywords"
        },
        {
          "include": "#fuzzy-brackets"
        },
        {
          "match": "\\b[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b",
          "name": "keyword.other.unit.trin"
        },
        {
          "match": "\\s+",
          "name": "meta.space.trin"
        }
      ]
    },
    "fuzzy-brackets": {
      "patterns": [
        {
          "begin": "(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.mapping.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.mapping.trin"
            },
            {
              "include": "#labels"
            },
            {
              "include": "#fuzzy-expression"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.array.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            },
            {
              "include": "#fuzzy-expression"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.expression.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.arguments.trin"
            },
            {
              "include": "#fuzzy-expression"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "back-references": {
      "patterns": [
        {
          "match": "\\$(\\d+[+-]?|[+-]\\d*|&)",
          "name": "keyword.other.back-reference.trin"
        },
        {
          "begin": "(\\$<)\\s*",
          "end": "\\s*(>)",
          "name": "keyword.other.back-reference.trin",
          "captures": {
            "1": {
              "name": "keyword.other.back-reference.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "begin": "(\\$(['\"]))\\s*",
          "end": "\\s*(\\2)",
          "name": "keyword.other.back-reference.trin",
          "captures": {
            "1": {
              "name": "keyword.other.back-reference.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        }
      ]
    },
    "regexp-patterns": {
      "patterns": [
        {
          "match": "\\p{Z}+",
          "name": "meta.space.trin"
        },
        {
          "include": "#embedded"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#strings"
        },
        {
          "match": "\\|",
          "name": "keyword.operator.or.trin"
        },
        {
          "match": "\\&",
          "name": "keyword.operator.compose.trin"
        },
        {
          "match": "\\.",
          "name": "constant.character.all.trin"
        },
        {
          "match": "\\\\[bB](?:{(?:[^\\\\{}]|\\\\.)+})?",
          "name": "keyword.control.anchor.trin"
        },
        {
          "match": "\\$|\\\\[yYzZ](?:{(?:[^\\\\{}]|\\\\.)+})?",
          "name": "keyword.control.end.trin}"
        },
        {
          "match": "\\^|\\\\[AmM](?:{(?:[^\\\\{}]|\\\\.)+})?",
          "name": "keyword.control.begin.trin"
        },
        {
          "match": "\\\\K",
          "name": "keyword.control.keepout.trin"
        },
        {
          "match": "\\\\G",
          "name": "keyword.control.search.trin"
        },
        {
          "match": "\\\\R",
          "name": "constant.character.control.trin"
        },
        {
          "match": "\\\\[XO]",
          "name": "constant.character.unicode.trin"
        },
        {
          "match": "\\\\\\d+",
          "name": "keyword.other.back-reference.trin"
        },
        {
          "match": "\\{\\s*(?:\\d*\\s*,){,2}\\s*\\d*\\s*}\\s*(?:(\\?)|(\\+)|(\\*))?",
          "captures": {
            "0": {
              "name": "keyword.operator.quantifier.trin"
            },
            "1": {
              "name": "keyword.operator.modifier.lazy.trin"
            },
            "2": {
              "name": "keyword.operator.modifier.eager.trin"
            },
            "3": {
              "name": "keyword.operator.modifier.greedy.trin"
            }
          }
        },
        {
          "match": "(?:(\\?)|(\\+)|(\\*))\\s*(?:(\\?)|(\\+)|(\\*))?",
          "captures": {
            "1": {
              "name": "keyword.operator.quantifier.lazy.trin"
            },
            "2": {
              "name": "keyword.operator.quantifier.eager.trin"
            },
            "3": {
              "name": "keyword.operator.quantifier.greedy.trin"
            },
            "4": {
              "name": "keyword.operator.modifier.lazy.trin"
            },
            "5": {
              "name": "keyword.operator.modifier.eager.trin"
            },
            "6": {
              "name": "keyword.operator.modifier.greedy.trin"
            }
          }
        },
        {
          "begin": "(\\\\k<)",
          "end": "\\s*(>)",
          "name": "constant.other.back-reference.trin",
          "captures": {
            "1": {
              "name": "keyword.other.back-reference.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "begin": "(\\\\g<)",
          "end": "\\s*(>)",
          "name": "constant.other.subroutine.trin",
          "captures": {
            "1": {
              "name": "keyword.other.subroutine.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "begin": "(\\\\k('''+|\"\"\"+|['\"]))",
          "end": "\\s*(\\2)",
          "name": "constant.other.back-reference.trin",
          "captures": {
            "1": {
              "name": "keyword.other.back-reference.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "begin": "(\\\\g('''+|\"\"\"+|['\"]))",
          "end": "\\s*(\\2)",
          "name": "constant.other.subroutine.trin",
          "captures": {
            "1": {
              "name": "keyword.other.subroutine.trin"
            }
          },
          "patterns": [
            {
              "include": "#variables"
            },
            {
              "include": "#numbers"
            },
            {
              "include": "#operators"
            },
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "begin": "({)",
          "end": "\\s*(})",
          "name": "meta.fuzzy.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.fuzzy.trin"
            }
          },
          "patterns": [
            {
              "applyEndPatternLast": true,
              "begin": "(?<=^|\\\\.|[,;'\"`(){}\\[\\]\\s\\w])(:)",
              "beginCaptures": {
                "1": {
                  "name": "punctuation.separator.key-value.trin"
                }
              },
              "end": "(?=[,;}]|)|$",
              "patterns": [
                {
                  "include": "#regexp-patterns"
                }
              ]
            },
            {
              "include": "#fuzzy-expression"
            }
          ]
        },
        {
          "include": "#regexp-groups"
        },
        {
          "include": "#regexp-character-set"
        },
        {
          "include": "#regexp-character-class"
        }
      ]
    },
    "regexp-groups": {
      "patterns": [
        {
          "comment": "Embedded expression",
          "begin": "\\(\\?([*+])",
          "end": "\\s*(\\))",
          "name": "constant.other.pcre.trin",
          "captures": {
            "0": {
              "name": "punctuation.section.expression.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "Block comment",
          "begin": "(\\()(\\?#)",
          "contentName": "comment.block.regexp.trin",
          "end": "\\s*(\\))",
          "name": "comment.block.regexp.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.trin"
            }
          },
          "patterns": [
            {
              "match": "\\\\.",
              "name": "comment.block.regexp.trin"
            }
          ]
        },
        {
          "comment": "Lookahead assertion",
          "begin": "(\\(\\?=)",
          "end": "\\s*(\\))",
          "name": "meta.group.look-ahead.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.look-ahead.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Lookbehind assertion",
          "begin": "(\\(\\?<=)",
          "end": "\\s*(\\))",
          "name": "meta.group.look-behind.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.look-behind.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Negative lookahead assertion",
          "begin": "(\\(\\?!)",
          "end": "\\s*(\\))",
          "name": "meta.group.negative-look-ahead.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.negative-look-ahead.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Negative lookbehind assertion",
          "begin": "(\\(\\?<!)",
          "end": "\\s*(\\))",
          "name": "meta.group.negative-look-behind.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.negative-look-behind.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Match directive Oniguruma supports only 20 levels of recursion",
          "begin": "(?x)(\\(\\?)(?=%)",
          "captures": {
            "1": {
              "name": "punctuation.definition.directive.trin"
            }
          },
          "end": "\\s*(\\))",
          "name": "meta.group.directive.trin",
          "patterns": [
            {
              "include": "#format-syntax"
            },
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Longest match",
          "begin": "(\\(\\?/=?)",
          "end": "\\s*(\\))",
          "name": "meta.group.longest.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.longest.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Flag modifier group",
          "begin": "(\\(\\?\\^?(?:([+-]?\\d+?)|((?:[+-]\\p{Lu}+)+|\\p{Lu}+(?:[+-]\\p{Lu}+)*)|((?:[+-]\\p{Ll}+)+|\\p{Ll}+(?:[+-]\\p{Ll}+)*)))\\s*(:)?",
          "end": "\\s*(\\))",
          "name": "meta.group.flag.trin",
          "captures": {
            "0": {
              "name": "punctuation.definition.group.flag.trin"
            },
            "1": {
              "name": "punctuation.definition.group.flag.trin"
            },
            "2": {
              "name": "constant.numeric.index.trin"
            },
            "3": {
              "name": "keyword.control.recursion.trin"
            },
            "4": {
              "name": "keyword.other.flag.trin"
            },
            "5": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Callouts",
          "begin": "(\\(\\?)(?={)",
          "end": "\\s*(\\))",
          "name": "meta.group.call-out.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.call-out.trin"
            }
          },
          "patterns": [
            {
              "begin": "(?<=\\(\\?)({)",
              "end": "\\s*(\\})\\s*([<*>])?(?:(\\[)(.*?)(\\]))?",
              "name": "punctuation.definition.group.call-out.trin",
              "captures": {
                "1": {
                  "name": "punctuation.definition.group.call-out.trin"
                },
                "2": {
                  "name": "keyword.operator.range.trin"
                },
                "3": {
                  "name": "punctuation.definition.tag.trin"
                },
                "4": {
                  "patterns": [
                    {
                      "include": "#function-names"
                    }
                  ]
                },
                "5": {
                  "name": "punctuation.definition.tag.trin"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            },
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Atomic groups",
          "begin": "(\\(\\?>)",
          "end": "\\s*(\\))",
          "name": "meta.group.atomic.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.atomic.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Non-capturing groups",
          "begin": "(\\(\\?:)",
          "end": "\\s*(\\))",
          "name": "meta.group.non-capturing.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.non-capturing.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Branch groups",
          "begin": "(\\(\\?)(?=[(|])",
          "end": "\\s*(\\))",
          "name": "meta.group.branch.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.branch.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Atomic groups",
          "begin": "(\\(\\?~)",
          "end": "\\s*(\\))",
          "name": "meta.group.absent.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.absent.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Back-reference groups",
          "begin": "\\((\\?&(?:([+-]?\\d+)|([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)))(:)?",
          "end": "\\s*\\)",
          "name": "meta.group.back-reference.trin",
          "captures": {
            "0": {
              "name": "punctuation.definition.group.back-reference.trin"
            },
            "1": {
              "name": "punctuation.definition.group.back-reference.trin"
            },
            "2": {
              "name": "constant.numeric.index.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#variables"
                }
              ]
            },
            "4": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Named groups (angle-brackets)",
          "begin": "\\(\\?(?=<(?![!=]))",
          "end": "\\s*(\\))",
          "name": "meta.group.named.trin",
          "captures": {
            "0": {
              "name": "punctuation.definition.group.named.trin"
            }
          },
          "patterns": [
            {
              "begin": "(?<=\\(\\?)(<)",
              "end": "\\s*(>)",
              "name": "constant.other.group.trin",
              "captures": {
                "1": {
                  "name": "punctuation.definition.group.named.trin"
                }
              },
              "patterns": [
                {
                  "include": "#variables"
                },
                {
                  "include": "#numbers"
                },
                {
                  "include": "#operators"
                },
                {
                  "include": "#string-content"
                }
              ]
            },
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Named groups (single or double-quotes)",
          "begin": "\\(\\?(?=['\"])",
          "end": "\\s*(\\))",
          "name": "meta.group.named.trin",
          "captures": {
            "0": {
              "name": "punctuation.definition.group.named.trin"
            }
          },
          "patterns": [
            {
              "begin": "(?<=\\(\\?)('''+|\"\"\"+|['\"])",
              "end": "\\s*(\\1)",
              "name": "constant.other.group.trin",
              "captures": {
                "1": {
                  "name": "punctuation.definition.group.named.trin"
                }
              },
              "patterns": [
                {
                  "include": "#variables"
                },
                {
                  "include": "#numbers"
                },
                {
                  "include": "#operators"
                },
                {
                  "include": "#string-content"
                }
              ]
            },
            {
              "include": "#regexp-patterns"
            }
          ]
        },
        {
          "comment": "Unnamed groups",
          "begin": "(\\()",
          "end": "(\\s*\\))",
          "name": "meta.group.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.group.trin"
            }
          },
          "patterns": [
            {
              "include": "#regexp-patterns"
            }
          ]
        }
      ]
    },
    "regexp-character-class": {
      "patterns": [
        {
          "include": "#embedded"
        },
        {
          "match": "\\\\(?=\\s*$)",
          "name": "constant.character.escape.newline.trin"
        },
        {
          "include": "#character-escapes"
        },
        {
          "include": "#numeric-escapes"
        },
        {
          "begin": "(?i)\\\\p{",
          "end": "\\s*}",
          "name": "constant.other.character-class.unicode.trin",
          "patterns": [
            {
              "include": "#attribute-selectors"
            }
          ]
        },
        {
          "match": "(?i)\\\\([cm][a-z])",
          "name": "constant.character.control.trin"
        },
        {
          "match": "(?i)\\\\p[a-z]{1,2}",
          "name": "constant.other.character-class.unicode.trin"
        },
        {
          "match": "(?i)\\\\[ci]({\\w+})?",
          "name": "constant.other.character-class.xml.trin"
        },
        {
          "match": "(?i)\\\\n{(?:[^\\\\{}]|\\\\.)+}",
          "name": "constant.character.escape.unicode.name.trin"
        },
        {
          "match": "\\\\[prntfvabe]",
          "name": "constant.character.escape.trin"
        },
        {
          "match": "\\\\[a-z]",
          "name": "constant.other.character-class.trin"
        },
        {
          "match": "\\\\[A-Z]",
          "name": "constant.other.character-class.negated.trin"
        },
        {
          "match": "(?i)\\\\[\\p{L}\\p{N}]",
          "name": "constant.character.escape.trin"
        },
        {
          "match": "\\\\[\\p{S}\\p{P}]",
          "name": "constant.character.escape.symbol.trin"
        },
        {
          "match": "\\\\\\p{Z}",
          "name": "constant.character.escape.other.trin"
        },
        {
          "match": "\\\\\\p{C}",
          "name": "invalid.illegal.unknown-escape.trin"
        },
        {
          "match": "\\\\.",
          "name": "constant.character.escape.other.trin"
        }
      ]
    },
    "regexp-character-operators": {
      "patterns": [
        {
          "match": "(?x)\n( # from\n    \\\\(?:d?\\d+|d{[\\d\\s,;]+}) # decimal escape\n  | \\\\[xu](?:\\h+|{[\\h\\s,;]+}) # hex escape\n  | \\\\o(?:[0-7]+|{[0-7\\s,;]+}) # octal escape\n  | \\\\b(?:[01]+|{[01\\s,;]+}) # binary escape\n  | \\\\[cm][a-z] # meta-character\n  | \\\\p(?:[a-z]{1,2}|{(?:[^\\\\{}]|\\\\.)+}) # Unicode char-group\n  | \\\\n{(?:[^\\\\{}]|\\\\.)+} # Unicode named character\n  | \\\\(?:[prntfvabe]|[^a-zA-Z]) # any escape character\n  | [^-\\\\\\[\\]] # any unescaped character\n)\n  \\s*\n    (-|->|>-|>>) # range\n  \\s*\n( # to\n    \\\\(?:d?\\d+|d{[\\d\\s,;]+}) # decimal escape\n  | \\\\[xu](?:\\h+|{[\\h\\s,;]+}) # hex escape\n  | \\\\o(?:[0-7]+|{[0-7\\s,;]+}) # octal escape\n  | \\\\b(?:[01]+|{[01\\s,;]+}) # binary escape\n  | \\\\[cm][a-z] # meta-character\n  | \\\\p(?:[a-z]{1,2}|{(?:[^\\\\{}]|\\\\.)+}) # Unicode char-group\n  | \\\\n{(?:[^\\\\{}]|\\\\.)+} # Unicode named character\n  | \\\\(?:[prntfvabe]|[^a-zA-Z]) # any escape character\n  | [^-\\\\\\[\\]] # any unescaped character\n) (?:\n    \\s*\n      (:) # range\n    \\s*\n  ( # to\n      \\d+ # number\n    | \\\\(?:d?\\d+|d{[\\d\\s,;]+}) # decimal escape\n    | \\\\[xu](?:\\h+|{[\\h\\s,;]+}) # hex escape\n    | \\\\o(?:[0-7]+|{[0-7\\s,;]+}) # octal escape\n    | \\\\b(?:[01]+|{[01\\s,;]+}) # binary escape\n    | \\\\[cm][a-z] # meta-character\n    | \\\\p(?:[a-z]{1,2}|{(?:[^\\\\{}]|\\\\.)+}) # Unicode char-group\n    | \\\\n{(?:[^\\\\{}]|\\\\.)+} # Unicode named character\n    | \\\\(?:[prntfvabe]|[^a-zA-Z]) # any escape character\n    | [^-\\\\\\[\\]] # any unescaped character\n  )\n)?\n",
          "captures": {
            "1": {
              "name": "constant.other.character-class.range.from.trin",
              "patterns": [
                {
                  "include": "#regexp-character-operators"
                },
                {
                  "include": "#regexp-character-class"
                }
              ]
            },
            "2": {
              "name": "keyword.operator.range.trin"
            },
            "3": {
              "name": "constant.other.character-class.range.to.trin",
              "patterns": [
                {
                  "include": "#regexp-character-operators"
                },
                {
                  "include": "#regexp-character-class"
                }
              ]
            },
            "4": {
              "name": "keyword.operator.range.trin"
            },
            "5": {
              "name": "constant.other.character-class.range.by.trin",
              "patterns": [
                {
                  "include": "#numbers"
                },
                {
                  "include": "#regexp-character-operators"
                },
                {
                  "include": "#regexp-character-class"
                }
              ]
            }
          }
        },
        {
          "match": "\\|\\|",
          "name": "keyword.operator.union.trin"
        },
        {
          "match": "\\&&",
          "name": "keyword.operator.intersection.trin"
        },
        {
          "match": "\\^\\^",
          "name": "keyword.operator.symmetric.trin"
        },
        {
          "match": "~~",
          "name": "keyword.operator.negation.trin"
        },
        {
          "match": "--",
          "name": "keyword.operator.difference.trin"
        }
      ]
    },
    "regexp-character-set": {
      "patterns": [
        {
          "begin": "(\\[:)",
          "end": "\\s*(:\\])",
          "name": "constant.other.character-set.posix.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.character-class.posix.trin"
            }
          },
          "patterns": [
            {
              "include": "#attribute-selectors"
            }
          ]
        },
        {
          "begin": "(\\[\\^)",
          "end": "\\s*(\\])",
          "name": "constant.other.character-set.negated.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.character-class.negated.trin"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#regexp-character-operators"
            },
            {
              "include": "#regexp-character-class"
            },
            {
              "include": "#regexp-character-set"
            }
          ]
        },
        {
          "begin": "(\\[)",
          "end": "\\s*(\\])",
          "name": "constant.other.character-set.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.character-class.trin"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "include": "#regexp-character-operators"
            },
            {
              "include": "#regexp-character-class"
            },
            {
              "include": "#regexp-character-set"
            }
          ]
        }
      ]
    },
    "attribute-selectors": {
      "patterns": [
        {
          "match": ",",
          "name": "punctuation.separator.sequence.trin"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#strings"
        },
        {
          "match": "(?xi)\\b[is]\\b\\s*(?=[)}\\]]|([&|^])\\1)",
          "name": "storage.modifier.ignore-when.trin"
        },
        {
          "include": "#string-escapes"
        },
        {
          "match": "[:!=</>.^$%?*+|&~]?=",
          "name": "keyword.operator.pattern.trin"
        },
        {
          "match": "\\&&|\\|\\||\\^\\^|!",
          "name": "keyword.operator.logical.trin"
        },
        {
          "match": "\\b(i[ns])\\b",
          "name": "keyword.operator.expression.$1.trin"
        },
        {
          "begin": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b([:!=</>.^$%?*+|&~]?=)",
          "beginCaptures": {
            "1": {
              "name": "entity.other.attribute-name.key.trin"
            },
            "2": {
              "name": "keyword.operator.pattern.trin"
            }
          },
          "end": "(?=&&|\\|\\||\\^\\^|[\\s,:;'\"`(){}\\[\\]])",
          "name": "string.unquoted.attribute-name.trin",
          "patterns": [
            {
              "include": "#html-properties"
            }
          ]
        },
        {
          "comment": "Attribute names",
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
          "captures": {
            "1": {
              "name": "entity.other.attribute-name.trin"
            },
            "2": {
              "name": "keyword.operator.pattern.trin"
            }
          }
        },
        {
          "include": "#operators"
        }
      ]
    },
    "jsx": {
      "applyEndPatternLast": true,
      "comment": "Only after opening brackets, commas, semicolons, keywords, and operators.\nIn addition, < > starts a JSX fragment, <?x ... ?> starts a declaration, and =\n<! !> starts a fragment with CDATA-style syntax.\n",
      "begin": "(?x)\n(?<=\n  (?:\n    (?:\n        ^ # beginning of line\n      | [,;] # separator\n      | [({\\[] # opening bracket\n    )\n      | \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b # identifier or keyword\n      | [\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+ \\s # postfix or infix operator\n  ) \\s*\n)\n(?=<[\\p{Pc}\\p{L}]|<\\s+>)\n",
      "end": "(?=)|$",
      "patterns": [
        {
          "include": "#tag-component-name"
        }
      ]
    },
    "tag-component-name": {
      "patterns": [
        {
          "comment": "JSX Fragment",
          "contentName": "meta.jsx.fragment.trin",
          "begin": "\\s*(<)\\s*(?=>)",
          "end": "(?<=</)(>)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.tag.trin"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.tag.trin"
            }
          },
          "patterns": [
            {
              "include": "#tag-termination"
            }
          ]
        },
        {
          "comment": "Tags that end > are trapped in tag-termination",
          "contentName": "meta.jsx.trin",
          "begin": "(?x)\n\\s*\n(<) # start tag begin\n(\n  (?:\n    \\b\n    [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # identifier\n    \\b\n    (?:\\.|::?) # qualified name separator\n  )*\n  [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # last part of identifier\n  \\b\n)\n(?=[/>\\s])(?![:])(?<![.:=])\n",
          "end": "(?x) \\s*\n(?:\n    (?<=</)(\\2)(>)\n  | (<?/>)\n  | ((?<=</)\\O*?)>\n)\n",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.tag.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#tag-names"
                }
              ]
            }
          },
          "endCaptures": {
            "1": {
              "patterns": [
                {
                  "include": "#tag-names"
                }
              ]
            },
            "2": {
              "name": "punctuation.definition.tag.trin"
            },
            "3": {
              "name": "punctuation.definition.tag.trin"
            },
            "4": {
              "name": "invalid.illegal.termination.trin"
            }
          },
          "patterns": [
            {
              "include": "#tag-termination"
            },
            {
              "include": "#tag-attributes"
            }
          ]
        }
      ]
    },
    "jsx-comments": {
      "begin": "<!--",
      "end": "-->",
      "captures": {
        "1": {
          "name": "punctuation.definition.comment.trin"
        }
      },
      "name": "comment.block.trin"
    },
    "tag-termination": {
      "comment": "uses non consuming search for </ in </tag>",
      "contentName": "string.unquoted.html.trin",
      "name": "string.unquoted.html.trin",
      "begin": "(>)",
      "end": "(</)",
      "captures": {
        "0": {
          "name": "punctuation.definition.tag.trin"
        }
      },
      "patterns": [
        {
          "include": "#evaluated-code"
        },
        {
          "include": "#jsx-entities"
        },
        {
          "include": "#tag-component-name"
        },
        {
          "include": "#markdown"
        },
        {
          "include": "#jsx-comments"
        }
      ]
    },
    "tag-attributes": {
      "patterns": [
        {
          "include": "#comma"
        },
        {
          "include": "#semicolon"
        },
        {
          "include": "#style-selectors"
        },
        {
          "include": "#attribute-names"
        },
        {
          "applyEndPatternLast": true,
          "begin": "\\s*(=)\\s*",
          "beginCaptures": {
            "1": {
              "name": "punctuation.separator.key-value.trin"
            }
          },
          "end": "(?=)|$",
          "name": "string.unquoted.trin",
          "patterns": [
            {
              "include": "#html-properties"
            }
          ]
        },
        {
          "include": "#strings"
        },
        {
          "include": "#comments"
        }
      ]
    },
    "attribute-names": {
      "match": "\\s*([\\p{Pd}\\w]+)\\b\\s*",
      "captures": {
        "1": {
          "name": "entity.other.attribute-name.${1:/camelcase}.trin",
          "patterns": [
            {
              "include": "#css-property-names"
            }
          ]
        }
      },
      "name": "string.unquoted.trin"
    },
    "spread-attribute": {
      "comment": "Spread attribute { ... AssignmentExpression }",
      "match": "(?<!\\*)\\*(?!\\*)",
      "name": "keyword.operator.spread.trin"
    },
    "jsx-entities": {
      "patterns": [
        {
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.trin"
            },
            "2": {
              "name": "punctuation.definition.entity.trin"
            }
          },
          "match": "(&)#\\d+(;)",
          "name": "constant.character.escape.decimal.trin"
        },
        {
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.trin"
            },
            "2": {
              "name": "punctuation.definition.entity.trin"
            }
          },
          "match": "(?i)(&)#x\\h+(;)",
          "name": "constant.character.escape.hexadecimal.trin"
        },
        {
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.trin"
            },
            "2": {
              "name": "punctuation.definition.entity.trin"
            }
          },
          "match": "(?i)(&)#b[01]+(;)",
          "name": "constant.character.escape.binary.trin"
        },
        {
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.trin"
            },
            "2": {
              "name": "punctuation.definition.entity.trin"
            }
          },
          "match": "(?i)(&)#o[0-7]\\h+(;)",
          "name": "constant.character.escape.octal.trin"
        },
        {
          "captures": {
            "1": {
              "name": "punctuation.definition.entity.trin"
            },
            "2": {
              "name": "punctuation.definition.entity.trin"
            }
          },
          "match": "(&)(?:\\\\.|[^(){}\\[\\]\\s;])+?(;)",
          "name": "constant.character.entity.xml"
        },
        {
          "match": "&(?=\\w*;)",
          "name": "invalid.illegal.ambiguous-ampersand.trin"
        },
        {
          "comment": "Entity with & and invalid name",
          "match": "&\\s*+;",
          "name": "invalid.illegal.bad-ampersand.trin"
        }
      ]
    },
    "inline-markdown": {
      "patterns": [
        {
          "include": "#ampersand"
        },
        {
          "include": "#bracket"
        },
        {
          "include": "#bold"
        },
        {
          "include": "#italic"
        },
        {
          "include": "#raw"
        },
        {
          "include": "#escape"
        },
        {
          "include": "#image-inline"
        },
        {
          "include": "#image-ref"
        },
        {
          "include": "#link-email"
        },
        {
          "include": "#link-inet"
        },
        {
          "include": "#link-inline"
        },
        {
          "include": "#link-ref"
        },
        {
          "include": "#link-ref-literal"
        },
        {
          "include": "#link-ref-shortcut"
        }
      ]
    },
    "ampersand": {
      "comment": "Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.",
      "match": "&(?!([a-zA-Z0-9]+|#[0-9]+|#x\\h+);)",
      "name": "meta.other.valid-ampersand.markdown"
    },
    "bold": {
      "begin": "(?x)\n(?<open>(\\*\\*(?=\\w)|(?<!\\w)\\*\\*|(?<!\\w)\\b__))(?=\\S)\n(?=\n  (\n    <[^>]*+> # HTML tags\n    | (?<raw>`+)([^`]|(?!(?<!`)\\k<raw>(?!`))`)*+\\k<raw>\n    # Raw\n    | \\\\[\\\\`*_{}\\[\\]() #.!+\\->]?+ # Escapes\n    | \\[\n    (\n        (?<square> # Named group\n          [^\\[\\]\\\\] # Match most chars\n          | \\\\. # Escaped chars\n          | \\[ \\g<square>*+ \\] # Nested brackets\n        )*+\n      \\]\n      (\n        ( # Reference Link\n          [ ]? # Optional space\n          \\[[^\\]]*+\\] # Ref name\n        )\n        | ( # Inline Link\n          \\( # Opening paren\n            [ \\t]*+ # Optional whitespace\n            <?(.*?)>? # URL\n            [ \\t]*+ # Optional whitespace\n            ( # Optional Title\n              (?<title>['\"])\n              (.*?)\n              \\k<title>\n            )?\n          \\)\n        )\n      )\n    )\n    | (?!(?<=\\S)\\k<open>). # Everything besides\n    # style closer\n  )++\n  (?<=\\S)(?=__\\b|\\*\\*)\\k<open> # Close\n)\n",
      "captures": {
        "1": {
          "name": "punctuation.definition.bold.markdown"
        }
      },
      "end": "(?<=\\S)(\\1)",
      "name": "markup.bold.markdown",
      "patterns": [
        {
          "include": "#string-content"
        },
        {
          "include": "#escape"
        },
        {
          "include": "#ampersand"
        },
        {
          "include": "#bracket"
        },
        {
          "include": "#raw"
        },
        {
          "include": "#bold"
        },
        {
          "include": "#italic"
        },
        {
          "include": "#image-inline"
        },
        {
          "include": "#link-inline"
        },
        {
          "include": "#link-inet"
        },
        {
          "include": "#link-email"
        },
        {
          "include": "#image-ref"
        },
        {
          "include": "#link-ref-literal"
        },
        {
          "include": "#link-ref"
        },
        {
          "include": "#link-ref-shortcut"
        }
      ]
    },
    "bracket": {
      "comment": "Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.",
      "match": "<(?![a-zA-Z/?\\$!])",
      "name": "meta.other.valid-bracket.markdown"
    },
    "escape": {
      "match": "\\\\[-`*_#+.!(){}\\[\\]\\\\>]",
      "name": "constant.character.escape.markdown"
    },
    "image-inline": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.description.markdown"
        },
        "4": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "5": {
          "name": "punctuation.definition.metadata.markdown"
        },
        "6": {
          "name": "punctuation.definition.link.markdown"
        },
        "7": {
          "name": "markup.underline.link.image.markdown"
        },
        "8": {
          "name": "punctuation.definition.link.markdown"
        },
        "9": {
          "name": "string.other.link.description.title.markdown"
        },
        "10": {
          "name": "punctuation.definition.string.markdown"
        },
        "11": {
          "name": "punctuation.definition.string.markdown"
        },
        "12": {
          "name": "string.other.link.description.title.markdown"
        },
        "13": {
          "name": "punctuation.definition.string.markdown"
        },
        "14": {
          "name": "punctuation.definition.string.markdown"
        },
        "15": {
          "name": "string.other.link.description.title.markdown"
        },
        "16": {
          "name": "punctuation.definition.string.markdown"
        },
        "17": {
          "name": "punctuation.definition.string.markdown"
        },
        "18": {
          "name": "punctuation.definition.metadata.markdown"
        }
      },
      "match": "(?x)\n(\\!\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])\n# Match the link text.\n(\\() # Opening paren for url\n  (<?)(\\S+?)(>?) # The url\n  [ \\t]* # Optional whitespace\n  (?:\n      ((\\().+?(\\))) # Match title in parens...\n    | ((\").+?(\")) # or in double quotes...\n    | ((').+?(')) # or in single quotes.\n  )? # Title is optional\n  \\s* # Optional whitespace\n(\\))\n",
      "name": "meta.image.inline.markdown"
    },
    "image-ref": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.description.markdown"
        },
        "4": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "5": {
          "name": "punctuation.definition.constant.markdown"
        },
        "6": {
          "name": "constant.other.reference.link.markdown"
        },
        "7": {
          "name": "punctuation.definition.constant.markdown"
        }
      },
      "match": "(\\!\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])[ ]?(\\[)(.*?)(\\])",
      "name": "meta.image.reference.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "italic": {
      "begin": "(?x) (?<open>(\\*(?=\\w)|(?<!\\w)\\*|(?<!\\w)\\b_))(?=\\S) # Open\n(?=\n  (\n    <[^>]*+> # HTML tags\n    | (?<raw>`+)([^`]|(?!(?<!`)\\k<raw>(?!`))`)*+\\k<raw>\n    # Raw\n    | \\\\[\\\\`*_{}\\[\\]() #.!+\\->]?+ # Escapes\n    | \\[\n    (\n        (?<square> # Named group\n          [^\\[\\]\\\\] # Match most chars\n          | \\\\. # Escaped chars\n          | \\[ \\g<square>*+ \\] # Nested brackets\n        )*+\n      \\]\n      (\n        ( # Reference Link\n          [ ]? # Optional space\n          \\[[^\\]]*+\\] # Ref name\n        )\n        | ( # Inline Link\n          \\( # Opening paren\n            [ \\t]*+ # Optional whitespace\n            <?(.*?)>? # URL\n            [ \\t]*+ # Optional whitespace\n            ( # Optional Title\n              (?<title>['\"])\n              (.*?)\n              \\k<title>\n            )?\n          \\)\n        )\n      )\n    )\n    | \\k<open>\\k<open> # Must be bold closer\n    | (?!(?<=\\S)\\k<open>). # Everything besides\n    # style closer\n  )++\n  (?<=\\S)(?=_\\b|\\*)\\k<open> # Close\n)\n",
      "captures": {
        "1": {
          "name": "punctuation.definition.italic.markdown"
        }
      },
      "end": "(?<=\\S)(\\1)((?!\\1)|(?=\\1\\1))",
      "name": "markup.italic.markdown",
      "patterns": [
        {
          "include": "#string-content"
        },
        {
          "include": "#escape"
        },
        {
          "include": "#ampersand"
        },
        {
          "include": "#bracket"
        },
        {
          "include": "#raw"
        },
        {
          "include": "#bold"
        },
        {
          "include": "#image-inline"
        },
        {
          "include": "#link-inline"
        },
        {
          "include": "#link-inet"
        },
        {
          "include": "#link-email"
        },
        {
          "include": "#image-ref"
        },
        {
          "include": "#link-ref-literal"
        },
        {
          "include": "#link-ref"
        },
        {
          "include": "#link-ref-shortcut"
        }
      ]
    },
    "link-email": {
      "captures": {
        "1": {
          "name": "punctuation.definition.link.markdown"
        },
        "2": {
          "name": "markup.underline.link.markdown"
        },
        "4": {
          "name": "punctuation.definition.link.markdown"
        }
      },
      "match": "(<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)(>)",
      "name": "meta.link.email.lt-gt.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "link-inet": {
      "captures": {
        "1": {
          "name": "punctuation.definition.link.markdown"
        },
        "2": {
          "name": "markup.underline.link.markdown"
        },
        "3": {
          "name": "punctuation.definition.link.markdown"
        }
      },
      "match": "(<)((?:https?|ftp)://.*?)(>)",
      "name": "meta.link.inet.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "link-inline": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.title.markdown"
        },
        "4": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "5": {
          "name": "punctuation.definition.metadata.markdown"
        },
        "6": {
          "name": "punctuation.definition.link.markdown"
        },
        "7": {
          "name": "markup.underline.link.markdown"
        },
        "9": {
          "name": "punctuation.definition.link.markdown"
        },
        "10": {
          "name": "string.other.link.description.title.markdown"
        },
        "11": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "12": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "13": {
          "name": "string.other.link.description.title.markdown"
        },
        "14": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "15": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "16": {
          "name": "string.other.link.description.title.markdown"
        },
        "17": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "18": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "19": {
          "name": "punctuation.definition.metadata.markdown"
        }
      },
      "match": "(?x)\n(\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])\n# Match the link text.\n(\\() # Opening paren for url\n  (<?)((?<url>(?>[^\\s()]+)|\\(\\g<url>*\\))*)(>?) # The url\n  [ \\t]* # Optional whitespace\n  (?:\n      ((\\().+?(\\))) # Match title in parens...\n    | ((\").+?(\")) # or in double quotes...\n    | ((').+?(')) # or in single quotes.\n  )? # Title is optional\n  \\s* # Optional whitespace\n(\\))\n",
      "name": "meta.link.inline.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "link-ref": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.title.markdown"
        },
        "4": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "5": {
          "name": "punctuation.definition.constant.begin.markdown"
        },
        "6": {
          "name": "constant.other.reference.link.markdown"
        },
        "7": {
          "name": "punctuation.definition.constant.end.markdown"
        }
      },
      "match": "(\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])(\\[)([^\\]]*+)(\\])",
      "name": "meta.link.reference.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "link-ref-literal": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.title.markdown"
        },
        "4": {
          "name": "punctuation.definition.string.end.markdown"
        },
        "5": {
          "name": "punctuation.definition.constant.begin.markdown"
        },
        "6": {
          "name": "punctuation.definition.constant.end.markdown"
        }
      },
      "match": "(\\[)((?<square>[^\\[\\]\\\\]|\\\\.|\\[\\g<square>*+\\])*+)(\\])[ ]?(\\[)(\\])",
      "name": "meta.link.reference.literal.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "link-ref-shortcut": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.markdown"
        },
        "2": {
          "name": "string.other.link.title.markdown"
        },
        "3": {
          "name": "punctuation.definition.string.end.markdown"
        }
      },
      "match": "(\\[)(\\S+?)(\\])",
      "name": "meta.link.reference.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "raw": {
      "captures": {
        "1": {
          "name": "punctuation.definition.raw.markdown"
        },
        "2": {
          "patterns": [
            {
              "include": "#string-content"
            }
          ]
        },
        "3": {
          "name": "punctuation.definition.raw.markdown"
        }
      },
      "match": "(`+)([^`]|(?!(?<!`)\\1(?!`))`)*+(\\1)",
      "name": "markup.inline.raw.string.markdown",
      "patterns": [
        {
          "include": "#string-content"
        }
      ]
    },
    "markdown": {
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "include": "#jsx-entities"
        },
        {
          "include": "#html-tag"
        },
        {
          "include": "#string-content"
        },
        {
          "include": "#evaluated-code"
        },
        {
          "include": "#executed-code"
        },
        {
          "include": "#inline-styles"
        },
        {
          "include": "#blockquote"
        },
        {
          "include": "#unordered-list"
        },
        {
          "include": "#ordered-list"
        },
        {
          "include": "#inline-markdown"
        }
      ],
      "repository": {
        "blockquote": {
          "comment": "> blockquote",
          "begin": "^\\s*(\\>)(\\s+.*)\\n*",
          "end": "^(?=\\S)|(?!\\G)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.quote.begin.markdown.trin"
            },
            "2": {
              "name": "markup.quote.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          },
          "name": "markup.quote.markdown.trin",
          "patterns": [
            {
              "begin": "^(\\s+)(?!\\s)",
              "end": "^(?!\\1|\\s*$)",
              "name": "markup.quote.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          ]
        },
        "unordered-list": {
          "comment": "- unordered list",
          "begin": "^\\s*(\\-)(?!>)\\s+(.*)\\n*",
          "end": "^(?=\\S)|(?!\\G)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.list.begin.markdown.trin"
            },
            "2": {
              "name": "markup.list.unnumbered.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          },
          "name": "markup.list.unnumbered.markdown.trin",
          "patterns": [
            {
              "begin": "^(\\s+)(?!\\s)",
              "end": "^(?!\\1|\\s*$)",
              "name": "markup.list.unnumbered.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          ]
        },
        "ordered-list": {
          "comment": "+ ordered list",
          "begin": "^\\s*(\\+)(?!>)\\s+(.*)\\n*",
          "end": "^(?=\\S)|(?!\\G)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.list.begin.markdown.trin"
            },
            "2": {
              "name": "markup.list.numbered.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          },
          "name": "markup.list.numbered.markdown.trin",
          "patterns": [
            {
              "begin": "^(\\s+)(?!\\s)",
              "end": "^(?!\\1|\\s*$)",
              "name": "markup.list.numbered.markdown.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          ]
        },
        "evaluated-code": {
          "applyEndPatternLast": true,
          "comment": "Evaluated code",
          "begin": "(?<=^|[\\w\\s'\"`])(=>)",
          "end": "(?=|$)",
          "captures": {
            "1": {
              "name": "storage.type.method.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        "executed-code": {
          "applyEndPatternLast": true,
          "comment": "Executed code",
          "begin": "(?<=^|[\\w\\s'\"`])(->)",
          "end": "(?=|$)",
          "captures": {
            "1": {
              "name": "storage.type.subroutine.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        "html-tag": {
          "comment": "<Tags",
          "applyEndPatternLast": true,
          "begin": "(?<=^|[\\w\\s'\"`])(<)\\b",
          "end": "(<?>?=?)|(?=)|$",
          "name": "meta.tag.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.tag.trin"
            }
          },
          "patterns": [
            {
              "comment": "Tag name",
              "match": "(?<=<)\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?:[:.][\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b",
              "captures": {
                "1": {
                  "name": "entity.name.tag.trin",
                  "patterns": [
                    {
                      "match": "\\.|:|::",
                      "name": "punctuation.separator.namespace.trin"
                    },
                    {
                      "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[:.])",
                      "name": "entity.name.tag.namespace.trin"
                    },
                    {
                      "match": "\\b((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\\b",
                      "name": "support.class.component.trin"
                    },
                    {
                      "include": "#clauses"
                    },
                    {
                      "include": "#declarations"
                    },
                    {
                      "include": "#keywords"
                    },
                    {
                      "include": "#html-tag-names"
                    }
                  ]
                }
              }
            },
            {
              "comment": "ID",
              "match": "(?<=#)\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
              "name": "entity.other.attribute-name.id.trin"
            },
            {
              "comment": "Class",
              "match": "(?<=\\.)\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b",
              "name": "entity.other.attribute-name.class.trin"
            },
            {
              "begin": "(\\[)\\s*",
              "end": "\\s*(\\])\\s*",
              "captures": {
                "1": {
                  "name": "punctuation.definition.directive.trin"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            },
            {
              "begin": "(\\{)\\s*",
              "end": "\\s*(\\})\\s*",
              "captures": {
                "1": {
                  "name": "punctuation.definition.mapping.trin"
                }
              },
              "patterns": [
                {
                  "include": "#style-properties"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "begin": "(\\()\\s*",
              "end": "\\s*(\\))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.parameters.trin"
                }
              },
              "patterns": [
                {
                  "include": "#tag-attributes"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "match": "\\s*([.#])(?=[\\w$])",
              "name": "punctuation.definition.entity.trin"
            },
            {
              "comment": "inline markup",
              "begin": "(?<!'+)\\s*('''+|')",
              "contentName": "string.quoted.single.trin",
              "end": "\\s*((\\1)(?!'+))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.string.trin"
                }
              },
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            },
            {
              "comment": "inline markup",
              "begin": "(?<!\"+)\\s*(\"\"\"+|\")",
              "contentName": "string.quoted.double.trin",
              "end": "\\s*((\\1)(?!\"+))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.string.trin"
                }
              },
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            },
            {
              "include": "#regexps"
            }
          ]
        },
        "inline-styles": {
          "begin": "(?<=^|[\\w\\s'\"`])(\\+>)(.*)\\n*",
          "beginCaptures": {
            "1": {
              "name": "storage.type.style.trin"
            },
            "2": {
              "patterns": [
                {
                  "match": "(?<=^|\\s)([?:]?=)(?=\\s+|$)",
                  "captures": {
                    "1": {
                      "name": "keyword.operator.assignment.trin"
                    }
                  }
                },
                {
                  "include": "#comments"
                },
                {
                  "include": "#style-pair"
                },
                {
                  "include": "#style-rules"
                },
                {
                  "include": "#block-entities"
                },
                {
                  "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
                  "name": "entity.name.style.trin"
                }
              ]
            }
          },
          "end": "^(?=\\S)|(?!\\G)",
          "patterns": [
            {
              "begin": "^(\\s+)(?!\\s)",
              "end": "^(?!\\1|\\s*$)",
              "name": "meta.style.yaml",
              "patterns": [
                {
                  "include": "#style-properties"
                }
              ]
            }
          ]
        }
      }
    },
    "html-properties": {
      "patterns": [
        {
          "include": "#line-continuation"
        },
        {
          "include": "source.yaml#flow-sequence"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#css-value-names"
        },
        {
          "include": "#hex-colors"
        },
        {
          "include": "#type-variables"
        },
        {
          "include": "#embedded-expression"
        },
        {
          "include": "source.css.scss#constant_functions"
        },
        {
          "include": "source.css.scss#constant_sass_functions"
        },
        {
          "include": "source.css.scss#constant_important"
        },
        {
          "include": "source.css.scss#constant_default"
        },
        {
          "include": "source.css.scss#constant_optional"
        }
      ]
    },
    "hex-colors": {
      "match": "(#)\\b(?:\\h{3,4}|\\h{6}|\\h{8})\\b",
      "name": "constant.other.color.rgb-value.hex.css",
      "captures": {
        "1": {
          "name": "punctuation.definition.constant.css"
        }
      }
    },
    "tag-names": {
      "match": "\\s*\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?:(?:\\.|::?)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*)*)\\b\\s*",
      "name": "entity.name.tag.trin",
      "captures": {
        "1": {
          "name": "entity.name.tag.trin",
          "patterns": [
            {
              "match": "\\.|:|::",
              "name": "punctuation.separator.namespace.trin"
            },
            {
              "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[:.])",
              "name": "entity.name.tag.namespace.trin"
            },
            {
              "match": "\\b((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\\b",
              "name": "support.class.component.trin"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#keywords"
            },
            {
              "include": "#html-tag-names"
            }
          ]
        }
      }
    },
    "style-block": {
      "begin": "\\s*(\\{)\\s*",
      "end": "\\s*(\\})\\s*",
      "captures": {
        "1": {
          "name": "punctuation.section.property-list.trin"
        }
      },
      "patterns": [
        {
          "include": "#style-properties"
        }
      ]
    },
    "style-pair": {
      "applyEndPatternLast": true,
      "begin": "\\s*([\\p{Pd}\\w]+)\\b(:)\\s*",
      "end": "(?=)|$",
      "name": "string.unquoted.trin",
      "beginCaptures": {
        "1": {
          "name": "support.type.property-name.trin",
          "patterns": [
            {
              "include": "#css-property-names"
            }
          ]
        },
        "2": {
          "name": "punctuation.separator.key-value.trin"
        }
      },
      "patterns": [
        {
          "include": "#html-properties"
        },
        {
          "match": "\\s+",
          "name": "meta.var.expr.trin"
        }
      ]
    },
    "style-properties": {
      "patterns": [
        {
          "include": "#embedded"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#keywords"
        },
        {
          "include": "#style-pair"
        },
        {
          "include": "#style-rules"
        },
        {
          "include": "#style-block"
        },
        {
          "include": "$self"
        }
      ]
    },
    "style-rules": {
      "patterns": [
        {
          "include": "#calls"
        },
        {
          "comment": "CSS operators",
          "match": "\\s*(?:(\\+)|(\\-)|(\\*)|(/)|(\\%)|(\\!)|(\\?)|(\\&)|(\\|)|(\\^)|(\\~)|(\\$)|(\\#)|([<>]))\\s*",
          "captures": {
            "1": {
              "name": "keyword.operator.sum.trin"
            },
            "2": {
              "name": "keyword.operator.difference.trin"
            },
            "3": {
              "name": "keyword.operator.product.trin"
            },
            "4": {
              "name": "keyword.operator.quotient.trin"
            },
            "5": {
              "name": "keyword.operator.remainder.trin"
            },
            "6": {
              "name": "keyword.operator.only.trin"
            },
            "7": {
              "name": "keyword.operator.maybe.trin"
            },
            "8": {
              "name": "keyword.operator.intersection.trin"
            },
            "9": {
              "name": "keyword.operator.union.trin"
            },
            "10": {
              "name": "keyword.operator.symmetric.trin"
            },
            "11": {
              "name": "keyword.operator.negation.trin"
            },
            "12": {
              "name": "keyword.operator.macro.dollar.trin"
            },
            "13": {
              "name": "keyword.operator.private.trin"
            },
            "14": {
              "name": "keyword.operator.class.trin"
            }
          }
        },
        {
          "begin": "\\s*(\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.parameters.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#style-pair"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(\\[)\\s*",
          "end": "\\s*(\\])\\s*",
          "captures": {
            "1": {
              "name": "punctuation.definition.selector.trin"
            }
          },
          "patterns": [
            {
              "include": "#attribute-selectors"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.trin"
        },
        {
          "include": "#style-selectors"
        },
        {
          "include": "#format-syntax"
        },
        {
          "include": "#tag-names"
        }
      ]
    },
    "style-selectors": {
      "patterns": [
        {
          "match": "\\s*(\\@|\\#|\\&|\\*|\\.|\\:|::)(?=[\\w$])",
          "name": "punctuation.definition.entity.trin"
        },
        {
          "match": "\\s*(?<=@)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "keyword.control.at-rule.trin"
        },
        {
          "match": "\\s*(?<=#)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "entity.other.attribute-name.id.trin"
        },
        {
          "match": "\\s*(?<=&)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "entity.name.type.anchor.trin"
        },
        {
          "match": "\\s*(?<=\\*)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "entity.name.type.alias.trin"
        },
        {
          "match": "\\s*(?<=\\.)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "entity.other.attribute-name.class.trin"
        },
        {
          "match": "\\s*(?<=::?)[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\s*",
          "name": "entity.other.attribute-name.pseudo-component.trin"
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "include": "#block-comments"
        },
        {
          "include": "#line-comments"
        },
        {
          "include": "#nested-comments"
        }
      ]
    },
    "block-comments": {
      "patterns": [
        {
          "begin": "\\s*(/\\*\\*)(?=\\s+|\\s*$)",
          "end": "\\s*(\\*/)",
          "name": "comment.block.documentation.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.trin"
            }
          },
          "patterns": [
            {
              "include": "#jsdoc"
            },
            {
              "include": "text.html.markdown#inline"
            },
            {
              "include": "#nested-jsdoc"
            }
          ]
        },
        {
          "begin": "\\s*(/\\*)(?=\\s+|\\s*$)",
          "end": "\\s*(\\*/)",
          "name": "comment.block.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.trin"
            }
          },
          "patterns": [
            {
              "include": "text.html.markdown#inline"
            },
            {
              "include": "#nested-block"
            }
          ]
        }
      ]
    },
    "line-comments": {
      "patterns": [
        {
          "begin": "\\s*(///)(?=\\s+|\\s*$)",
          "end": "\\s*$",
          "name": "comment.line.documentation.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.trin"
            }
          },
          "patterns": [
            {
              "include": "#jsdoc"
            },
            {
              "include": "text.html.markdown#inline"
            }
          ]
        },
        {
          "begin": "\\s*(//)(?=\\s+|\\s*$)",
          "end": "\\s*$",
          "name": "comment.line.number-sign.trin",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.trin"
            }
          },
          "patterns": [
            {
              "include": "text.html.markdown#inline"
            }
          ]
        }
      ]
    },
    "nested-jsdoc": {
      "begin": "(/\\*\\*?)(?=\\s+|\\s*$)",
      "end": "\\s*(\\*/)",
      "name": "comment.block.documentation.nested.trin",
      "captures": {
        "1": {
          "name": "punctuation.definition.comment.trin"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc"
        },
        {
          "include": "text.html.markdown#inline"
        },
        {
          "include": "#nested-jsdoc"
        }
      ]
    },
    "nested-block": {
      "begin": "(/\\*)(?=\\s+|\\s*$)",
      "end": "\\s*(\\*/)",
      "name": "comment.block.nested.trin",
      "captures": {
        "1": {
          "name": "punctuation.definition.comment.trin"
        }
      },
      "patterns": [
        {
          "include": "text.html.markdown#inline"
        },
        {
          "include": "#nested-block"
        }
      ]
    },
    "jsdoc": {
      "patterns": [
        {
          "include": "#jsdoc-inline-tags"
        },
        {
          "include": "#jsdoc-access"
        },
        {
          "include": "#jsdoc-as-name-path"
        },
        {
          "include": "#jsdoc-simple"
        },
        {
          "include": "#jsdoc-simple-name-path"
        },
        {
          "include": "#jsdoc-module"
        },
        {
          "include": "#jsdoc-type-name"
        },
        {
          "include": "#jsdoc-type-no-name"
        },
        {
          "comment": "additional jsdoc V2 keywords",
          "match": "(?<!\\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\\b",
          "name": "storage.type.class.jsdoc"
        },
        {
          "comment": "additional jsdoc keywords",
          "match": "(?<!\\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\\b",
          "name": "storage.type.class.jsdoc"
        }
      ]
    },
    "jsdoc-access": {
      "comment": "@tag protected....",
      "match": "(@(access))\\s*(private|protected|public)?(?=\\s|$)",
      "captures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        },
        "3": {
          "name": "storage.modifier.jsdoc"
        }
      }
    },
    "jsdoc-module": {
      "comment": "@tag {optional type} module:file",
      "begin": "(@(exports|module|listens|requires)\\b)\\s*(?=({(?:(?>(?:[^\\\\{}]|\\\\.)+)|\\g<-1>)*\\})?\\s*(\\S*)([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\5$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "match": "(?:(module)(:))?(((?!\\*/)\\S)+)",
          "captures": {
            "1": {
              "name": "keyword.module.jsdoc"
            },
            "2": {
              "name": "punctuation.jsdoc"
            },
            "3": {
              "name": "string.modulename.jsdoc"
            }
          }
        }
      ]
    },
    "jsdoc-as-name-path": {
      "comment": "to terminate the block",
      "begin": "(@(borrows|lends)\\b)\\s*(?=(?!\\*/)\\S+(?:(?:\\s*\\bas\\b\\s*(?!\\*/)\\S+)?)?([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\3$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-name-path-scopes"
        }
      ]
    },
    "jsdoc-simple": {
      "comment": "@tag",
      "match": "(@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\\b)(?=$|\\s)",
      "captures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      }
    },
    "jsdoc-simple-name-path": {
      "comment": "@tag {opt type} Class#xxx or Class#Event:aaaa etc",
      "begin": "(@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\\b)\\s*(?=({(?:(?>(?:[^\\\\{}]|\\\\.)+)|\\g<-1>)*\\})?\\s*\\S*([\\S*\\s]*))",
      "end": "^|(?=\\*/)|(?=\\4$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "include": "#jsdoc-name-path-scopes"
        }
      ]
    },
    "jsdoc-type-name": {
      "comment": "@tag {optional type} name",
      "begin": "(@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|namespace|param|var)\\b)\\s*(?=({(?:(?>(?:[^\\\\{}]|\\\\.)+)|\\g<-1>)*\\})?\\s*(((\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\S)+)?([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\7$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "include": "#jsdoc-name-scopes"
        }
      ]
    },
    "jsdoc-type-no-name": {
      "comment": "@tag {types}",
      "begin": "(@(enum|exception|implements|private|protected|public|returns|return|throws|type)\\b)\\s*(?=({(?:(?>(?:[^\\\\{}]|\\\\.)+)|\\g<-1>)*\\})?\\s*([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\4$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        }
      ]
    },
    "jsdoc-inline-tags": {
      "name": "meta.tag.inline.jsdoc",
      "begin": "(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])?({)(?=@)",
      "end": "\\s*(})",
      "beginCaptures": {
        "1": {
          "name": "string.linktext.jsdoc"
        },
        "2": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "match": "(@(link|tutorial))\\b([^}]*)",
          "captures": {
            "1": {
              "name": "storage.type.class.jsdoc"
            },
            "3": {
              "name": "string.jsdoc"
            }
          }
        }
      ]
    },
    "jsdoc-typedef-scopes": {
      "name": "entity.name.type.instance.jsdoc",
      "begin": "{",
      "end": "}|^",
      "captures": {
        "0": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-primitives"
        },
        {
          "include": "#jsdoc-name-path-scopes"
        },
        {
          "include": "#jsdoc-typedef-obj"
        }
      ]
    },
    "jsdoc-typedef-primitives": {
      "match": "\\b(null|undefined|boolean|string|number)\\b",
      "captures": {
        "1": {
          "name": "support.type.builtin.primitive.jsdoc"
        }
      }
    },
    "jsdoc-typedef-obj": {
      "comment": "typedef object",
      "begin": "{",
      "end": "}|^",
      "captures": {
        "0": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-primitives"
        },
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b\\s*(:)",
          "captures": {
            "1": {
              "name": "variable.other.readwrite.jsdoc"
            }
          }
        },
        {
          "include": "#jsdoc-name-path-scopes"
        },
        {
          "include": "#jsdoc-typedef-obj"
        }
      ]
    },
    "jsdoc-name-scopes": {
      "patterns": [
        {
          "match": "((?!\\*/)[\\S&&[^\\[\\]\"']])+",
          "captures": {
            "0": {
              "name": "variable.other.jsdoc"
            }
          }
        },
        {
          "name": "variable.other.jsdoc",
          "begin": "\\[",
          "end": "\\]|^",
          "patterns": [
            {
              "include": "#jsdoc-string"
            },
            {
              "include": "#jsdoc-name-scopes"
            }
          ]
        }
      ]
    },
    "jsdoc-name-path-scopes": {
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*(?=[\\p{Pc}\\p{L}])",
          "captures": {
            "1": {
              "name": "keyword.as.jsdoc"
            }
          }
        },
        {
          "match": "\\s*(?:([\\p{Pc}\\p{L}&&\\P{Ll}]+\\w*)|([\\p{Pc}\\p{L}][\\w\\p{Pd}]*))(?=[\\s\\-~.#]|$)",
          "captures": {
            "1": {
              "name": "entity.name.class.jsdoc"
            },
            "2": {
              "name": "entity.name.function.jsdoc"
            }
          }
        },
        {
          "match": "(\\.)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.static.jsdoc"
            }
          }
        },
        {
          "match": "(\\#)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.instance.jsdoc"
            }
          }
        },
        {
          "match": "(~|-)([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.inner.jsdoc"
            }
          }
        },
        {
          "match": "(\\#)(event)(:)",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "keyword.event.jsdoc"
            },
            "3": {
              "name": "keyword.operator.jsdoc"
            }
          }
        },
        {
          "name": "string.method.jsdoc",
          "begin": "\\.(?=\"|')",
          "end": "(?=.)",
          "applyEndPatternLast": true,
          "patterns": [
            {
              "include": "#jsdoc-string"
            }
          ]
        }
      ]
    },
    "jsdoc-string": {
      "name": "string.jsdoc",
      "match": "\\\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'"
    },
    "calls": {
      "patterns": [
        {
          "name": "meta.function.call.trin",
          "match": "(?x)\n(?<=\n  \\s* # opening\n  (?:\\|{1,3}> | \\+>) # operator\n  \\s*\n)\n\\b\n(\n  # ignore all keywords\n  (?!\n    (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n    (?: # keywords\n      in|of|as|is|new\n      |to|til|thru|by|del\n      |unset|ref|and|or|xor|not\n      |var|val|func?|proc|type\n      |class|data|enum|mod\n      |iter|macro|inter|obj\n      |trait|style|elem|prop|mark\n      |go|defer|do|from|where|with\n      |if|elif|else|then|def\n      |for|each|loop|while\n      |try|throw|catch|after\n      |match|case|pass|fail|goto\n      |break|next|redo|retry\n      |return|yield|await|label\n      |use|show|hide|route\n      |debug|assert|check\n    )\n    (?!\\B|\\p{Pd}+\\b)\n  )\n  (?:\n    \\b\n    [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # identifier\n    \\b\n    (?: [!?]?\\.=? | [?!:]:=?) # qualified name separator\n  )*\n  [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # last part of identifier\n)\n\\b |\n(?<! # ignore qualified names\n  \\b (?: [?!]?\\.=? | [?!:]:=?) (?: \\b | ['\"`\\\\({\\[])\n)\n(?<=\n  (?:\n    # beginning of line\n    ^\n  | # or before a delimiter\n    [,;({\\[] \\s*\n  | # or before a sigil\n    [$:] \\s* \\b\n  | # key-value separator\n    ['\"`(){}\\[\\]\\w]: \\s\n  | # operator\n    (?:^ | ['\"`(){}\\[\\]\\s\\w] | \\\\.) # anchor\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  | # open/close bracket\n    (?:['\"`(){}\\[\\]] | \\\\.)\n    (?: [?!]?\\.=? | [?!:]:=?) # accessors\n  | # command syntax\n    //? \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n  | (?:\n      (?:^|[,;'\"`(){}\\[\\]\\s]|\\\\.) # beside a delimiter or space\n      \\b\n        (?:# keywords\n          in|of|as|is|new\n          |to|til|thru|by|del\n          |unset|ref|and|or|xor|not\n          |var|val|func?|proc|type\n          |class|data|enum|mod\n          |iter|macro|inter|obj\n          |trait|style|elem|prop|mark\n          |go|defer|do|from|where|with\n          |if|elif|else|then|def\n          |for|each|loop|while\n          |try|throw|catch|after\n          |match|case|pass|fail|goto\n          |break|next|redo|retry\n          |return|yield|await|label\n          |use|show|hide|route\n          |debug|assert|check\n        )\n      \\b\n      (?:$|[,;'\"`(){}\\[\\]\\\\\\s]) # beside a delimiter or space\n    )\n  ) \\s* # before a space\n)\n\\b\n(\n  # ignore all keywords\n  (?!\n    (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n    (?: # keywords\n      in|of|as|is|new\n      |to|til|thru|by|del\n      |unset|ref|and|or|xor|not\n      |var|val|func?|proc|type\n      |class|data|enum|mod\n      |iter|macro|inter|obj\n      |trait|style|elem|prop|mark\n      |go|defer|do|from|where|with\n      |if|elif|else|then|def\n      |for|each|loop|while\n      |try|throw|catch|after\n      |match|case|pass|fail|goto\n      |break|next|redo|retry\n      |return|yield|await|label\n      |use|show|hide|route\n      |debug|assert|check\n    )\n    (?!\\B|\\p{Pd}+\\b)\n  )\n  (?:\n    \\b\n    [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # identifier\n    \\b\n    (?: [!?]?\\.=? | [?!:]:=?) # qualified name separator\n  )*\n  [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # last part of identifier\n)\n\\b\n(?=\n  \\s+\n  (?:\n      # prefix operator literal\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n      ['\"`({\\[]\n    | # array literal\n      \\[\n    | # ignore orphaned qualified name\n      (?!\n        (?: [?!]?\\.=? | [?!:]:=?)\n        ['\"`\\\\({\\[\\w]\n      )\n      # prefix operator\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*\n      (?:\n        # ignore all keywords\n        (?!\n          (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n          (?: # keywords\n            in|of|as|is|new\n            |to|til|thru|by|del\n            |unset|ref|and|or|xor|not\n            |var|val|func?|proc|type\n            |class|data|enum|mod\n            |iter|macro|inter|obj\n            |trait|style|elem|prop|mark\n            |go|defer|do|from|where|with\n            |if|elif|else|then|def\n            |for|each|loop|while\n            |try|throw|catch|after\n            |match|case|pass|fail|goto\n            |break|next|redo|retry\n            |return|yield|await|label\n            |use|show|hide|route\n            |debug|assert|check\n          )\n          (?!\\B|\\p{Pd}+\\b)\n        )\n        (?:\n          \\b\n          [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # identifier\n          \\b\n          (?: [!?]?\\.=? | [?!:]:=?) # qualified name separator\n        )*\n        [\\p{Pc}\\p{L}][\\w\\p{Pd}]* # last part of identifier\n      )\n      (?: # closing bracket\n          [,;'\"`(){}\\[\\]\\s]\n        | # operator\n          [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n        | # end of line\n          $\n      )\n  )\n  | \\s* # optional space\n  (?: # command or string literal\n      (?: \\\\ | //? \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* )\n    | # function application, composition and piping\n      (?: \\$ | \\s \\. | <\\|{1,3}| <\\+) [\\s\\w]\n    | # no-argument call\n      \\b! (?:[,;'\"`)}\\]\\s] | $)\n    | # C-style function call\n      (?:[!?]\\.=?|\\.=)? \\#?\\(\n    | # generics\n      (?:[!?]\\.=?|\\.=)? < ['\"`\\\\({\\[\\w]\n    | # string literal or expression\n      ['\"`(]\n  )\n)\n",
          "captures": {
            "1": {
              "patterns": [
                {
                  "include": "#function-names"
                }
              ]
            },
            "2": {
              "patterns": [
                {
                  "include": "#function-names"
                }
              ]
            }
          }
        }
      ]
    },
    "embedded-calls": {
      "patterns": [
        {
          "name": "meta.function.name.trin",
          "match": "(?x)\n(?:\n  (?<=[!?]?\\.=?|[?!:]:=?) (?<! \\.\\.+) \\b\n    (?: # Properties\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n    )\n  \\b\n    (?= \\#? \\( ) # opening bracket\n  |\n  (?<= ^ # beginning of line\n    | ['\"`(){}\\[\\]\\s\\w] # literal\n    (?: # operators\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n    )?\n  ) \\b\n    (?: # Regular variables\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n    )\n  \\b\n    (?= \\#? \\( ) # opening bracket\n)\n",
          "captures": {
            "1": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.tag.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.tag.trin support.class.component.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.class.builtin.trin"
            },
            "4": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.method.trin"
            },
            "5": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.tagged-template.trin"
            },
            "6": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.type.trin"
            },
            "7": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.class.trin"
            },
            "8": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.trin"
            }
          }
        }
      ]
    },
    "function-names": {
      "patterns": [
        {
          "name": "meta.function.name.trin",
          "match": "(?x)\n(?:\n  (?<=[!?]?\\.=?|[?!:]:=?) (?<! \\.\\.+) \\b\n    (?: # Properties\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n    )\n  \\b\n    (?= $  # end of line\n      | (?: # operators\n        <\\|{1,3} | <\\+ | \\|{1,3}> | \\+> | ![:.]=? | [!$] | \\s\\.\n      ) ['\"`(){}\\[\\]\\s\\w]\n    )\n  |\n  (?<= ^ # beginning of line\n    | (?: ^ | ['\"`(){}\\[\\]\\s\\w] | \\\\. ) # literal\n    (?: # operators\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n    )?\n  ) \\b\n    (?: # Regular variables\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n    )\n  \\b\n    (?= $ # end of line\n      | (?: # operators\n        [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n        <\\|{1,3} | <\\+ | \\|{1,3}> | \\+> | ![:.]=? | [!$] | \\s\\.\n      )? ['\"`(){}\\[\\]\\s\\w]\n    )\n)\n",
          "captures": {
            "1": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.tag.trin"
            },
            "2": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.tag.trin support.class.component.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.class.builtin.trin"
            },
            "4": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.method.trin"
            },
            "5": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.tagged-template.trin"
            },
            "6": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.type.trin"
            },
            "7": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.class.trin"
            },
            "8": {
              "patterns": [
                {
                  "include": "#type-names"
                },
                {
                  "include": "#support-functions"
                }
              ],
              "name": "entity.name.function.trin"
            }
          }
        },
        {
          "include": "#variables"
        },
        {
          "include": "#infix-operators"
        }
      ]
    },
    "placeholder-variables": {
      "patterns": [
        {
          "match": "(?i)\\s*\\?[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.optional.trin"
        },
        {
          "match": "(?i)\\s*\\*\\??[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.spread.trin"
        },
        {
          "match": "(?i)\\s*//?\\??[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.name.trin"
        },
        {
          "match": "(?i)\\s*&\\??[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.reference.trin"
        },
        {
          "match": "(?i)\\s*%\\??[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.other.trin"
        },
        {
          "match": "(?i)\\s*\\b[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b\\s*",
          "name": "variable.parameter.trin"
        }
      ]
    },
    "variables": {
      "comment": "Four types of variables:\n- _lead_underscore\n- UPPERCASE\n- PascalCase\n- camelCase\n",
      "match": "(?x) \\b\n\n(?:\n  (?<= [!?]?\\.=? | [?!:]:=?) (?<! \\.\\.+)\n  (?: # Properties\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n  |\n  (?: # Objects\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n  (?! \\.\\.+) (?= [!?]?\\.=? | [?!:]:=? | \\#?\\[)\n  |\n  (?: # Regular variables\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n)\\b\n",
      "captures": {
        "1": {
          "name": "variable.other.index.trin"
        },
        "2": {
          "name": "variable.other.constant.property.trin"
        },
        "3": {
          "name": "variable.other.property.static.trin"
        },
        "4": {
          "name": "variable.other.property.trin"
        },
        "5": {
          "name": "variable.other.global.trin"
        },
        "6": {
          "name": "variable.other.constant.object.trin"
        },
        "7": {
          "name": "variable.other.conditional.trin"
        },
        "8": {
          "name": "variable.other.object.trin"
        },
        "9": {
          "name": "variable.other.dollar.trin"
        },
        "10": {
          "name": "variable.other.constant.trin"
        },
        "11": {
          "name": "variable.other.class.trin"
        },
        "12": {
          "name": "variable.other.readwrite.trin"
        }
      }
    },
    "operators": {
      "patterns": [
        {
          "include": "#primary-operators"
        },
        {
          "include": "#infix-operators"
        },
        {
          "include": "#suffix-operators"
        },
        {
          "include": "#prefix-operators"
        }
      ]
    },
    "special-operators": {
      "patterns": [
        {
          "begin": "(?<=^|\\s)(\\?)(?=\\s|$)",
          "end": "(?<=^|\\s)(:)(?=\\s|$)",
          "captures": {
            "1": {
              "name": "keyword.operator.conditional.trin"
            }
          },
          "patterns": [
            {
              "begin": "\\s*(?=([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\s*:)",
              "end": "\\s*(?=:\\s|$)",
              "patterns": [
                {
                  "include": "#constants"
                },
                {
                  "include": "#variables"
                }
              ]
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=^|\\s)(\\!)(?=\\s|$)",
          "end": "(?<=^|\\s)(:)(?=\\s|$)",
          "captures": {
            "1": {
              "name": "keyword.operator.ternary.trin"
            }
          },
          "patterns": [
            {
              "begin": "\\s*(?=([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\s*:)",
              "end": "\\s*(?=:\\s|$)",
              "patterns": [
                {
                  "include": "#constants"
                },
                {
                  "include": "#variables"
                }
              ]
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=^|\\s)(\\$)(?=\\s|$)",
          "end": "(?<=^|\\s)(:)(?=\\s|$)",
          "captures": {
            "1": {
              "name": "keyword.operator.macro.dollar.trin"
            }
          },
          "patterns": [
            {
              "begin": "\\s*(?=([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\s*:)",
              "end": "\\s*(?=:\\s|$)",
              "name": "entity.name.function.trin"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "infix-operators": {
      "patterns": [
        {
          "name": "keyword.operator.infix.trin",
          "match": "(?xi)\n(?<=^|[\\s({\\[]) # opening\n(?:\n  ( # 1: compound assignment operators\n    # all operators except ~ < = > . : !\n    [\\p{S}\\p{P}&&[^~<=>.,:;!'\"`(){}\\[\\]\\p{Pc}]]\n    # operator character\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*\n    = # ending equal sign\n  ) |\n  ( # 2: arithmetic operator\n    \\+ | - | \\*{1,3} | //? | %%?\n  ) |\n  ( # 3: string / regex\n    \\+\\+ | --\n  ) |\n  ( # 4: logical operator\n    \\&\\& | \\|\\| | \\^\\^ | !\n  ) |\n  ( # 5: bitwise and set\n    \\& | \\| | \\^ | ~\n  ) |\n  ( # 6: bitwise shift\n    <<<? | >>>?\n  ) |\n  ( # 7: pipeline\n    <\\|{1,3} | \\|{1,3}>\n  ) |\n  ( # 8: composition\n    <\\+ | \\+>\n  ) |\n  ( # 9: membership\n    [<>][:!] | [:!][<>]\n  ) |\n  ( # 10: comparison\n    < | > | <= | >= | <> | <=>\n  ) |\n  ( # 11: equality\n    == | != | === | !==\n  ) |\n  ( # 12: similarity\n    ~[=!] | [=!]~ | =<\n  ) |\n  ( # 13: functional\n    <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]\n  ) |\n  ( # 14: null coalescing\n    \\?+\n  ) |\n  ( # 15: non null coalescing\n    !+\n  ) |\n  ( # 16: falsy coalescing\n    \\?:\n  ) |\n  ( # 17: truthy coalescing\n    !:\n  ) |\n  ( # 18: function application\n    [.$]\n  ) |\n  ( # 19: assignment\n    :?=\n  ) |\n  ( # 20: range\n    [>.]\\.[.<]\n  ) |\n  ( # 21: fat arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* => # right side\n    | <= [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 22: skinny arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* -> # right side\n    | <- [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 23: wavy arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* ~> # right side\n    | <~ [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 24: custom logical\n    [&|^~] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 25: custom arithmetic\n    [-+*/%] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 26: custom prototype\n    [@:] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 27: custom accessor\n    [.] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 28: custom comparison\n    [=!] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 29: custom relational\n    [<>] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 30: custom private\n    [?\\#] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 31: custom math\n    \\p{Sm} # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 32: custom currency\n    \\p{Sc} # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 33: custom ascii\n    [\\p{S}\\p{P}&&[\\x80-\\xFF]] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 34: catch all\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  )\n)\n(?=$|[)}\\]\\s]) # closing\n",
          "captures": {
            "1": {
              "name": "keyword.operator.assignment.augmented.trin"
            },
            "2": {
              "name": "keyword.operator.arithmetic.trin"
            },
            "3": {
              "name": "keyword.operator.successor.trin"
            },
            "4": {
              "name": "keyword.operator.logical.trin"
            },
            "5": {
              "name": "keyword.operator.bitwise.trin"
            },
            "6": {
              "name": "keyword.operator.bitwise.shift.trin"
            },
            "7": {
              "name": "keyword.operator.pipeline.trin"
            },
            "8": {
              "name": "keyword.operator.compose.trin"
            },
            "9": {
              "name": "keyword.operator.class.trin"
            },
            "10": {
              "name": "keyword.operator.relational.trin"
            },
            "11": {
              "name": "keyword.operator.comparison.trin"
            },
            "12": {
              "name": "keyword.operator.similarity.trin"
            },
            "13": {
              "name": "keyword.operator.function.trin"
            },
            "14": {
              "name": "keyword.operator.null-coalescing.trin"
            },
            "15": {
              "name": "keyword.operator.coalescing.trin"
            },
            "16": {
              "name": "keyword.operator.conditional.trin"
            },
            "17": {
              "name": "keyword.operator.ternary.trin"
            },
            "18": {
              "name": "keyword.operator.macro.trin"
            },
            "19": {
              "name": "keyword.operator.assignment.trin"
            },
            "20": {
              "name": "keyword.operator.range.trin"
            },
            "21": {
              "name": "keyword.operator.arrow.fat.trin"
            },
            "22": {
              "name": "keyword.operator.arrow.skinny.trin"
            },
            "23": {
              "name": "keyword.operator.arrow.wavy.trin"
            },
            "24": {
              "name": "keyword.operator.logical.custom.trin"
            },
            "25": {
              "name": "keyword.operator.arithmetic.custom.trin"
            },
            "26": {
              "name": "keyword.operator.prototype.custom.trin"
            },
            "27": {
              "name": "keyword.operator.accessor.custom.trin"
            },
            "28": {
              "name": "keyword.operator.comparison.custom.trin"
            },
            "29": {
              "name": "keyword.operator.relational.custom.trin"
            },
            "30": {
              "name": "keyword.operator.private.custom.trin"
            },
            "31": {
              "name": "keyword.operator.math.custom.trin"
            },
            "32": {
              "name": "keyword.operator.currency.custom.trin"
            },
            "33": {
              "name": "keyword.operator.ascii.custom.trin"
            },
            "34": {
              "name": "keyword.operator.infix.trin"
            }
          }
        },
        {
          "name": "keyword.operator.primary.trin",
          "match": "(?x)\n(?<=['\"`)}\\]\\w]|\\\\.) # closing\n(?:\n  ( # 1: optional accessor\n  \\?[.:]=?\n  ) |\n  ( # 2: assertion/call operator\n    ![.:]=?\n  ) |\n  ( # 3: accessor operator\n    (?:::|\\.)=?\n  ) |\n  ( # 4: compound assignment operators\n    # all operators except ~ < = > . : !\n    [\\p{S}\\p{P}&&[^~<=>.,:;!'\"`(){}\\[\\]\\p{Pc}]]\n    # operator character\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*\n    = # ending equal sign\n  ) |\n  ( # 5: arithmetic operator\n    \\+ | - | \\*{1,3} | //? | %%?\n  ) |\n  ( # 6: string / regex\n    \\+\\+ | --\n  ) |\n  ( # 7: logical operator\n    \\&\\& | \\|\\| | \\^\\^ | !\n  ) |\n  ( # 8: bitwise and set\n    \\& | \\| | \\^ | ~\n  ) |\n  ( # 9: bitwise shift\n    <<<? | >>>?\n  ) |\n  ( # 10: pipeline\n    <\\|{1,3} | \\|{1,3}>\n  ) |\n  ( # 11: composition\n    <\\+ | \\+>\n  ) |\n  ( # 12: membership\n    [<>][:!] | [:!][<>]\n  ) |\n  ( # 13: comparison\n    < | > | <= | >= | <> | <=>\n  ) |\n  ( # 14: equality\n    == | != | === | !==\n  ) |\n  ( # 15: similarity\n    ~[=!] | [=!]~ | =<\n  ) |\n  ( # 16: functional\n    <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]\n  ) |\n  ( # 17: null coalescing\n    \\?+\n  ) |\n  ( # 18: non null coalescing\n    !+\n  ) |\n  ( # 19: falsy coalescing\n    \\?:\n  ) |\n  ( # 20: truthy coalescing\n    !:\n  ) |\n  ( # 21: function application\n    [.$]\n  ) |\n  ( # 22: assignment\n    :?=\n  ) |\n  ( # 23: range\n    [>.]\\.[.<]\n  ) |\n  ( # 24: fat arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* => # right side\n    | <= [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 25: skinny arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* -> # right side\n    | <- [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 26: wavy arrow\n      [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* ~> # right side\n    | <~ [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]* # left side\n  ) |\n  ( # 27: custom logical\n    [&|^~] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 28: custom arithmetic\n    [-+*/%] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 29: custom prototype\n    [@:] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 30: custom accessor\n    [.] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 31: custom comparison\n    [=!] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 32: custom relational\n    [<>] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 33: custom private\n    [?\\#] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 34: custom math\n    \\p{Sm} # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 35: custom currency\n    \\p{Sc} # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 36: custom ascii\n    [\\p{S}\\p{P}&&[\\x80-\\xFF]] # leading chars\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  ) |\n  ( # 37: catch all\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  )\n)\n(?=['\"`\\\\({\\[\\w]) # opening\n",
          "captures": {
            "1": {
              "name": "keyword.operator.optional.trin"
            },
            "2": {
              "name": "keyword.operator.assert.trin"
            },
            "3": {
              "name": "keyword.operator.accessor.trin"
            },
            "4": {
              "name": "keyword.operator.assignment.augmented.trin"
            },
            "5": {
              "name": "keyword.operator.arithmetic.trin"
            },
            "6": {
              "name": "keyword.operator.successor.trin"
            },
            "7": {
              "name": "keyword.operator.logical.trin"
            },
            "8": {
              "name": "keyword.operator.bitwise.trin"
            },
            "9": {
              "name": "keyword.operator.bitwise.shift.trin"
            },
            "10": {
              "name": "keyword.operator.pipeline.trin"
            },
            "11": {
              "name": "keyword.operator.compose.trin"
            },
            "12": {
              "name": "keyword.operator.class.trin"
            },
            "13": {
              "name": "keyword.operator.relational.trin"
            },
            "14": {
              "name": "keyword.operator.comparison.trin"
            },
            "15": {
              "name": "keyword.operator.similarity.trin"
            },
            "16": {
              "name": "keyword.operator.function.trin"
            },
            "17": {
              "name": "keyword.operator.null-coalescing.trin"
            },
            "18": {
              "name": "keyword.operator.coalescing.trin"
            },
            "19": {
              "name": "keyword.operator.conditional.trin"
            },
            "20": {
              "name": "keyword.operator.ternary.trin"
            },
            "21": {
              "name": "keyword.operator.macro.trin"
            },
            "22": {
              "name": "keyword.operator.assignment.trin"
            },
            "23": {
              "name": "keyword.operator.range.trin"
            },
            "24": {
              "name": "keyword.operator.arrow.fat.trin"
            },
            "25": {
              "name": "keyword.operator.arrow.skinny.trin"
            },
            "26": {
              "name": "keyword.operator.arrow.wavy.trin"
            },
            "27": {
              "name": "keyword.operator.logical.custom.trin"
            },
            "28": {
              "name": "keyword.operator.arithmetic.custom.trin"
            },
            "29": {
              "name": "keyword.operator.prototype.custom.trin"
            },
            "30": {
              "name": "keyword.operator.accessor.custom.trin"
            },
            "31": {
              "name": "keyword.operator.comparison.custom.trin"
            },
            "32": {
              "name": "keyword.operator.relational.custom.trin"
            },
            "33": {
              "name": "keyword.operator.private.custom.trin"
            },
            "34": {
              "name": "keyword.operator.math.custom.trin"
            },
            "35": {
              "name": "keyword.operator.currency.custom.trin"
            },
            "36": {
              "name": "keyword.operator.ascii.custom.trin"
            },
            "37": {
              "name": "keyword.operator.primary.trin"
            }
          }
        }
      ]
    },
    "prefix-operators": {
      "comment": "Prefix operators",
      "match": "(?x)\n(?:\n  ([*/]) # 1\n  |(\\+) # 2\n  |(\\-) # 3\n  |(\\&) # 4\n  |(\\|) # 5\n  |(\\^) # 6\n  |(\\!) # 7\n  |(\\$) # 8\n  |(\\@) # 9\n  |(\\~) # 10\n  |(\\?) # 11\n  |(\\=) # 12\n  |(\\$) # 13\n  |(\\#) # 14\n  |[\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]\n) # 15\n(?=[\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*\n['\"`\\\\({\\[\\w])\n",
      "name": "keyword.operator.prefix.trin",
      "captures": {
        "1": {
          "name": "keyword.operator.module.all.trin"
        },
        "2": {
          "name": "keyword.operator.increment.trin"
        },
        "3": {
          "name": "keyword.operator.decrement.trin"
        },
        "4": {
          "name": "keyword.operator.intersection.trin"
        },
        "5": {
          "name": "keyword.operator.union.trin"
        },
        "6": {
          "name": "keyword.operator.symmetric.trin"
        },
        "7": {
          "name": "keyword.operator.logical.trin"
        },
        "8": {
          "name": "keyword.operator.private.trin"
        },
        "9": {
          "name": "keyword.operator.decorator.trin"
        },
        "10": {
          "name": "keyword.operator.bitwise.not.trin"
        },
        "11": {
          "name": "keyword.operator.existential.trin"
        },
        "12": {
          "name": "keyword.operator.assignment.trin"
        },
        "13": {
          "name": "keyword.operator.pipeline.trin"
        },
        "14": {
          "name": "keyword.operator.private.trin"
        },
        "15": {
          "name": "keyword.operator.prefix.trin"
        }
      }
    },
    "suffix-operators": {
      "comment": "Suffix operators",
      "match": "(?x)\n(?<=(?:['\"`)}\\]\\w]|\\\\.)\n  [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*)\n(?:\n  ([*/]) # 1\n  |(\\+) # 2\n  |(\\-) # 3\n  |(\\&) # 4\n  |(\\|) # 5\n  |(\\^) # 6\n  |(\\!) # 7\n  |(\\$) # 8\n  |(\\@) # 9\n  |(\\~) # 10\n  |(\\?) # 11\n  |(\\=) # 12\n  |(\\$) # 13\n  |(\\#) # 14\n  |[\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]\n) # 15\n",
      "name": "keyword.operator.suffix.trin",
      "captures": {
        "1": {
          "name": "keyword.operator.module.all.trin"
        },
        "2": {
          "name": "keyword.operator.increment.trin"
        },
        "3": {
          "name": "keyword.operator.decrement.trin"
        },
        "4": {
          "name": "keyword.operator.intersection.trin"
        },
        "5": {
          "name": "keyword.operator.union.trin"
        },
        "6": {
          "name": "keyword.operator.symmetric.trin"
        },
        "7": {
          "name": "keyword.operator.assert.trin"
        },
        "8": {
          "name": "keyword.operator.private.trin"
        },
        "9": {
          "name": "keyword.operator.decorator.trin"
        },
        "10": {
          "name": "keyword.operator.bitwise.trin"
        },
        "11": {
          "name": "keyword.operator.optional.trin"
        },
        "12": {
          "name": "keyword.operator.assignment.trin"
        },
        "13": {
          "name": "keyword.operator.pipeline.trin"
        },
        "14": {
          "name": "keyword.operator.private.trin"
        },
        "15": {
          "name": "keyword.operator.suffix.trin"
        }
      }
    },
    "types": {
      "patterns": [
        {
          "include": "#angle-brackets"
        },
        {
          "include": "#type-strings"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#params-clause"
        },
        {
          "include": "#type-keywords"
        },
        {
          "include": "#type-names"
        },
        {
          "include": "#type-variables"
        },
        {
          "include": "#type-operators"
        },
        {
          "include": "#type-brackets"
        },
        {
          "match": "\\s+",
          "name": "meta.type.trin"
        }
      ]
    },
    "type-variables": {
      "comment": "Four types of variables:\n- _lead_underscore\n- UPPERCASE\n- PascalCase\n- camelCase\n",
      "match": "(?x) \\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n(?:\n  (?<= [!?]?\\.=? | [?!:]:=?) (?<! \\.\\.+)\n  (?: # Properties\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n  |\n  (?: # Objects\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n  (?! \\.\\.+) (?= [!?]?\\.=? | [?!:]:=? | \\#?\\[)\n  |\n  (?: # Regular variables\n      # leading or trailing underscore\n      (\\p{Pc}+[\\p{Pc}\\p{L}][\\w\\p{Pd}]*\\b(?!\\p{Pc}+))\n    | # all uppercase or first word uppercase\n      ([\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*\\p{Pd}[\\w\\p{Pd}]*|[\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Ll}]*)\n    | # Pascal case\n      ((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\n    | # Camel case\n      ([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n  )\n)\\b\n",
      "captures": {
        "1": {
          "name": "entity.name.module.trin"
        },
        "2": {
          "name": "entity.name.tag.trin"
        },
        "3": {
          "name": "entity.name.namespace.trin"
        },
        "4": {
          "name": "entity.name.interface.trin"
        },
        "5": {
          "name": "entity.name.tag.block.trin"
        },
        "6": {
          "name": "entity.name.tag.script.trin"
        },
        "7": {
          "name": "entity.name.tag.style.trin"
        },
        "8": {
          "name": "entity.name.tag.inline.trin"
        },
        "9": {
          "name": "entity.name.label.trin"
        },
        "10": {
          "name": "entity.name.project.trin"
        },
        "11": {
          "name": "entity.name.class.trin"
        },
        "12": {
          "name": "entity.name.type.trin"
        }
      }
    },
    "type-annotation": {
      "applyEndPatternLast": true,
      "name": "meta.type.trin",
      "begin": "(:)(?=$|[\\w\\s'\"`({\\[])",
      "end": "(?=)|$",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.annotation.trin"
        }
      },
      "patterns": [
        {
          "include": "#types"
        },
        {
          "match": "\\s+",
          "name": "meta.type.trin"
        }
      ]
    },
    "type-embedded-expression": {
      "begin": "(\\${)\\s*",
      "end": "\\s*(})",
      "name": "entity.quasi.component.trin",
      "captures": {
        "1": {
          "name": "punctuation.section.embedded.trin"
        }
      },
      "patterns": [
        {
          "include": "#types"
        },
        {
          "include": "$self"
        }
      ]
    },
    "type-strings": {
      "comment": "coming soon",
      "patterns": [
        {
          "comment": "single quoted raw string",
          "begin": "(?<!'+)\\s*('''+)",
          "contentName": "string.quoted.single.trin",
          "end": "\\s*((\\1)(?!'+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#type-embedded-verbatim"
            }
          ]
        },
        {
          "comment": "simple single quoted raw string",
          "begin": "(?<!'+)\\s*(')",
          "contentName": "string.quoted.single.trin",
          "end": "\\s*((\\1)(?!'+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "match": "''",
              "name": "constant.character.escape.trin"
            },
            {
              "include": "#type-embedded-verbatim"
            }
          ]
        },
        {
          "comment": "double quoted standard string",
          "begin": "(?<!\"+)\\s*(\"\"\"+)",
          "contentName": "string.quoted.double.trin",
          "end": "\\s*((\\1)(?!\"+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#string-escapes"
            },
            {
              "include": "#type-embedded"
            }
          ]
        },
        {
          "comment": "double quoted standard string",
          "begin": "(?<!\"+)\\s*(\")",
          "contentName": "string.quoted.double.trin",
          "end": "\\s*((\\1)(?!\"+))",
          "captures": {
            "1": {
              "name": "punctuation.definition.string.trin"
            }
          },
          "patterns": [
            {
              "include": "#string-escapes"
            },
            {
              "include": "#type-embedded"
            }
          ]
        }
      ]
    },
    "type-embedded": {
      "patterns": [
        {
          "include": "#format-specifier"
        },
        {
          "include": "#embedded-placeholder"
        },
        {
          "include": "#type-embedded-expression"
        }
      ]
    },
    "type-embedded-verbatim": {
      "patterns": [
        {
          "match": "\\$\\$|\\%\\%|\\#\\#",
          "name": "constant.character.escape.trin"
        },
        {
          "include": "#format-specifier"
        },
        {
          "include": "#embedded-placeholder"
        },
        {
          "include": "#type-embedded-expression"
        }
      ]
    },
    "type-brackets": {
      "patterns": [
        {
          "include": "#type-curly-brackets"
        },
        {
          "include": "#type-square-brackets"
        },
        {
          "include": "#type-round-brackets"
        }
      ]
    },
    "type-curly-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.mapping.trin"
            },
            {
              "match": "(?<=(?:['\"`)}\\]\\w]|\\\\.)[\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*):(?=['\"`\\\\({\\[\\w\\s]|$)",
              "name": "punctuation.separator.key-value.trin"
            },
            {
              "match": "(?<=^\\s*|[,;{]\\s*)(?:[-+*]\\s+)*[-+*](?=\\s|$)",
              "name": "punctuation.definition.block.sequence.item.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "\\s*(?<=[\\w'\"`)}\\]]|[^.]\\.=?|[?!:]:=?)(\\#?\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.typeparameters.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.object.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=(?:^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):)\\s*\\|\\s*\\||^\\s*\\|)\\s*(\\#\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.section.class.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=(?:^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):)\\s*\\|\\s*\\||^\\s*\\|)\\s*(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.block.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\s*|[\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+)\\s*(\\#\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.mapping.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\s*|[\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+)\\s*(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.dictionary.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "type-round-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.arguments.trin"
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "match": "(?<=[\\w\\s][(|])\\.",
              "name": "punctuation.definition.metadata.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "\\s*(?<=[\\w'\"`)}\\]>]|[^.]\\.=?|[?!:]:=?)(\\#?\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.parameters.trin"
            }
          },
          "patterns": [
            {
              "include": "#punctuation"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "#types"
            },
            {
              "include": "self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.tuple.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(\\#?\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.expression.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "type-square-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "\\s*(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.array.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(?<=[\\w'\"`)}\\]]|[^.]\\.=?|[?!:]:=?)(\\#?\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.attribute-selector.trin"
            }
          },
          "patterns": [
            {
              "include": "#punctuation"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(\\#\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.sequence.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "\\s*(\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.array.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            },
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "type-keywords": {
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(ext)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.extends.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(impl)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.implements.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(infer|as|is)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.$1.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(type|name|size|key)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.$1of.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(inst)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.instanceof.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(val)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.valueof.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(attr)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.attributeof.trin"
        }
      ]
    },
    "type-operators": {
      "patterns": [
        {
          "match": "\\s*(==?>|--?>|~~?>)",
          "name": "keyword.operator.type.function.trin"
        },
        {
          "match": "\\s*(<==|<--?|<~~?)",
          "name": "keyword.operator.type.channel.trin"
        },
        {
          "comment": "Function types",
          "match": "(?:^|\\s+)(?:(\\|)|(>))(?=['\"`({\\[\\w])|(?<=['\"`)}\\]\\w])(?:(\\|)|(<))(?:$|\\s+)",
          "captures": {
            "1": {
              "name": "keyword.operator.type.function.trin"
            },
            "2": {
              "name": "keyword.operator.type.channel.trin"
            },
            "3": {
              "name": "keyword.operator.type.function.trin"
            },
            "4": {
              "name": "keyword.operator.type.channel.trin"
            }
          }
        },
        {
          "comment": "Primary binary operators",
          "match": "(?<=['\"`)}\\]\\w])(?:([>.]\\.[.<])|(\\?[.:]=?)|(![.:]=?)|((?:::|\\.)=?))(?=['\"`\\\\({\\[\\w])",
          "captures": {
            "1": {
              "name": "keyword.operator.range.trin"
            },
            "2": {
              "name": "keyword.operator.optional.trin"
            },
            "3": {
              "name": "keyword.operator.assert.trin"
            },
            "4": {
              "name": "keyword.operator.accessor.trin"
            }
          }
        },
        {
          "comment": "type operators",
          "match": "\\s*(?:(\\+)|(\\-)|(\\*)|(/)|(\\%)|(\\!)|(\\?)|(\\&)|(\\|)|(\\^)|(\\~)|(\\$)|([<>]))(?=$|[({\\[\\w'\"\\s])",
          "captures": {
            "1": {
              "name": "keyword.operator.sum.trin"
            },
            "2": {
              "name": "keyword.operator.difference.trin"
            },
            "3": {
              "name": "keyword.operator.product.trin"
            },
            "4": {
              "name": "keyword.operator.quotient.trin"
            },
            "5": {
              "name": "keyword.operator.remainder.trin"
            },
            "6": {
              "name": "keyword.operator.only.trin"
            },
            "7": {
              "name": "keyword.operator.maybe.trin"
            },
            "8": {
              "name": "keyword.operator.intersection.trin"
            },
            "9": {
              "name": "keyword.operator.union.trin"
            },
            "10": {
              "name": "keyword.operator.symmetric.trin"
            },
            "11": {
              "name": "keyword.operator.negation.trin"
            },
            "12": {
              "name": "keyword.operator.macro.dollar.trin"
            },
            "13": {
              "name": "keyword.operator.class.trin"
            }
          }
        }
      ]
    },
    "block-entities": {
      "patterns": [
        {
          "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\.|::)",
          "name": "entity.name.namespace.trin"
        },
        {
          "applyEndPatternLast": true,
          "begin": "\\s+(impl)\\s+",
          "end": "(?=.)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.implements.trin"
            }
          },
          "patterns": [
            {
              "match": "\\.|::",
              "name": "punctuation.separator.namespace.trin"
            },
            {
              "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\.|::)",
              "name": "entity.name.namespace.trin"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.trait.trin"
            },
            {
              "include": "#comma"
            },
            {
              "include": "#line-continuation"
            }
          ]
        },
        {
          "applyEndPatternLast": true,
          "begin": "\\s+(ext)\\s+",
          "end": "(?=.)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.extends.trin"
            }
          },
          "patterns": [
            {
              "match": "\\.|::",
              "name": "punctuation.separator.namespace.trin"
            },
            {
              "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=\\.|::)",
              "name": "entity.name.module.trin"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.interface.trin"
            },
            {
              "include": "#comma"
            },
            {
              "include": "#line-continuation"
            }
          ]
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#type-keywords"
        },
        {
          "include": "#type-square-brackets"
        },
        {
          "include": "#parameter-brackets"
        },
        {
          "include": "#round-brackets"
        },
        {
          "include": "#type-annotation"
        },
        {
          "match": "\\s*(?<!\\*)\\*(?!\\*)\\s*",
          "name": "keyword.generator.asterisk.trin"
        },
        {
          "include": "#regexps"
        },
        {
          "include": "#strings"
        },
        {
          "include": "#symbols"
        },
        {
          "include": "#constants"
        },
        {
          "applyEndPatternLast": true,
          "begin": "\\s*(:)(?:(?=::)|(?![\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]))",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.annotation.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            }
          ]
        },
        {
          "include": "#comments"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#comma"
        },
        {
          "include": "#line-continuation"
        },
        {
          "match": "\\.|::",
          "name": "punctuation.separator.namespace.trin"
        },
        {
          "match": "\\s+",
          "name": "meta.block.trin"
        }
      ]
    },
    "modifier-keywords": {
      "match": "(?x)\n(\n  (?:\n    (?:\n      \\s*\n      (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\n      \\b\n        (?:\n          pub|priv|prot|final|immut|mut|over\n          |glo|loc|intern|extern|imply|exply\n          |post|[gs]et|rem\n\n          |seal|abst|impure|pure|early|late\n          |covar|contra|a?sync|stat|dyn|lazy\n          |eager|bound|free|unique|struct\n\n          |rec|oper|curry|inline\n          |pre|suf|inf|left|right\n        )\n      )\n      (?!\\B|\\p{Pd}+\\b)\n    \\s*\n  )*\n)\n(?=\n  \\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?:\n    var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n",
      "captures": {
        "1": {
          "patterns": [
            {
              "include": "#modifiers"
            }
          ]
        }
      }
    },
    "modifiers": {
      "patterns": [
        {
          "comment": "Visibility modifiers",
          "match": "(?x) \\s*\n\\b\n(?:\n  pub|priv|prot|final|immut|mut|over\n  |glo|loc|intern|extern|imply|exply\n  |post|[gs]et|rem\n)\n(?!\\B|\\p{Pd}+\\b)\n\\s*\n",
          "name": "storage.modifier.trin"
        },
        {
          "comment": "Visibility modifiers",
          "match": "(?x) \\s*\n\\b\n(?:\n  seal|abst|impure|pure|early|late\n  |covar|contra|a?sync|stat|dyn|lazy\n  |eager|bound|free|unique|struct\n)\n(?!\\B|\\p{Pd}+\\b)\n\\s*\n",
          "name": "storage.type.accessor.trin"
        },
        {
          "comment": "Functional modifiers",
          "match": "(?x) \\s*\n\\b\n(?:\n  rec|oper|curry|inline\n  |pre|suf|inf|left|right\n)\n(?!\\B|\\p{Pd}+\\b)\n\\s*\n",
          "name": "storage.type.property.trin"
        }
      ]
    },
    "declaration-keywords": {
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(decl|def)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.other.declare.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(var|val)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(style)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.style.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(func?)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.function.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(proc)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.procedure.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(class)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.class.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(data)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.data.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(enum)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.enum.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(mod)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.module.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(iter)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.iterator.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(macro)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.macro.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(inter)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.structure.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(obj)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.object.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(trait)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.trait.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(elem)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.component.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(prop)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.property.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(mark)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "storage.type.markup.trin"
        }
      ]
    },
    "general-keywords": {
      "comment": "general keywords",
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(if|elif|else)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.conditional.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(for|loop|while)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.loop.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(try|throw|catch|after)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.trycatch.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(match|case|fail)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.switch.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.flow.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(use|show|hide|route)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.module.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(with|then|do|from|ref|go|defer)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.$1.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(debug|assert|check|where)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.other.$1.trin"
        }
      ]
    },
    "expression-keywords": {
      "comment": "expression keywords",
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(in|of|as|is|new)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.$1.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(del)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.delete.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(to|til|till|thru|by)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.range.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(unset)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.void.trin"
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(and|or|xor|not)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.logical.trin"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "include": "#validation-expression"
        },
        {
          "include": "#module-expression"
        },
        {
          "include": "#control-expression"
        },
        {
          "include": "#query-expression"
        },
        {
          "include": "#modifier-keywords"
        },
        {
          "include": "#declaration-keywords"
        },
        {
          "include": "#expression-keywords"
        },
        {
          "include": "#general-keywords"
        }
      ],
      "repository": {
        "control-expression": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(break|next|redo|retry|label|goto|pass)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.flow.trin"
            }
          },
          "patterns": [
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "constant.other.label.trin"
            }
          ]
        },
        "module-expression": {
          "patterns": [
            {
              "applyEndPatternLast": true,
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(use|show|hide|route)(?!\\B|\\p{Pd}+\\b)\\s*",
              "end": "(?=)|$",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.module.trin"
                }
              },
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.module.trin"
                },
                {
                  "include": "#type-keywords"
                },
                {
                  "include": "#declarations"
                },
                {
                  "include": "#strings"
                },
                {
                  "include": "#symbols"
                },
                {
                  "include": "#type-operators"
                },
                {
                  "match": ",",
                  "name": "punctuation.separator.comma.trin"
                },
                {
                  "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
                  "name": "variable.other.readwrite.alias.trin"
                }
              ]
            }
          ]
        },
        "validation-expression": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(where)(?!\\B|\\p{Pd}+\\b)\\s*",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.validate.trin"
            }
          },
          "end": "(?=[,;)}\\]])",
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(pre|post|need|know|check|test|read|write|till|same)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.validate.trin"
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.validate.trin"
            },
            {
              "include": "$self"
            }
          ]
        },
        "query-expression": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(from)(?!\\B|\\p{Pd}+\\b)\\s*",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.query.trin"
            }
          },
          "end": "(?=[,;)}\\]])",
          "patterns": [
            {
              "include": "#query-body"
            },
            {
              "include": "$self"
            }
          ]
        },
        "query-body": {
          "patterns": [
            {
              "include": "#in-clause"
            },
            {
              "include": "#where-clause"
            },
            {
              "include": "#join-clause"
            },
            {
              "include": "#sort-clause"
            },
            {
              "include": "#select-clause"
            },
            {
              "include": "#group-clause"
            },
            {
              "include": "#limit-clause"
            },
            {
              "include": "#reduce-clause"
            }
          ],
          "repository": {
            "in-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                },
                "2": {
                  "patterns": [
                    {
                      "include": "$self"
                    }
                  ]
                },
                "3": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "join-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b((?:full|part|self|cross)?(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:inner|outer|left|right)?(?!\\B|\\p{Pd}+\\b)\\s*\\bjoin)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                },
                "2": {
                  "patterns": [
                    {
                      "include": "$self"
                    }
                  ]
                },
                "3": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b([io]nto|equal)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.query.trin"
                },
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "where-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(where|having|filter|reject)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "sort-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b((?:sort|order)(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:asc|desc)?(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:by|with)?)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "select-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b((?:select|map)(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:unique|any|all)?)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(by|while|until|with)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.query.trin"
                },
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "limit-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b((?:take|drop|limit|offset)(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:first|last|head|tail)?)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(by|while|until|with)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.query.trin"
                },
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "reduce-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b((?:fold|reduce|scan)(?!\\B|\\p{Pd}+\\b)\\s*\\b(?:left|right)?)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(by|while|until|with)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.query.trin"
                },
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            "group-clause": {
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(group)(?!\\B|\\p{Pd}+\\b)\\s*",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.query.trin"
                }
              },
              "end": "(?=[,;)}\\]])",
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(by|into)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.query.trin"
                },
                {
                  "include": "#query-body"
                },
                {
                  "include": "$self"
                }
              ]
            }
          }
        }
      }
    },
    "declarations": {
      "patterns": [
        {
          "include": "#variable"
        },
        {
          "include": "#declare"
        },
        {
          "include": "#style"
        },
        {
          "include": "#markup"
        },
        {
          "include": "#function"
        },
        {
          "include": "#procedure"
        },
        {
          "include": "#class"
        },
        {
          "include": "#data"
        },
        {
          "include": "#enum"
        },
        {
          "include": "#module"
        },
        {
          "include": "#iterator"
        },
        {
          "include": "#macro"
        },
        {
          "include": "#structure"
        },
        {
          "include": "#object"
        },
        {
          "include": "#trait"
        },
        {
          "include": "#component"
        },
        {
          "include": "#property"
        }
      ],
      "repository": {
        "markup": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(mark)(?!\\B|\\p{Pd}+\\b)(.*)\\n*",
          "beginCaptures": {
            "1": {
              "name": "storage.type.markup.trin"
            },
            "2": {
              "name": "string.unquoted.block.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          },
          "end": "^(?=\\S)|(?!\\G)",
          "patterns": [
            {
              "begin": "^(\\s+)(?!\\s)",
              "end": "^(?!\\1|\\s*$)",
              "name": "string.unquoted.block.trin",
              "patterns": [
                {
                  "include": "#markdown"
                }
              ]
            }
          ]
        },
        "style": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(style)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.style.trin"
            }
          },
          "name": "meta.style.trin",
          "patterns": [
            {
              "include": "#style-rules"
            },
            {
              "include": "#style-pair"
            },
            {
              "include": "#style-block"
            },
            {
              "applyEndPatternLast": true,
              "name": "meta.style.trin",
              "begin": "\\s*([?:]?=)\\s*",
              "captures": {
                "1": {
                  "name": "keyword.operator.assignment.trin"
                }
              },
              "end": "(?=)|$",
              "patterns": [
                {
                  "include": "#style-pair"
                },
                {
                  "include": "#style-rules"
                },
                {
                  "include": "#style-block"
                },
                {
                  "include": "#block-entities"
                }
              ]
            },
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.style.trin"
            }
          ]
        },
        "component": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(elem)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.component.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.component.trin",
              "patterns": [
                {
                  "match": "\\.|:|::",
                  "name": "punctuation.separator.namespace.trin"
                },
                {
                  "match": "\\b([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\\b(?=[:.])",
                  "name": "entity.name.tag.namespace.trin"
                },
                {
                  "match": "\\b((?:[\\p{Pc}\\p{L}&&\\P{Ll}][\\w\\p{Pd}&&\\P{Lu}]*)+)\\b",
                  "name": "support.class.component.trin"
                },
                {
                  "include": "#clauses"
                },
                {
                  "include": "#declarations"
                },
                {
                  "include": "#keywords"
                },
                {
                  "include": "#html-tag-names"
                }
              ]
            }
          ]
        },
        "variable": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(var|val)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.variable.trin"
            }
          }
        },
        "declare": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(decl)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.trin"
            }
          }
        },
        "function": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(func?)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.function.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.function.trin"
            }
          ]
        },
        "procedure": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(proc)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.procedure.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.procedure.trin"
            }
          ]
        },
        "class": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(class)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.class.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.class.trin"
            }
          ]
        },
        "data": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(data)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.data.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.data.trin"
            }
          ]
        },
        "enum": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(enum)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.enum.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.enum.trin"
            }
          ]
        },
        "module": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(mod)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.module.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.module.trin"
            }
          ]
        },
        "iterator": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(iter)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.iterator.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.iterator.trin"
            }
          ]
        },
        "macro": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(macro)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.macro.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.macro.trin"
            }
          ]
        },
        "structure": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(inter)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.structure.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.structure.trin"
            }
          ]
        },
        "object": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(obj)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.object.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.object.trin"
            }
          ]
        },
        "trait": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(trait)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.trait.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.trait.trin"
            }
          ]
        },
        "property": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(prop)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "storage.type.property.trin"
            }
          },
          "patterns": [
            {
              "include": "#block-entities"
            },
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.property.trin"
            }
          ]
        }
      }
    },
    "function-clause": {
      "patterns": [
        {
          "comment": "Function def before function keyword\nx = def()\n",
          "match": "(?x)\n\n\\s*\n\n(?<=[?!:]:|\\b\\.|[?!]\\.)\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\\s+\n\n# Assignment operator\n(:?=)\\s+\n\n(\n  (?:\n    \\s*\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\s*\n  )*\n)\n\n(?=\n  \\s*\n  \\b\n  (?: # Function types\n    iter|func?|proc|macro\n  )\n  \\b\n)\n",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.method.trin"
            },
            "2": {
              "name": "keyword.operator.assignment.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            }
          }
        },
        {
          "begin": "(?x)\n\n(?<=[?!:]:|\\b\\.|[?!]\\.)\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\\s+\n\n# Assignment operator\n(:?=)\\s+\n\n(\n  (?:\n    \\s*\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\s*\n  )*\n)\n\n\\s*\n(\\|)\n(?!\\|)\n",
          "end": "(?<=^|['\"`)}\\]\\w\\s]|\\\\.)(\\|)(?=:?(?:[\\w\\s'\"`({\\[])|$)",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.method.trin"
            },
            "2": {
              "name": "keyword.operator.assignment.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            },
            "4": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "match": "(?<=[\\w\\s][(|])\\.",
              "name": "punctuation.definition.metadata.trin"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "Function def before function keyword\nx = def()\n",
          "match": "(?x)\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\\s+\n\n# Assignment operator\n(:?=)\\s+\n\n(\n  (?:\n    \\s*\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\s*\n  )*\n)\n\n(?=\n  \\s*\n  \\b\n  (?: # Function types\n    iter|func?|proc|macro\n  )\n  \\b\n)\n",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.function.trin"
            },
            "2": {
              "name": "keyword.operator.assignment.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            }
          }
        },
        {
          "begin": "(?x)\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\\s+\n\n# Assignment operator\n(:?=)\\s+\n\n\\s*\n\n(\n  (?:\n    \\s*\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\s*\n  )*\n)\n\n\\s*\n(\\|)\n(?!\\|)\n",
          "end": "(?<=^|['\"`)}\\]\\w\\s]|\\\\.)(\\|)(?=:?(?:[\\w\\s'\"`({\\[])|$)",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.function.trin"
            },
            "2": {
              "name": "keyword.operator.assignment.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            },
            "4": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "match": "(?<=[\\w\\s][(|])\\.",
              "name": "punctuation.definition.metadata.trin"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "params-clause": {
      "begin": "(?x)\n(?<=\n  (?:\n    # beginning of line\n    ^\n  | # or before a delimiter\n    [,;({\\[]\n  | # or before a sigil\n    [$:] \\s* \\b\n  | # key-value separator\n    ['\"`(){}\\[\\]\\w]: \\s\n  | # operator\n    (?:^ | ['\"`(){}\\[\\]\\s\\w] | \\\\.) # anchor\n    [\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]+\n  | # open/close bracket\n    (?:['\"`(){}\\[\\]] | \\\\.)\n    (?: [?!]?\\.=? | [?!:]:=?) # accessors\n  | # command syntax\n    //? \\b [\\p{Pc}\\p{L}][\\w\\p{Pd}]* \\b\n  | (?:\n      (?:^|[,;'\"`(){}\\[\\]\\s]|\\\\.) # beside a delimiter or space\n      \\b\n        (?:# keywords\n          in|of|as|is|new\n          |to|til|thru|by|del\n          |unset|ref|and|or|xor|not\n          |var|val|func?|proc|type\n          |class|data|enum|mod\n          |iter|macro|inter|obj\n          |trait|style|elem|prop|mark\n          |go|defer|do|from|where|with\n          |if|elif|else|then|def\n          |for|each|loop|while\n          |try|throw|catch|after\n          |match|case|pass|fail|goto\n          |break|next|redo|retry\n          |return|yield|await|label\n          |use|show|hide|route\n          |debug|assert|check\n        )\n      \\b\n      (?:$|[,;'\"`(){}\\[\\]\\\\\\s]) # beside a delimiter or space\n    )\n  )\n) \\s* # before a space\n(\\|)\n(?!\\|)\n",
      "captures": {
        "1": {
          "name": "punctuation.separator.arguments.trin"
        }
      },
      "end": "(?<=^|['\"`)}\\]\\w\\s]|\\\\.)(\\|)(?=:?(?:[\\w\\s'\"`({\\[])|$)",
      "patterns": [
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.operator.expression.as.trin"
        },
        {
          "match": "(?<=[\\w\\s][(|])\\.",
          "name": "punctuation.definition.metadata.trin"
        },
        {
          "include": "#clauses"
        },
        {
          "include": "#constants"
        },
        {
          "include": "#declarations"
        },
        {
          "include": "#expression-keywords"
        },
        {
          "include": "#function-params"
        },
        {
          "include": "$self"
        }
      ]
    },
    "clauses": {
      "patterns": [
        {
          "include": "#for-clause"
        },
        {
          "include": "#if-clause"
        },
        {
          "include": "#switch-clause"
        },
        {
          "include": "#match-clause"
        },
        {
          "include": "#catch-clause"
        },
        {
          "include": "#with-clause"
        },
        {
          "include": "#do-clause"
        },
        {
          "include": "#type-clause"
        },
        {
          "include": "#new-clause"
        },
        {
          "include": "#params-clause"
        },
        {
          "include": "#function-clause"
        }
      ],
      "repository": {
        "pattern-brackets": {
          "begin": "\\s*(\\()",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.parameters.trin"
            }
          },
          "patterns": [
            {
              "include": "#function-params"
            }
          ]
        },
        "new-clause": {
          "applyEndPatternLast": true,
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(new)(?!\\B|\\p{Pd}+\\b)",
          "end": "(?=)|$",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.expression.$1.trin"
            }
          },
          "patterns": [
            {
              "match": "(?x) \\s*\\b\n\n(?!\n  (?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b\n  (?: # keywords\n    in|of|as|is|new\n    |to|til|thru|by|del\n    |unset|ref|and|or|xor|not\n    |var|val|func?|proc|type\n    |class|data|enum|mod\n    |iter|macro|inter|obj\n    |trait|style|elem|prop|mark\n    |go|defer|do|from|where|with\n    |if|elif|else|then|def\n    |for|each|loop|while\n    |try|throw|catch|after\n    |match|case|pass|fail|goto\n    |break|next|redo|retry\n    |return|yield|await|label\n    |use|show|hide|route\n    |debug|assert|check\n  )\n  (?!\\B|\\p{Pd}+\\b)\n)\n\n# identifier\n([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)\n\\b\n",
              "name": "entity.name.instance.trin"
            },
            {
              "include": "#type-keywords"
            },
            {
              "include": "#type-square-brackets"
            },
            {
              "include": "#parameter-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        "type-clause": {
          "patterns": [
            {
              "applyEndPatternLast": true,
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(is|as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "end": "(?=)|$",
              "beginCaptures": {
                "1": {
                  "name": "keyword.operator.expression.$1.trin"
                }
              },
              "patterns": [
                {
                  "include": "#types"
                }
              ]
            },
            {
              "applyEndPatternLast": true,
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(type)(?!\\B|\\p{Pd}+\\b)\\s*",
              "end": "(?=)|$",
              "captures": {
                "1": {
                  "name": "keyword.other.typedef.trin"
                }
              },
              "patterns": [
                {
                  "include": "#type-curly-brackets"
                },
                {
                  "include": "#types"
                },
                {
                  "match": "\\s*([?:]?=)\\s*",
                  "captures": {
                    "1": {
                      "name": "keyword.operator.assignment.trin"
                    }
                  }
                }
              ]
            }
          ]
        },
        "catch-clause": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(catch)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "name": "meta.catch.trin",
          "captures": {
            "1": {
              "name": "keyword.control.error.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "begin": "\\s*(\\()",
              "end": "\\s*(\\))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.expression.trin"
                }
              },
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.error.trin"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.error.trin"
            },
            {
              "include": "$self"
            }
          ]
        },
        "for-clause": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(for|each|while)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "name": "meta.for.trin",
          "captures": {
            "1": {
              "name": "keyword.control.loop.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.loop.trin"
            },
            {
              "begin": "\\s*(\\()",
              "end": "\\s*(\\))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.expression.trin"
                }
              },
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.loop.trin"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "include": "$self"
            }
          ]
        },
        "if-clause": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(if|elif)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "name": "meta.if.trin",
          "captures": {
            "1": {
              "name": "keyword.control.conditional.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        "switch-clause": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(match)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "name": "meta.switch.trin",
          "captures": {
            "1": {
              "name": "keyword.control.match.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        "with-clause": {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(with)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "name": "meta.with.trin",
          "captures": {
            "1": {
              "name": "keyword.control.with.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.with.trin"
            },
            {
              "begin": "\\s*(\\()",
              "end": "\\s*(\\))",
              "captures": {
                "1": {
                  "name": "punctuation.definition.expression.trin"
                }
              },
              "patterns": [
                {
                  "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
                  "name": "keyword.control.with.trin"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "include": "$self"
            }
          ]
        }
      }
    },
    "labels": {
      "patterns": [
        {
          "comment": "Function def before function keyword\nx = def()\n",
          "match": "(?x)\n(?<=^ | [{;,\\s])\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\n# Key value separator\n(:)\\s*\n\n(\n  (?:\n    \\s*\n    \\b\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\b\n    \\s*\n  )*\n)\n\n(?=\n  \\s*\n  \\b\n  (?: # Function types\n    iter|func?|proc|macro\n  )\n  \\b\n)\n",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.function.trin"
            },
            "2": {
              "name": "punctuation.separator.key-value.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            }
          }
        },
        {
          "begin": "(?x)\n(?<=^ | [{;,\\s])\n\n\\s*\n\n# Label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\n# Key value separator\n(:)\n\n\\s*\n\n(\n  (?:\n    \\s*\n    \\b\n    (?: # Modifier keywords\n      pub|priv|prot|final|immut|mut|over\n      |glo|loc|intern|extern|imply|exply\n      |post|[gs]et|rem\n\n      |seal|abst|impure|pure|early|late\n      |covar|contra|a?sync|stat|dyn|lazy\n      |eager|bound|free|unique|struct\n\n      |rec|oper|curry|inline\n      |pre|suf|inf|left|right\n    )\n    \\b\n    \\s*\n  )*\n)\n\n\\s*\n(\\|)\n(?!\\|)\n",
          "end": "(?<=^|['\"`)}\\]\\w\\s]|\\\\.)(\\|)(?=:?(?:[\\w\\s'\"`({\\[])|$)",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "entity.name.function.trin"
            },
            "2": {
              "name": "punctuation.separator.key-value.trin"
            },
            "3": {
              "patterns": [
                {
                  "include": "#modifier-keywords"
                }
              ]
            },
            "4": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.separator.arguments.trin"
            }
          },
          "patterns": [
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "match": "(?<=[\\w\\s][(|])\\.",
              "name": "punctuation.definition.metadata.trin"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "match": "(?x)\n(?<=^ | [{;,\\s])\n\n\\s*\n\n# label\n(\\b[\\p{Pc}\\p{L}][\\p{Pd}\\w]*\\b)\n\n(?=: ['\"`\\\\({\\[\\s\\w])\n",
          "name": "meta.object-literal.key.trin",
          "captures": {
            "1": {
              "name": "constant.other.object.key.trin",
              "patterns": [
                {
                  "include": "#constants"
                },
                {
                  "include": "#numbers"
                },
                {
                  "include": "#symbols"
                },
                {
                  "include": "#string-content"
                }
              ]
            }
          }
        }
      ]
    },
    "punctuation": {
      "patterns": [
        {
          "include": "#line-continuation"
        },
        {
          "include": "#comma"
        },
        {
          "include": "#semicolon"
        }
      ]
    },
    "line-continuation": {
      "begin": "\\s*(\\\\)\\s*(?=/[/*]\\s|$)",
      "end": "^\\s*",
      "captures": {
        "1": {
          "name": "punctuation.separator.continuation.line.trin"
        }
      },
      "patterns": [
        {
          "include": "#comments"
        }
      ]
    },
    "comma": {
      "match": "\\s*(,)",
      "name": "punctuation.separator.comma.trin"
    },
    "double-semicolon": {
      "match": "\\s*(;;)",
      "name": "punctuation.terminator.expression.trin"
    },
    "semicolon": {
      "match": "\\s*(;)",
      "name": "punctuation.terminator.statement.trin"
    },
    "brackets": {
      "patterns": [
        {
          "include": "#curly-brackets"
        },
        {
          "include": "#square-brackets"
        },
        {
          "include": "#round-brackets"
        },
        {
          "include": "#angle-brackets"
        }
      ]
    },
    "angle-brackets": {
      "patterns": [
        {
          "comment": "Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz",
          "name": "meta.type-arguments",
          "begin": "(?<=^|['\"`)}\\]\\s\\w])(<)(?=['\"`({\\[\\w])",
          "end": "(?<=^|['\"`)}\\]>\\w])(>)",
          "captures": {
            "1": {
              "name": "punctuation.type.arguments.trin"
            }
          },
          "patterns": [
            {
              "include": "#punctuation"
            },
            {
              "include": "#brackets"
            },
            {
              "include": "#types"
            }
          ]
        }
      ]
    },
    "closures": {
      "patterns": [
        {
          "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(case)(?!\\B|\\p{Pd}+\\b)\\s*",
          "end": "(?<=;)|(?={)|$|\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(then)(?!\\B|\\p{Pd}+\\b)|(?<=[)}\\]\\w'\"`])(:)(?=\\s|$)",
          "captures": {
            "1": {
              "name": "keyword.control.match.trin"
            },
            "2": {
              "name": "punctuation.separator.colon.trin"
            }
          },
          "patterns": [
            {
              "include": "#params-clause"
            },
            {
              "applyEndPatternLast": true,
              "begin": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(is)(?!\\B|\\p{Pd}+\\b)\\s*",
              "end": "(?=)|$",
              "beginCaptures": {
                "1": {
                  "name": "keyword.control.match.trin"
                }
              },
              "patterns": [
                {
                  "include": "#types"
                }
              ]
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(if|lest|elif|elest|else)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.match.trin"
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(var|val)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.match.trin"
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.control.match.trin"
            },
            {
              "include": "#type-keywords"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(fail)(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "keyword.control.match.trin"
        }
      ]
    },
    "curly-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.mapping.trin"
            },
            {
              "match": "(?<=(?:['\"`)}\\]\\w]|\\\\.)[\\p{S}\\p{P}&&[^,;'\"`\\\\(){}\\[\\]\\p{Pc}]]*):(?=['\"`\\\\({\\[\\w\\s]|$)",
              "name": "punctuation.separator.key-value.trin"
            },
            {
              "match": "(?<=^\\s*|[,;{]\\s*)(?:[-+*]\\s+)*[-+*](?=\\s|$)",
              "name": "punctuation.definition.block.sequence.item.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "(?<=[\\w'\"`)}\\]]|[^.]\\.=?|[?!:]:=?)(\\#?\\{)\\s*",
          "end": "\\s*(\\})\\s*",
          "captures": {
            "1": {
              "name": "punctuation.definition.typeparameters.trin"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.object.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\|\\s*\\||^\\s*\\|)\\s*(\\#\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.section.class.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\|\\s*\\||^\\s*\\|)\\s*(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.block.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\s*|[\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+)\\s*(\\#\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.mapping.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=^|[,;({\\[]|(?:^|[,;(){}\\[\\]\\w'\"`]|\\\\.):\\s*|[\\p{S}\\p{P}&&[^,;'\"`(){}\\[\\]\\p{Pc}]]+)\\s*(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.dictionary.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\#\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.section.class.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\{)\\s*",
          "end": "\\s*(\\})",
          "captures": {
            "1": {
              "name": "punctuation.definition.block.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "round-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.arguments.trin"
            },
            {
              "match": "\\s*(?<!(?:(?<!\\.)\\.|[?!:]:)=?)\\b(as)(?!\\B|\\p{Pd}+\\b)\\s*",
              "name": "keyword.operator.expression.as.trin"
            },
            {
              "match": "(?<=[\\w\\s][(|])\\.",
              "name": "punctuation.definition.metadata.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "(?<=[\\w'\"`)}\\]>]|[^.]\\.=?|[?!:]:=?)(\\#?\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.parameters.trin"
            }
          },
          "patterns": [
            {
              "include": "#punctuation"
            },
            {
              "include": "#clauses"
            },
            {
              "include": "#constants"
            },
            {
              "include": "#declarations"
            },
            {
              "include": "#expression-keywords"
            },
            {
              "include": "#function-params"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.tuple.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\#?\\()\\s*",
          "end": "\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.definition.expression.trin"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "square-brackets": {
      "repository": {
        "punctuation": {
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            }
          ]
        }
      },
      "patterns": [
        {
          "begin": "(?<=\\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\\b\\s*)(\\#?\\{)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.binding-pattern.array.trin"
            }
          },
          "patterns": [
            {
              "include": "#labels"
            },
            {
              "include": "#punctuation"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?<=[\\w'\"`)}\\]]|[^.]\\.=?|[?!:]:=?)(\\#?\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.attribute-selector.trin"
            }
          },
          "patterns": [
            {
              "include": "#punctuation"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\#\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.sequence.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(\\[)\\s*",
          "end": "\\s*(\\])",
          "captures": {
            "1": {
              "name": "punctuation.definition.array.trin"
            }
          },
          "patterns": [
            {
              "match": ",",
              "name": "punctuation.separator.sequence.trin"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "css-property-names": {
      "patterns": [
        {
          "match": "(?x)\\b(\n  # Standard CSS\n  additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration\n  |animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backdrop-filter\n  |backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image\n  |background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border\n  |border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color\n  |border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius\n  |border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image\n  |border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end\n  |border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color\n  |border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width\n  |border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius\n  |border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style\n  |border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side\n  |caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|column-count|column-fill|column-gap\n  |column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|content|counter-increment\n  |counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis\n  |flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family\n  |font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch\n  |font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures\n  |font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical\n  |grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start\n  |grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows\n  |hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align\n  |inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation\n  |justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style\n  |list-style-image|list-style-position|list-style-type|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start\n  |margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset\n  |mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode\n  |mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width\n  |max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position\n  |offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans\n  |outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline\n  |overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]\n  |pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left\n  |padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin\n  |place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align\n  |ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start\n  |scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right\n  |scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom\n  |scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right\n  |scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type\n  |scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size\n  |speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit\n  |stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright\n  |text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style\n  |text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation\n  |text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-position|top|touch-action|transform\n  |transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function\n  |translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change\n  |word-break|word-spacing|word-wrap|writing-mode|z-index|zoom\n\n  # SVG attributes\n  |alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile\n  |color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity\n  |glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid\n  |marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap\n  |stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y\n\n  # Not listed on MDN; presumably deprecated\n  |adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break\n  |balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length\n  |bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction\n  |box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column\n  |column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break\n  |delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust\n  |drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position\n  |flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before\n  |hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust\n  |initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count\n  |justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift\n  |line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed\n  |marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group\n  |orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range\n  |play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim\n  |radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness\n  |right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color\n  |rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral\n  |speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch\n  |string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height\n  |text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style\n  |top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range\n  |voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap\n\n  # Standard CSS\n  |additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration\n  |animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter\n  |backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage\n  |backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border\n  |borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor\n  |borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius\n  |borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage\n  |borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd\n  |borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor\n  |borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth\n  |borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius\n  |borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle\n  |borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide\n  |caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap\n  |columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement\n  |counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis\n  |flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily\n  |fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch\n  |fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures\n  |fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical\n  |grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart\n  |gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows\n  |hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign\n  |inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation\n  |justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle\n  |listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart\n  |marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset\n  |maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode\n  |maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth\n  |maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition\n  |offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans\n  |outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline\n  |overflowWrap|overflow[XY]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior[XY]\n  |pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft\n  |paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin\n  |placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign\n  |rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart\n  |scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight\n  |scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom\n  |scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight\n  |scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType\n  |scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size\n  |speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit\n  |strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright\n  |textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle\n  |textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation\n  |textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform\n  |transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction\n  |translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange\n  |wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom\n\n  # SVG attributes\n  |alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile\n  |colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity\n  |glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid\n  |markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap\n  |strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y\n\n  # Not listed on MDN; presumably deprecated\n  |adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak\n  |balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength\n  |bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection\n  |boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column\n  |columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak\n  |delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust\n  |dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition\n  |flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore\n  |hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust\n  |initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount\n  |justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift\n  |lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed\n  |marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup\n  |orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange\n  |playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim\n  |radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness\n  |rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor\n  |ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral\n  |speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch\n  |stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight\n  |textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle\n  |topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange\n  |voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.type.property-name.css.trin"
        }
      ]
    },
    "css-value-names": {
      "comment": "TODO",
      "patterns": [
        {
          "match": "(?x)\\b(\n  aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.color.w3c-standard-color-name.css.trin"
        },
        {
          "match": "(?x)\\b(\n  aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood\n  |cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan\n  |darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange\n  |darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise\n  |darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen\n  |gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki\n  |lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow\n  |lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray\n  |lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue\n  |mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise\n  |mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered\n  |orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum\n  |powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell\n  |sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato\n  |transparent|turquoise|violet|wheat|whitesmoke|yellowgreen\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.color.w3c-extended-color-name.css.trin"
        },
        {
          "match": "\\b(currentColor)(?!\\B|\\p{Pd}+\\b)",
          "name": "support.constant.color.current.css.trin"
        },
        {
          "match": "(?x)\\b(\n  ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow\n  |ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption\n  |InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow\n  |ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.color.system.css.trin"
        },
        {
          "match": "(?x)\\b(\n  above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse\n  |always|antialiased|auto|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel\n  |bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets\n  |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn\n  |color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover\n  |crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures\n  |distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in\n  |ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded\n  |fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|free|unique|structze\n  |from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide\n  |historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space\n  |ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start\n  |inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83\n  |jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB\n  |lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent\n  |match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize\n  |nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures\n  |no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize\n  |oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding\n  |padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line\n  |pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]\n  |reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text\n  |ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate\n  |sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller\n  |smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap\n  |step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table\n  |table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl\n  |text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle\n  |ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical\n  |vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy\n  |weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out\n\n  |above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse\n  |always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel\n  |bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets\n  |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn\n  |colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover\n  |crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures\n  |distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn\n  |easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded\n  |fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|free|unique|structze\n  |fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide\n  |historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace\n  |ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart\n  |inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83\n  |jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB\n  |liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent\n  |matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize\n  |nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures\n  |noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize\n  |oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding\n  |paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine\n  |preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat[xy]\n  |resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText\n  |rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate\n  |sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller\n  |smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap\n  |stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table\n  |tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl\n  |text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle\n  |ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical\n  |verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy\n  |weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.property-value.css.trin"
        },
        {
          "match": "(?x)\\s*\\b(\n  arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic\n  |decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am\n  |ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew\n  |hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer\n  |korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek\n  |lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal\n  |square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian\n  |upper-latin|upper-roman|urdu\n\n  |arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic\n  |decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm\n  |ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew\n  |hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer\n  |koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek\n  |lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal\n  |square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian\n  |upperLatin|upperRoman|urdu\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.property-value.list-style-type.css.trin"
        },
        {
          "match": "(?x)\\s*\\b(\n  arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma\n  |times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif\n  |monospace\n  |arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma\n  |times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif\n  |monospace\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.font-name.css.trin"
        }
      ]
    },
    "html-tag-names": {
      "patterns": [
        {
          "match": "(?x)\\b(?:\n  (all|print|screen|speech)\n  |(aural|braille|embossed|handheld|projection|tty|tv)\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.constant.media.css.trin"
        },
        {
          "match": "(?x)\\b(\n\n  # HTML\n  a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound\n  |big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command\n  |content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset\n  |figcaption|figure|font|footer|form|frame|frameset|h(?:0|[1-9]\\d*)|head|header|hgroup|hr|html|i\n  |iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark\n  |marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript\n  |object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc\n  |ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong\n  |style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr\n  |track|tt|u|ul|var|video|wbr|xmp\n\n  # SVG\n  |altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform\n  |circle|clipPath|colorProfile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix\n  |feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap\n  |feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur\n  |feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting\n  |feSpotLight|feTile|feTurbulence|filter|fontFace|fontFaceFormat|fontFaceName\n  |fontFaceSrc|fontFaceUri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern\n  |line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata\n  |missingGlyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor\n  |stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern\n\n  # MathML\n  |annotation|annotationXml|maction|maligngroup|malignmark|math|menclose|merror|mfenced\n  |mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot\n  |mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup\n  |msup|mtable|mtd|mtext|mtr|munder|munderover|semantics\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "entity.name.tag.css.trin"
        }
      ]
    },
    "entities": {
      "patterns": [
        {
          "include": "#function-names"
        },
        {
          "include": "#constant-names"
        },
        {
          "include": "#type-names"
        },
        {
          "include": "#variable-names"
        }
      ]
    },
    "type-names": {
      "comment": "Names for built-in types",
      "patterns": [
        {
          "comment": "Primitive classes",
          "match": "(?x)\\s*(?<![?!]?\\.|[?!:]:)\\b(\n  Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)\n  |Imag|Comp|Char|Rune|Str|Sym\n  |(U?Int|[UI])(8|16|32|64|128)\n  |([CI]?Float|[CI]?F)(16|32|64|128)\n  # lower flat case\n  |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)\n  |imag|comp|char|rune|str|sym\n  |(u?int|[ui])(8|16|32|64|128)\n  |([ci]?float|[ci]?f)(16|32|64|128)\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.type.builtin.primitive.trin"
        },
        {
          "comment": "Data structure classes",
          "match": "(?x)\\s*(?<![?!]?\\.|[?!:]:)\\b(\n  Array|Tuple|List|Set|Hash|Seq|Str|Dict|Iter\n  |Proc|Range|Stack|Heap|Queue|Tree|Trie|Rec\n  |Future|Stream|RegExp?|Func?|Buf|StrBuf|Bytes\n  # lower flat case\n  |array|tuple|list|set|hash|seq|str|dict|iter\n  |proc|range|stack|heap|queue|tree|trie|rec\n  |future|stream|regexp?|func?|buf|strbuf|bytes\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.type.builtin.trin"
        },
        {
          "comment": "Constant/algebraic classes",
          "match": "(?x)\\s*(?<![?!]?\\.|[?!:]:)\\b(\n  True|False|Null|Void|NaN|Infin|Empty|Unit|Obj\n  |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const\n  # lower flat case\n  |true|false|null|void|nan|infin|empty|unit|obj\n  |any|mixed|just|some|none|never|(im)?pure|const\n)(?!\\B|\\p{Pd}+\\b)\n",
          "name": "support.type.primitive.trin"
        },
        {
          "comment": "Error classes | BaseError, etc",
          "match": "\\s*\\b((\\p{Lu}[\\w\\p{Pd}&&\\P{Lu}]*)+)?(Error|Exception)(?!\\B|\\p{Pd}+\\b)",
          "name": "support.class.error.trin"
        },
        {
          "comment": "Interface classes | IEnumerable, etc",
          "match": "\\s*\\bI((\\p{Lu}[\\w\\p{Pd}&&\\P{Lu}]*)+)(?!\\B|\\p{Pd}+\\b)",
          "name": "entity.name.interface.trin"
        },
        {
          "comment": "Namespace classes | NSString, etc",
          "match": "\\s*\\bNS((\\p{Lu}[\\w\\p{Pd}&&\\P{Lu}]*)+)(?!\\B|\\p{Pd}+\\b)",
          "name": "entity.name.namespace.trin"
        },
        {
          "comment": "Trait classes | Serializable, Loggable etc",
          "match": "\\s*\\b((\\p{Lu}[\\w\\p{Pd}&&\\P{Lu}]*)+)able(?!\\B|\\p{Pd}+\\b)",
          "name": "support.class.trait.trin"
        }
      ]
    },
    "support-functions": {
      "comment": "Names for built-in functions (initial dump)",
      "patterns": [
        {
          "comment": "Python and Perl 6/Raku built-in functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)\n(\n  # Python\n  import|abs|all|any|ascii|bin|breakpoint|callable|chr|compile\n  |copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter\n  |format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance\n  |issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct\n  |open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted\n  |sum|vars|zip|file|reduce|intern|rawInput|unicode|cmp|basestring|execfile\n  |long|xrange|bool|bytearray|bytes|classmethod|complex|dict|float|frozenset\n  |int|list|object|property|set|slice|staticmethod|str|tuple|type\n\n  # JavaScript\n  |isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI\n  |decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|require\n  |(?:clear|set)(?:Interval|Timeout)\n\n  # Go\n  |append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println\n  |real|recover\n\n  # Lua\n  |coroutine|create|resume|running|status|wrap|yield|string|byte|char|dump|find\n  |format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper|table|concat|insert\n  |maxn|remove|sort|math|abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp\n  |ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?\n  |io|close|flush|input|lines|open|output|popen|read|tmpfile|type|write\n  |os|clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname\n  |package|cpath|loaded|loadlib|path|preload|seeall|debug|debug|[gs]etfenv\n  |[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue\n  |traceback|assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs\n  |loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawset\n  |require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall\n\n  # Perl\n  |eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints|chmod|split|reduce\n  |min|max|reverse|truncate|zip|cat|roundrobin|classify|first|sum|keys|values|pairs\n  |defined|delete|exists|elems|end|kv|any|all|one|wrap|shape|key|value|name|pop|push\n  |shift|splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt|sin|cos|tan\n  |round|strand|roots|cis|unpolar|polar|atan2|pick|chop|p5chop|chomp|p5chomp|lc\n  |lcfirst|uc|ucfirst|capitalize|normalize|pack|unpack|quotemeta|comb|samecase\n  |sameaccent|chars|nfd|nfc|nfkd|nfkc|printf|sprintf|caller|evalfile|run|runinstead\n  |nothing|want|bless|chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin\n  |getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print|open|read|write\n  |readline|say|seek|close|opendir|readdir|slurp|spurt|shell|run|pos|fmt|vec|link\n  |unlink|symlink|uniq|pair|asin|atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh\n  |tanh|asinh|done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh|asech|ok\n  |nok|planOk|diesOk|livesOk|skip|todo|pass|flunk|forceTodo|useOk|isaOk|diag|isDeeply\n  |isnt|like|skipRest|unlike|cmpOk|evalDiesOk|nokError|evalLivesOk|approx|isApprox\n  |throwsOk|versionLt|plan|eval|succ|pred|times|nonce|once|signature|new|connect\n  |operator|undef|undefine|sleep|from|to|infix|postfix|prefix|circumfix|postcircumfix\n  |minmax|lazy|count|unwrap|getc|pi|e|context|void|quasi|body|each|contains|rewinddir\n  |subst|can|isa|flush|arity|assuming|rewind|callwith|callsame|nextwith|nextsame|attr\n  |evalElsewhere|none|srand|trim|trimStart|trimEnd|lastcall|what|where|how|which|var\n  |who|whence|accepts|rejects|not|true|iterator|by|re|im|invert|flip|gist|flat|tree\n  |isPrime|throwsLike|trans\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.builtin.trin"
        },
        {
          "comment": "JavaScript StdLib functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|\n  scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|\n  sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|\n  Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|\n  Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|\n  savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|\n  contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|\n  createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|\n  test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|\n  untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins|refresh|paddings|parse|\n  print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|\n  fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|\n  forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|\n  abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|\n  releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|\n  Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|\n  Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|\n  moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.builtin.trin"
        },
        {
          "comment": "Python magic functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)\n(\n  \\p{Pc}+ (?:\n    abs|add|aenter|aexit|aiter|and|anext|await|bool|call|ceil|cmp|coerce|complex\n    |contains|copy|deepcopy|del|delattr|delete|delitem|delslice|dir|div|divmod|enter\n    |eq|exit|float|floor|floordiv|format|ge|get|getattr|getattribute|getinitargs\n    |getitem|getnewargs|getslice|getstate|gt|hash|hex|iadd|iand|idiv|ifloordiv|ilshift\n    |imod|imul|index|init|instancecheck|int|invert|ior|ipow|irshift|isub|iter|itruediv\n    |ixor|le|len|long|lshift|lt|missing|mod|mul|ne|neg|new|next|nonzero|oct|or|pos|pow\n    |radd|rand|rdiv|rdivmod|reduce|reduceEx|repr|reversed|rfloordiv|rlshift|rmod|rmul\n    |ror|round|rpow|rrshift|rshift|rsub|rtruediv|rxor|set|setattr|setitem|setslice\n    |setstate|sizeof|str|sub|subclasscheck|truediv|trunc|unicode|xor|matmul|rmatmul\n    |imatmul|initSubclass|setName|fspath|bytes|prepare|all|bases|builtins|class\n    |classGetitem|code|debug|defaults|dict|doc|file|fn|kwdefaults|members|metaclass\n    |methods|module|mro|mroEntries|name|qualname|postInit|self|signature|slots\n    |subclasses|version|weakref|wrapped|annotations|classcell|spec|path|package\n    |future|traceback\n  ) \\p{Pc}+\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.magic.trin"
        },
        {
          "comment": "CSS, LESS and SASS functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  abs|acos|alpha|argb|asin|atan|average|blue|calc|ceil\n  |color|contrast|convert|convert|cos|darken|data-uri\n  |desaturate|difference|e|escape|exclusion|extract\n  |fade|fadein|fadeout|floor|format|green|greyscale\n  |hardlight|hsl|hsla|hsv|hsva|hsvhue|hsvsaturation\n  |hsvvalue|hue|length|lighten|lightness|luma|max|min\n  |mix|mod|multiply|negation|overlay|percentage|pi|pow\n  |red|replace|round|saturate|saturation|screen|sin\n  |softlight|spin|sqrt|tan|unit\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.magic.trin"
        },
        {
          "comment": "Ruby kernel functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  # Ruby builtin functions\n  abort|atExit|autoload|binding|callcc|caller|callerLocations\n  |chomp|chop|eval|exec|exit|exit|fork|format|gets\n  |globalVariables|gsub|lambda|load|localVariables|open\n  |p|print|printf|proc|putc|puts|rand|readline|readlines\n  |select|setTraceFunc|sleep|spawn|sprintf|srand|sub\n  |syscall|system|test|traceVar|trap|untraceVar|warn\n\n  # C StdLib\n  |abort|abs|acos|asctime|asctimeR|asin|assert|atan|atan2|atexit|atof|atoi|atol|bsearch|btowc|calloc\n  |catclose6|catgets6|catopen6|ceil|clearerr|clock|cos|cosh|ctime|ctime64|ctimeR|ctime64R|difftime\n  |difftime64|div|erf|erfc|exit|exp|fabs|fclose|fdopen5|feof|ferror|fflush1|fgetc1|fgetpos1|fgets1\n  |fgetwc6|fgetws6|fileno5|floor|fmod|fopen|fprintf|fputc1|fputs1|fputwc6|fputws6|fread|free|unique|struct|freopen\n  |frexp|fscanf|fseek1|fsetpos1|ftell1|fwide6|fwprintf6|fwrite|fwscanf6|gamma|getc1|getchar1|getenv\n  |gets|getwc6|getwchar6|gmtime|gmtime64|gmtimeR|gmtime64R|hypot|isalnum|isalpha|isascii4|isblank\n  |iscntrl|isdigit|isgraph|islower|isprint|ispunct|isspace|isupper|iswalnum4|iswalpha4|iswblank4\n  |iswcntrl4|iswctype4|iswdigit4|iswgraph4|iswlower4|iswprint4|iswpunct4|iswspace4|iswupper4|iswxdigit4\n  |isxdigit4|j0|j1|jn|labs|ldexp|ldiv|localeconv|localtime|localtime64|localtimeR|localtime64R\n  |log|log10|longjmp|malloc|mblen|mbrlen4|mbrtowc4|mbsinit4|mbsrtowcs4|mbstowcs|mbtowc|memchr|memcmp\n  |memcpy|memmove|memset|mktime|mktime64|modf|nextafter|nextafterl|nexttoward|nexttowardl\n  |nlLanginfo4|perror|pow|printf|putc1|putchar1|putenv|puts|putwc6|putwchar6|qsort|quantexpd32\n  |quantexpd64|quantexpd128|quantized32|quantized64|quantized128|samequantumd32|samequantumd64\n  |samequantumd128|raise|rand|randR|realloc|regcomp|regerror|regexec|regfree|remove|rename|rewind1\n  |scanf|setbuf|setjmp|setlocale|setvbuf|signal|sin|sinh|snprintf|sprintf|sqrt|srand|sscanf\n  |strcasecmp|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strfmon4|strftime|strlen\n  |strncasecmp|strncat|strncmp|strncpy|strpbrk|strptime4|strrchr|strspn|strstr|strtod|strtod32\n  |strtod64|strtod128|strtof|strtok|strtokR|strtol|strtold|strtoul|strxfrm|swprintf|swscanf|system\n  |tan|tanh|time|time64|tmpfile|tmpnam|toascii|tolower|toupper|towctrans|towlower4|towupper4|ungetc1\n  |ungetwc6|vaArg|vaCopy|vaEnd|vaStart|vfprintf|vfscanf|vfwprintf6|vfwscanf|vprintf|vscanf|vsprintf\n  |vsnprintf|vsscanf|vswprintf|vswscanf|vwprintf6|vwscanf|wcrtomb4|wcscat|wcschr|wcscmp|wcscoll4|wcscpy\n  |wcscspn|wcsftime|wcslen|wcslocaleconv|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsptime|wcsrchr|wcsrtombs4\n  |wcsspn|wcsstr|wcstod|wcstod32|wcstod64|wcstod128|wcstof|wcstok|wcstol|wcstold|wcstombs|wcstoul\n  |wcsxfrm4|wctob|wctomb|wctrans|wctype4|wcwidth|wmemchr|wmemcmp|wmemcpy|wmemmove|wmemset|wprintf6\n  |wscanf6|y0|y1|yn\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.kernel.trin"
        },
        {
          "comment": "Event handler functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  on(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|\n  Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|\n  Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|\n  Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|\n  Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|\n  Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|\n  Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|\n  Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.event-handler.trin"
        },
        {
          "comment": "DOM functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|\n  appendChild|appendData|before|blur|canPlayType|captureStream|\n  caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|\n  cloneContents|cloneNode|cloneRange|close|closest|collapse|\n  compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|\n  convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|\n  createAttributeNS|createCaption|createCDATASection|createComment|\n  createContextualFragment|createDocument|createDocumentFragment|\n  createDocumentType|createElement|createElementNS|createEntityReference|\n  createEvent|createExpression|createHTMLDocument|createNodeIterator|\n  createNSResolver|createProcessingInstruction|createRange|createShadowRoot|\n  createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|\n  deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|\n  deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|\n  enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|\n  exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|\n  getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|\n  getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|\n  getClientRects|getContext|getDestinationInsertionPoints|getElementById|\n  getElementsByClassName|getElementsByName|getElementsByTagName|\n  getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|\n  getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|\n  hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|\n  insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|\n  insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|\n  isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|\n  lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|\n  moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|\n  parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|\n  previousSibling|probablySupportsContext|queryCommandEnabled|\n  queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|\n  querySelector|querySelectorAll|registerContentHandler|registerElement|\n  registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|\n  removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|\n  removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|\n  requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|\n  scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|\n  setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|\n  setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|\n  setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|\n  slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|\n  submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|\n  toDataURL|toggle|toString|values|write|writeln\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.dom.trin"
        },
        {
          "comment": "Bash and Batch built-in functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt\n  |bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil\n  |change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher\n  |clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert\n  |copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd\n  |dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf\n  |diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd\n  |dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal\n  |eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract\n  |fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|free|unique|structdisk\n  |fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate\n  |graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig\n  |ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd\n  |ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manageBde|mapadmin|md\n  |mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt\n  |msg|msiexec|msinfo32|mstsc|nbtstat|net|netcfg|netdiag|netdom|netsh|netstat\n  |nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt\n  |ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin\n  |pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershellIse\n  |print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd\n  |pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta\n  |rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32\n  |relog|ren|rename|rendom|repadmin|repairBde|replace|reset|rxec|risetup\n  |rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks\n  |scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn\n  |setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|sshAdd|sshAgent\n  |sshKeygen|sshKeyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo\n  |takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title\n  |tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp\n  |tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier\n  |verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where\n  |whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy\n  |alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown\n  |echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill\n  |let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source\n  |suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait\n  |alias|apropos|apt|aptGet|aptitude|aspell|at|awk|basename|base32|base64\n  |bash|bc|bg|bind|break|builtin|bzip2|cal|caller|when|cat|cd|cfdisk|chattr\n  |chgrp|chmod|chown|chpasswd|chroot|chkconfig|cksum|clear|cmp|comm|command\n  |continue|cp|cpio|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|declare\n  |df|diff|diff3|dig|dir|dircolors|dirname|dirs|dos2unix|dmesg|dpkg|du|echo\n  |egrep|eject|enable|env|ethtool|eval|exec|exit|expect|expand|export|expr\n  |false|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|for|format|free|unique|struct|fsck|ftp\n  |function|fuser|gawk|getopts|grep|groupadd|groupdel|groupmod|groups|gzip|hash\n  |head|help|history|hostname|htop|iconv|id|if|ifconfig|ifdown|ifup|import|install\n  |iostat|ip|jobs|join|kill|killall|less|let|link|ln|local|locate|logname|logout\n  |look|lpc|lpr|lprint|lprintd|lprintq|lprm|lsattr|lsblk|ls|lsof|lspci|make|man\n  |mapfile|mkdir|mkfifo|mkfile|mkisofs|mknod|mktemp|more|most|mount|mtools|mtr|mv\n  |mmv|nc|netstat|nft|nice|nl|nohup|notifySend|nslookup|open|op|passwd|paste\n  |pathchk|Perf|ping|pgrep|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd\n  |quota|quotacheck|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice\n  |remsync|return|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|select|seq|set|sftp\n  |shift|shopt|shuf|shutdown|sleep|slocate|sort|source|split|ss|ssh|stat|strace\n  |su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|tmux|touch|top\n  |tput|traceroute|trap|tr|true|tsort|tty|type|ulimit|umask|umount|unalias|uname\n  |unexpand|uniq|units|unix2dos|unrar|unset|unshar|until|uptime|useradd|userdel\n  |usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|w|wait|watch|wc|whereis|which\n  |while|who|whoami|wget|write|xargs|xdgOpen|xxd|xz|yes|zip\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.system.trin"
        },
        {
          "comment": "Bash and Batch built-in functions",
          "match": "(?x)\n(?<!\\p{Pd}+\\b|\\B)(\n  avg|checksumAgg|count|countBig|grouping|groupingId|max|min|sum|stdev|stdevp|var\n  |varp|cumeDist|firstValue|lag|lastValue|lead|percentRank|percentileCont|percentileDisc\n  |cast|convert|parse|tryCast|tryConvert|tryParse|cursorStatus|coalesce|nullif|choose\n  |iif|sysdatetime|sysdatetimeoffset|sysutcdatetime|currentTime(?:stamp)?|getdate\n  |getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts\n  |datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts\n  |datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate|cursorRows|connections\n  |cpuBusy|datefirst|dbts|error|fetchStatus|identity|idle|ioBusy|langid|language\n  |lockTimeout|maxConnections|maxPrecision|nestlevel|options|packetErrors|packReceived\n  |packSent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks\n  |totalErrors|totalRead|totalWrite|trancount|version|abs|acos|asin|atan|atn2|ceiling\n  |cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square\n  |tan|appName|applockMode|applockTest|assemblyproperty|colLength|colName|columnproperty\n  |databasePrincipalId|databasepropertyex|dbId|dbName|fileId|fileIdex|fileName|filegroupId\n  |filegroupName|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty\n  |indexCol|indexkeyProperty|indexproperty|objectDefinition|objectId|objectName\n  |objectSchemaName|objectproperty|objectpropertyex|originalDbName|parsename|schemaId|schemaName\n  |scopeIdentity|serverproperty|statsDate|typeId|typeName|typeproperty|rank|denseRank|ntile\n  |rowNumber|opendatasource|openrowset|openquery|openxml|certencoded|certprivatekey|currentUser\n  |databasePrincipalId|hasPermsByName|isMember|isRolemember|isSrvrolemember|originalLogin|permissions\n  |pwdcompare|pwdencrypt|schemaId|schemaName|sessionUser|suserId|suserSid|suserSname|systemUser\n  |suserName|userId|userName|ascii|char|charindex|concat|difference|format|left|len|lower|ltrim\n  |nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|stringAgg\n  |stringEscape|stringSplit|stuff|substring|translate|trim|unicode|upper|patindex|textptr|textvalid\n  |binaryChecksum|checksum|compress|connectionproperty|contextInfo|currentRequestId|currentTransactionId\n  |decompress|errorLine|errorMessage|errorNumber|errorProcedure|errorSeverity|errorState|formatmessage\n  |getFilestreamTransactionContext|getansinull|hostId|hostName|isnull|isnumeric|minActiveRowversion\n  |newid|newsequentialid|rowcountBig|sessionContext|sessionId|exactState\n)(?!\\B|\\p{Pd}+\\b)\\s*\n",
          "name": "support.function.database.trin"
        },
        {
          "comment": "predicate functions",
          "match": "\\s*\\bis(\\p{Lu}[\\w\\p{Pd}&&\\P{Lu}]*)+(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "support.function.predicate.trin"
        },
        {
          "comment": "magic functions",
          "match": "\\s*\\b\\p{Pc}+([\\p{Pc}\\p{L}][\\w\\p{Pd}]*)+\\p{Pc}+(?!\\B|\\p{Pd}+\\b)\\s*",
          "name": "support.function.magic.trin"
        }
      ]
    }
  }
}

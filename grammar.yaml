name: Protea
scopeName: source.dart
fileTypes: [dart, pta, pti, pts]
patterns: [include: '#core']

information for contributors: |
  This is the grammar for the Protea language.

  The grammar is nearing completion but needs to be thoroughly refactored and
  reorganized. There also are some bugfixes which are on the verge of being
  performed.

  Should you feel any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo, and I
  will be very happy to receive it/them.

fixes: |
  Changes in 2022:

  - Added back backslash strings, though with much more limitations. This also removes `\` as an operator identifier.
  - Removed JSX and style blocks; replaced them with indentation
  - Comments have been standardized into Swift-style comments:
    - `//` line comment
    - `///` documentation line comment
    - `/*` block comment `*/`
    - `/**` documentation block comment `*/`
  - Added `/` (full) and `//` (shorthand) command flags
  - Removed `import`, `export`, `let`, `const` in favor of `use`, `show`, `hide`, `var` and `val`.
  - Numbers and escape sequences have been reworked, and will no longer accept integers bigger than decimal 1114111 which now are highlighted as an error.
  - Bases 4, 6, and 12 have been scrapped, though a multi-base generic numeric literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed. Spacing around identifiers have also been removed.
  - Function call syntax is still reworked and may still be buggy. Might have a later fix in the near future, and some improvements have to be made.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings, generated using code
  - Fix JSX highlighting and attributes:
    - @directive
    - #id and .class
    - :event
    - $variable
    - &reference and *spread
  - Fixed regular expression replacement string highlighting

  Fixes:

  - Match unquoted glob patterns in routes without quotes
  - What would Trinity's standard library look like, since it is used both in client- and server-side application development? So far I have a handful shown below, namely function names, HTML tags and known CSS properties and constants which are taken from the grammars of those languages.
  - Rewrite complex regular expressions throughout this document and add some comments to make them more readable and less confusing
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [ ] embedded content
    - [ ] rounded and square brackets
    - [ ] LINQ, inline SQL and validation syntax (more to come later)
  - Revamp Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|til|thru|by|del
        |unset|ref|and|or|xor|not
        |var|val|func|proc|type
        |class|data|enum|module
        |iter|macro|inter|object
        |trait|style|elem|prop
        |go|defer|do|with|from|where
        |if|elif|else|then|def
        |for|each|loop|while
        |try|throw|catch|after
        |match|case|pass|fail|goto
        |break|next|redo|retry
        |return|yield|await|mark
        |use|show|hide|route
        |debug|assert|check
      )
      (?!\B|\p{Pd}+\b)
    )

    # identifier
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  html-tag-names: &html-tag-names
    - match: '\.|:|::'
      name: punctuation.separator.namespace.protea
    - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
      name: entity.name.tag.namespace.protea
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)\b
      name: support.class.component.protea
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#ignore-long-lines'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#embedded-expression'
      - include: '#jsx'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#symbols'
      - include: '#type-signature'
      - include: '#literals'
      - include: '#operators'
      - include: '#calls'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{1024,}$

  space:
    match: \s+
    name: meta.var.expr.protea

  # Function brackets (early here as not to break things)

  param-bracket-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.protea
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.protea
      - include: '#clauses'
      - include: '#constants'
      - include: '#declaration-keywords'
      - include: '#declaration-keywords'
      - include: '#parameter-variables'
      - include: '#keywords'

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.protea
      - match: '[\w]+?'
        name: invalid.illegal.variable.protea
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.protea
      - match: '[\p{S}\p{P}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.protea
      - match: \S+?
        name: invalid.illegal.uncaught.protea

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan) # null, NaN
            |(void) # undefined
            |(infin) # infinity
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: { name: constant.language.boolean.$1.protea }
          2: { name: constant.language.$2.protea }
          3: { name: constant.language.undefined.protea }
          4: { name: constant.language.infinity.protea }
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|that|self|super) # special arguments
            |(args) # arguments
            |(ctor) # constructor
            |(proto) # prototype
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: { name: variable.language.$1.protea }
          2: { name: variable.language.arguments.protea }
          3: { name: variable.language.constructor.protea }
          4: { name: variable.language.prototype.protea }

  # Numbers

  numbers:
    patterns:
      - comment: hexadecimal integers
        name: constant.numeric.hexadecimal.protea
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.protea }
          2: { name: keyword.other.unit.protea }
          3: { name: keyword.operator.expression.exponent.protea }
          4: { name: keyword.operator.exponent.sign.protea }
          5: { name: constant.numeric.decimal.exponent.mantissa.protea }
          6: { name: keyword.other.unit.protea }
      - comment: octal integers
        name: constant.numeric.octal.protea
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.protea }
          2: { name: keyword.other.unit.protea }
          3: { name: keyword.operator.expression.exponent.protea }
          4: { name: keyword.operator.exponent.sign.protea }
          5: { name: constant.numeric.decimal.exponent.mantissa.protea }
          6: { name: keyword.other.unit.protea }
      - comment: binary 0b
        name: constant.numeric.binary.protea
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.protea }
          2: { name: keyword.other.unit.protea }
          3: { name: keyword.operator.expression.exponent.protea }
          4: { name: keyword.operator.exponent.sign.protea }
          5: { name: constant.numeric.decimal.exponent.mantissa.protea }
          6: { name: keyword.other.unit.protea }
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.protea
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.protea }
          2: { name: keyword.other.unit.protea }
          3: { name: keyword.operator.expression.exponent.protea }
          4: { name: keyword.operator.exponent.sign.protea }
          5: { name: constant.numeric.decimal.exponent.mantissa.protea }
          6: { name: keyword.other.unit.protea }

  # Symbols

  decorators:
    - applyEndPatternLast: true
      begin: \@[\p{Pc}\p{L}][\w\p{Pd}]*\b
      end: (?=)|$
      name: entity.name.class.decorator.protea
      patterns:
        - include: '#brackets'
        - &embedded-primary-operators
          comment: Primary binary operators
          match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
          captures:
            1: { name: keyword.operator.optional.protea }
            2: { name: keyword.operator.assert.protea }
            3: { name: keyword.operator.accessor.protea }
        - match: \b[\p{Pc}\p{L}][\w\p{Pd}]*\b
          name: entity.name.class.decorator.protea

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s:=])(:)(?=[\\'"])
        end: (?=)|$
        name: constant.language.symbol-type.protea
        captures:
          1: { name: punctuation.definition.symbol.protea }
        patterns:
          - include: '#strings-single-quoted'
          - include: '#strings-double-quoted'
          - include: '#strings-unquoted'
      - match: (?<=^|\\.|['"`({\[)}\]\s:=])(:)([\p{Pc}\p{L}][\w\p{Pd}]*\b)
        captures:
          1: { name: punctuation.definition.symbol.protea }
          2: { name: constant.other.symbol.protea }

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (\\)
    end: (?=[\p{Z}\p{P}\p{S}])|$
    name: string.unquoted.protea
    captures:
      1: { name: punctuation.definition.string.protea }
    patterns:
      - include: '#string-escapes'

  strings:
    patterns:
      - include: '#strings-prefixed'
      - include: '#strings-double-quoted'
      - include: '#strings-single-quoted'

  strings-single-quoted:
    patterns:
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:\p{L}+))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'

  strings-double-quoted:
    patterns:
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:\p{L}+))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'

  string-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded'

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.protea
      - match: \\[abefprnstv]
        name: constant.character.escape.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.deprecated.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  named-characters:
    name: string.unquoted.plain.in.protea
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.protea
        begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: { name: constant.other.function.protea }
            patterns:
              - include: '#named-characters'
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
        name: constant.character.escape.protea
        captures:
          1: { patterns: [include: '#character-namespace'] }
      - include: '#string-content'
      - include: '#punctuation'
      - include: '#illegal'

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: support entity.name.tag.namespace.protea
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: support entity.name.function.member.protea

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: constant.other.character-class.protea
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: constant.character.escape.unicode.protea

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.protea
        begin: \\N([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: { name: constant.other.function.protea }
            patterns:
              - include: '#named-characters'
      - match: \\N([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
        name: constant.character.escape.protea
        captures:
          1: { patterns: [include: '#character-namespace'] }
      - begin: \\N{\s*
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.protea
            begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
            beginCaptures:
              1: { patterns: [include: '#function-namespace'] }
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: { name: constant.other.function.protea }
                patterns:
                  - include: '#named-characters'
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
            name: constant.character.escape.protea
            captures:
              1: { patterns: [include: '#character-namespace'] }
          - include: '#string-content'
          - include: '#punctuation'
          - include: '#illegal'

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 while \x encodes UTF-8 code points
      in addition to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.protea
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.protea
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.protea
          - include: '#illegal'

      - comment: Octal escape sequences (0 to 417777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 417777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.protea
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.protea
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 417777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.protea
          - include: '#illegal'

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411[01]
            | 111410\d
            | 11140\d{2}
            | 111[0-3]\d{3}
            | 110\d{4}
            | 10\d{5}
            | [1-9]\d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.protea
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.protea
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.protea
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                  111411[01]
                | 111410\d
                | 11140\d{2}
                | 111[0-3]\d{3}
                | 110\d{4}
                | 10\d{5}
                | [1-9]\d{1,5}
                | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.protea
          - include: '#illegal'

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.protea
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.protea
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.protea
        patterns:
          - include: '#punctuation'
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.protea
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
                (?!\h)
            name: constant.character.escape.leading.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.protea
          - include: '#illegal'

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.protea
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.protea
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.protea
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.protea
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.protea
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.protea
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.protea
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.protea
          - include: '#illegal'

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expression'
      - include: '#embedded-format'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.protea
      - include: '#embedded-expression'
      - include: '#embedded-format'

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.protea
        captures:
          1: { name: punctuation.definition.variable.protea }
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|val|func|proc|type
              |class|data|enum|module
              |iter|macro|inter|object
              |trait|style|elem|prop
              |go|defer|do|with|from|where
              |if|elif|else|then|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|pass|fail|goto
              |break|next|redo|retry
              |return|yield|await|mark
              |use|show|hide|route
              |debug|assert|check
            )
            (?!\B|\p{Pd}+\b)
          )
          \b # next to a word
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.variable.protea }
        patterns:
          - include: '#constants'
          - include: '#brackets'
          - include: '#embedded-calls'
          - include: '#variables'
          - include: '#numbers'
          - &embedded-primary-operators
            comment: Primary binary operators
            match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
            captures:
              1: { name: keyword.operator.optional.protea }
              2: { name: keyword.operator.assert.protea }
              3: { name: keyword.operator.accessor.protea }

  embedded-placeholder:
    patterns:
      - match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|//?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: { name: punctuation.definition.anchor.protea }
          2:
            name: constant.numeric.decimal.protea
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.protea
              - match: (?:[>.]\.[.<]|\.\.=?|=\.=)
                name: keyword.operator.range.protea
      - match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|//?|\*\*?)? # sigil
              [!?]? # required or optional
            )
            \b
             [\p{Pc}\p{L}][\w\p{Pd}]*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|with|from|where
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|mark
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            \b
            [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
            \b
          )
        captures:
          1: { name: punctuation.definition.anchor.protea }
          2: { patterns: [include: '#placeholder-variables'] }
      - begin: (\#{)\s*
        end: \s*(})
        name: entity.quasi.component.protea
        captures:
          1: { name: punctuation.definition.anchor.protea }
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(//)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.protea }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: { name: keyword.other.flag.protea }
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(/)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.protea }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: { name: keyword.modifier.protea }

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: { name: punctuation.definition.directive.protea }
    patterns:
      - include: '#format-syntax'

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}][\w\p{Pd}]*)\b(:)
        end: (?=)|$
        name: storage.type.format.protea
        captures:
          1: { name: punctuation.separator.mapping.protea }
          2: { name: storage.type.format.protea }
          3: { name: punctuation.separator.key-value.protea }
        patterns: &format-values
          - include: '#constants'
          - include: '#embedded-calls'
          - include: '#variables'
          - include: '#brackets'
          - include: '#regexps'
          - include: '#numbers'
          - include: '#symbols'
          - *embedded-primary-operators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: storage.type.format.protea
        captures:
          1: { name: punctuation.separator.mapping.protea }
          2: { name: storage.type.format.protea }

  # Regular expressions

  regexps:
    applyEndPatternLast: true
    begin: (?<!`+)(?=\p{L}*`+)
    end: (?=)|$
    name: meta.regexp.protea
    patterns:
      - comment: Pattern section
        begin: (?<!`+)\s*(\p{L}*)(```+|`)\s*
        end: \s*(\2)(?!`+)(\p{L}*)
        name: string.pattern.regexp.protea
        beginCaptures:
          1: { name: keyword.modifier.protea }
          2: { name: punctuation.section.regexp.begin.protea }
        endCaptures:
          1: { name: punctuation.section.regexp.end.protea }
          2: { name: keyword.other.flag.protea }
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
      - applyEndPatternLast: true
        begin: (?=,)
        end: (?=)|$
        name: meta.replace.protea
        patterns:
          - comment: Replacement section
            begin: (?<=`+|,)\s*(```+|`)\s*
            end: \s*(\1)(?!`+)(\p{L}*)
            name: string.replace.regexp.protea
            captures:
              1: { name: punctuation.section.regexp.end.protea }
              2: { name: keyword.other.flag.protea }
            patterns:
              - include: '#back-references'
              - include: '#string-content'
          - include: '#comments'
          - include: '#comma'
          - include: '#line-continuation'
      - include: '#comments'
      - include: '#line-continuation'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}][\w\p{Pd}]*\b
        name: keyword.other.unit.protea
      - match: \s+
        name: meta.space.protea

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: { name: punctuation.definition.mapping.protea }
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: { name: punctuation.definition.array.protea }
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.expression.protea }
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*|&)
        name: keyword.other.back-reference.protea
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.protea
        captures:
          1: { name: keyword.other.back-reference.protea }
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#string-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.protea
        captures:
          1: { name: keyword.other.back-reference.protea }
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - match: \p{Z}+
        name: meta.space.protea
      - include: '#embedded'
      - include: '#comments'
      - include: '#strings'
      - match: \|
        name: keyword.operator.or.protea
      - match: \&
        name: keyword.operator.compose.protea
      - match: \.
        name: constant.character.all.protea
      - match: \\[bB](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.protea
      - match: \$|\\[yYzZ](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.protea}
      - match: \^|\\[AmM](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.protea
      - match: \\K
        name: keyword.control.keepout.protea
      - match: \\G
        name: keyword.control.search.protea
      - match: \\R
        name: constant.character.control.protea
      - match: \\[XO]
        name: constant.character.unicode.protea
      - match: \\\d+
        name: keyword.other.back-reference.protea
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: { name: keyword.operator.quantifier.protea }
          1: { name: keyword.operator.modifier.lazy.protea }
          2: { name: keyword.operator.modifier.eager.protea }
          3: { name: keyword.operator.modifier.greedy.protea }
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: { name: keyword.operator.quantifier.lazy.protea }
          2: { name: keyword.operator.quantifier.eager.protea }
          3: { name: keyword.operator.quantifier.greedy.protea }
          4: { name: keyword.operator.modifier.lazy.protea }
          5: { name: keyword.operator.modifier.eager.protea }
          6: { name: keyword.operator.modifier.greedy.protea }
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.protea
        captures:
          1: { name: keyword.other.back-reference.protea }
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.protea
        captures:
          1: { name: keyword.other.subroutine.protea }
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.protea
        captures:
          1: { name: keyword.other.back-reference.protea }
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.protea
        captures:
          1: { name: keyword.other.subroutine.protea }
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.protea
        captures:
          1: { name: punctuation.definition.fuzzy.protea }
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: { name: punctuation.separator.key-value.protea }
            end: (?=[,;}]|)|$
            patterns:
              - include: '#regexp-patterns'
          - include: '#fuzzy-expression'
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'

  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(\?([*+])
        end: \s*(\))
        name: constant.other.pcre.protea
        captures:
          0: { name: punctuation.section.expression.protea }
        patterns:
          - include: $self
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.protea
        end: \s*(\))
        name: comment.block.regexp.protea
        captures:
          1: { name: punctuation.definition.comment.protea }
        patterns:
          - match: \\.
            name: comment.block.regexp.protea
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.protea
        captures:
          1: { name: punctuation.definition.group.look-ahead.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.protea
        captures:
          1: { name: punctuation.definition.group.look-behind.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.protea
        captures:
          1: { name: punctuation.definition.group.negative-look-ahead.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.protea
        captures:
          1: { name: punctuation.definition.group.negative-look-behind.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: { name: punctuation.definition.directive.protea }
        end: \s*(\))
        name: meta.group.directive.protea
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.protea
        captures:
          1: { name: punctuation.definition.group.longest.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.protea
        captures:
          0: { name: punctuation.definition.group.flag.protea }
          1: { name: punctuation.definition.group.flag.protea }
          2: { name: constant.numeric.index.protea }
          3: { name: keyword.control.recursion.protea }
          4: { name: keyword.other.flag.protea }
          5: { name: punctuation.separator.colon.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.protea
        captures:
          1: { name: punctuation.definition.group.call-out.protea }
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.protea
            captures:
              1: { name: punctuation.definition.group.call-out.protea }
              2: { name: keyword.operator.range.protea }
              3: { name: punctuation.definition.tag.protea }
              4: { patterns: [include: '#function-names'] }
              5: { name: punctuation.definition.tag.protea }
            patterns:
          - include: $self
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.protea
        captures:
          1: { name: punctuation.definition.group.atomic.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.protea
        captures:
          1: { name: punctuation.definition.group.non-capturing.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.protea
        captures:
          1: { name: punctuation.definition.group.branch.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.protea
        captures:
          1: { name: punctuation.definition.group.absent.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.protea
        captures:
          0: { name: punctuation.definition.group.back-reference.protea }
          1: { name: punctuation.definition.group.back-reference.protea }
          2: { name: constant.numeric.index.protea }
          3: { patterns: [include: '#variables'] }
          4: { name: punctuation.separator.colon.protea }
        patterns:
          - include: '#regexp-patterns'
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: { name: punctuation.definition.group.named.protea }
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.protea
            captures:
              1: { name: punctuation.definition.group.named.protea }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: { name: punctuation.definition.group.named.protea }
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.protea
            captures:
              1: { name: punctuation.definition.group.named.protea }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.protea
        captures:
          1: { name: punctuation.definition.group.protea }
        patterns:
          - include: '#regexp-patterns'

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - include: '#attribute-selectors'
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.protea
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.protea
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.protea
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.protea
      - match: \\[abefprntv]
        name: constant.character.escape.protea
      - match: \\[a-z]
        name: constant.other.character-class.protea
      - match: \\[A-Z]
        name: constant.other.character-class.negated.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.deprecated.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.protea
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          2:
            name: keyword.operator.range.protea
          3:
            name: constant.other.character-class.range.to.protea
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          4:
            name: keyword.operator.range.protea
          5:
            name: constant.other.character-class.range.by.protea
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
      - match: \|\|
        name: keyword.operator.union.protea
      - match: \&&
        name: keyword.operator.intersection.protea
      - match: \^\^
        name: keyword.operator.symmetric.protea
      - match: ~~
        name: keyword.operator.negation.protea
      - match: --
        name: keyword.operator.difference.protea

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.protea
        captures:
          1: { name: punctuation.definition.character-class.posix.protea }
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.protea
        captures:
          1: { name: punctuation.definition.character-class.negated.protea }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.protea
        captures:
          1: { name: punctuation.definition.character-class.protea }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    patterns:
      - match: ','
        name: punctuation.separator.sequence.protea
      - include: '#comments'
      - include: '#strings'
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.protea
      - include: '#string-escapes'
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.protea
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.protea
      - match: \b(in|is)\b
        name: keyword.operator.expression.$1.protea
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: { name: entity.other.attribute-name.key.protea }
          2: { name: keyword.operator.pattern.protea }
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`({\[)}\]])
        name: string.unquoted.attribute-name.protea
        patterns:
          - include: '#style-property-values'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: { name: entity.other.attribute-name.protea }
          2: { name: keyword.operator.pattern.protea }
      - include: '#operators'

  # Markdown

  jsx:
    applyEndPatternLast: true
    comment: |
      Only after opening brackets, commas, semicolons, keywords, and operators.
      In addition, < > starts a JSX fragment, <?x ... ?> starts a declaration, and =
      <! !> starts a fragment with CDATA-style syntax.
    begin: |
      (?x)
      (?<=
        (?:
          (?:
              ^ # beginning of line
            | [,;] # separator
            | [({\[] # opening bracket
          )
            | \b [\p{Pc}\p{L}][\w\p{Pd}]* \b \s # identifier or keyword
            | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s # postfix or infix operator
        ) \s*
      )
      (?=<[\p{Pc}\p{L}]|<\s+>)
    end: (?=)|$
    patterns:
      - include: '#tag-component-name'

  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: meta.jsx.fragment.protea
        begin: (<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: { name: punctuation.definition.tag.protea }
        endCaptures:
          1: { name: punctuation.definition.tag.protea }
        patterns:
          - include: '#tag-termination'
      - comment: Tags that end > are trapped in tag-termination
        contentName: meta.jsx.protea
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?:\.|::?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
            \b
          )
          (?=[,;'"`\\({\[)}\]/>\s])#(?![:])(?<![.:=])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</)\O*?)>
          )
        beginCaptures:
          1: { name: punctuation.definition.tag.protea }
          2: { patterns: [include: '#tag-names'] }
        endCaptures:
          1: { patterns: [include: '#tag-names'] }
          2: { name: punctuation.definition.tag.protea }
          3: { name: punctuation.definition.tag.protea }
          4: { name: invalid.illegal.termination.protea }
        patterns:
          - include: '#tag-termination'
          - include: '#tag-attributes'

  jsx-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: { name: punctuation.definition.comment.protea }
    name: comment.block.html.protea
    patterns:
      - include: '#jsx-comments'

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: string.unquoted.html.protea
    name: string.unquoted.html.protea
    begin: (>)
    end: (</)
    captures:
      0: { name: punctuation.definition.tag.protea }
    patterns:
      - include: '#evaluated-code'
      - include: '#jsx-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#jsx-comments'

  tag-attributes:
    patterns:
      - include: '#literals'
      - include: '#style-selectors'
      - include: '#attribute-names'
      - applyEndPatternLast: true
        begin: \s*(=)\s*
        beginCaptures:
          1: { name: punctuation.separator.key-value.protea }
        end: (?=)|$
        name: meta.property.jsx.protea
        patterns:
          - include: '#style-property-values'
      - include: '#comments'
      - include: '#punctuation'
      - include: '#brackets'
      - include: '#embedded'

  attribute-names:
    match: \s*([\p{Pd}\w]+)\b\s*
    name: meta.attribute.protea
    captures:
      1:
        name: entity.other.attribute-name.${1:/camelcase}.protea
        patterns:
          - include: '#css-property-names'

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.protea

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: { name: punctuation.definition.entity.protea }
          2: { name: punctuation.definition.entity.protea }
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.protea
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.protea
      - captures: *jsx-entities
        match: (&)(?:\\.|[^({\[)}\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.protea
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.protea

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z0-9]+|#[0-9]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: { name: punctuation.definition.bold.markdown }
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#italic'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.image.markdown }
      8: { name: punctuation.definition.link.markdown }
      9: { name: string.other.link.description.title.markdown }
      10: { name: punctuation.definition.string.markdown }
      11: { name: punctuation.definition.string.markdown }
      12: { name: string.other.link.description.title.markdown }
      13: { name: punctuation.definition.string.markdown }
      14: { name: punctuation.definition.string.markdown }
      15: { name: string.other.link.description.title.markdown }
      16: { name: punctuation.definition.string.markdown }
      17: { name: punctuation.definition.string.markdown }
      18: { name: punctuation.definition.metadata.markdown }
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.begin.markdown }
      5: { name: punctuation.definition.constant.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.markdown }
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: '#string-content'

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: { name: punctuation.definition.italic.markdown }
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  link-email:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      4: { name: punctuation.definition.link.markdown }
    match: (<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: '#string-content'

  link-inet:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      3: { name: punctuation.definition.link.markdown }
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: '#string-content'

  link-inline:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.markdown }
      9: { name: punctuation.definition.link.markdown }
      10: { name: string.other.link.description.title.markdown }
      11: { name: punctuation.definition.string.begin.markdown }
      12: { name: punctuation.definition.string.end.markdown }
      13: { name: string.other.link.description.title.markdown }
      14: { name: punctuation.definition.string.begin.markdown }
      15: { name: punctuation.definition.string.end.markdown }
      16: { name: string.other.link.description.title.markdown }
      17: { name: punctuation.definition.string.begin.markdown }
      18: { name: punctuation.definition.string.end.markdown }
      19: { name: punctuation.definition.metadata.markdown }
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: '#string-content'

  link-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  link-ref-literal:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: '#string-content'

  link-ref-shortcut:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      3: { name: punctuation.definition.string.end.markdown }
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  raw:
    captures:
      1: { name: punctuation.definition.raw.markdown }
      2: { patterns: [include: '#string-content'] }
      3: { name: punctuation.definition.raw.markdown }
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: '#string-content'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#jsx-entities'
      - include: '#html-tag'
      - include: '#string-content'
      - include: '#evaluated-code'
      - include: '#executed-code'
      - include: '#inline-styles'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

    repository:
      blockquote:
        comment: '> blockquote'
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.quote.begin.markdown }
          2:
            name: markup.quote.markdown
            patterns: [include: '#markdown']
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: '#markdown']

      unordered-list:
        comment: '- unordered list'
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.list.begin.markdown }
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']

      ordered-list:
        comment: '+ ordered list'
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.list.begin.markdown }
          2:
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: { name: storage.type.method.protea }
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: { name: storage.type.subroutine.protea }
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.protea
        captures:
          1: { name: punctuation.definition.tag.protea }
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
            captures:
              1: { name: entity.name.tag.protea, patterns: *html-tag-names }
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.id.protea
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.class.protea
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: { name: punctuation.definition.directive.protea }
            patterns:
          - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: { name: punctuation.definition.mapping.protea }
            patterns:
              - include: '#style-properties'
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.parameters.protea }
            patterns:
              - include: '#tag-attributes'
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.protea
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.protea
            end: \s*((\1)(?!'+))
            captures:
              1: { name: punctuation.definition.string.protea }
            patterns: [include: '#markdown']
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.protea
            end: \s*((\1)(?!"+))
            captures:
              1: { name: punctuation.definition.string.protea }
            patterns: [include: '#markdown']
          - include: '#regexps'

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1: { name: storage.type.style.protea }
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: { name: keyword.operator.assignment.protea }
              - include: '#comments'
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#declaration-clause'
              - match: *entity-name
                name: entity.name.style.protea
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: '#style-properties']

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:\.|::?)[\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
    name: meta.property-name.protea
    captures:
      1:
        patterns:
          - include: '#css-value-names'
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
            name: constant.other.protea
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: constant.language.protea
          - match: '\.|:|::'
            name: punctuation.separator.namespace.protea

  style-list:
    begin: (\[)\s*
    end: \s*(\])
    name: meta.brace.square.protea
    captures:
      1: { name: punctuation.definition.expression.protea }
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#style-list'
      - include: '#style-block'
      - include: '#literals'
      - include: '#property-name'
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#html-builtins'
      - include: '#line-continuation'
      - include: '#jsx'
      - include: '#brackets'

  hex-colors:
    match: (#)\b(?:\h{3,4}|\h{6}|\h{8})\b
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: { name: punctuation.definition.constant.css }

  tag-names:
    match: \s*\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:\.|::?)[\p{Pc}\p{L}][\w\p{Pd}]*)*)\b\s*
    name: entity.name.tag.protea
    captures:
      1:
        name: entity.name.tag.protea
        patterns: *html-tag-names

  style-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.style.protea
    captures:
      1: { name: punctuation.section.property-list.protea }
    patterns:
      - include: '#style-properties'

  style-pair:
    applyEndPatternLast: true
    begin: \s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=)|$
    name: meta.property.css.protea
    beginCaptures:
      1:
        name: support.type.property-name.protea
        patterns: [include: '#css-property-names']
      2:
        name: punctuation.separator.key-value.protea
    patterns:
      - include: '#style-property-values'
      - match: \s+
        name: meta.var.expr.protea

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-pair'
      - include: '#style-rules'
      - include: '#style-block'
      - include: $self

  style-rules:
    patterns:
      - include: '#calls'
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: { name: keyword.operator.sum.protea }
          2: { name: keyword.operator.difference.protea }
          3: { name: keyword.operator.product.protea }
          4: { name: keyword.operator.quotient.protea }
          5: { name: keyword.operator.remainder.protea }
          6: { name: keyword.operator.only.protea }
          7: { name: keyword.operator.maybe.protea }
          8: { name: keyword.operator.intersection.protea }
          9: { name: keyword.operator.union.protea }
          10: { name: keyword.operator.symmetric.protea }
          11: { name: keyword.operator.negation.protea }
          12: { name: keyword.operator.macro.dollar.protea }
          13: { name: keyword.operator.private.protea }
          14: { name: keyword.operator.class.protea }
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.parameters.protea }
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: { name: punctuation.definition.selector.protea }
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|only|just|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.protea
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^]|::)(?=[\w$])
        name: punctuation.definition.entity.protea
      - match: \s*(?<=\@)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: keyword.control.at-rule.protea
      - match: \s*(?<=\#)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.id.protea
      - match: \s*(?<=\.)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.class.protea
      - match: \s*(?<=::)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.pseudo-component.protea
      - match: \s*(?<=\~)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.key.protea

      - match: \s*(?<=\&)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.type.anchor.protea
      - match: \s*(?<=\*)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.type.alias.protea
      - match: \s*(?<=\%)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.function.protea
      - match: \s*(?<=\|)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.method.protea
      - match: \s*(?<=\:)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.procedure.protea
      - match: \s*(?<=\^)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.name.property.protea

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'
      - include: '#nested-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.documentation.protea
        captures:
          1: { name: punctuation.definition.comment.protea }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc'
      - begin: \s*(/\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.protea
        captures:
          1: { name: punctuation.definition.comment.protea }
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block'

  line-comments:
    patterns:
      - begin: \s*(///)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.documentation.protea
        captures:
          1: { name: punctuation.definition.comment.protea }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.number-sign.protea
        captures:
          1: { name: punctuation.definition.comment.protea }
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.documentation.nested.protea
    captures:
      1: { name: punctuation.definition.comment.protea }
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc'

  nested-block:
    begin: (/\*)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.nested.protea
    captures:
      1: { name: punctuation.definition.comment.protea }
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: { name: storage.type.class.jsdoc }
      3: { name: storage.modifier.jsdoc }

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: { name: keyword.module.jsdoc }
          2: { name: punctuation.jsdoc }
          3: { name: string.modulename.jsdoc }

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: { name: storage.type.class.jsdoc }

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: { name: string.linktext.jsdoc }
      2: { name: meta.brace.curly.jsdoc }
    endCaptures:
      1: { name: meta.brace.curly.jsdoc }
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: { name: storage.type.class.jsdoc }
          3: { name: string.jsdoc }

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: { name: support.type.builtin.primitive.jsdoc }

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b\s*(:)
        captures:
          1: { name: variable.other.readwrite.jsdoc }
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: { name: variable.other.jsdoc }
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*(?=[\p{Pc}\p{L}])
        captures:
          1: { name: keyword.as.jsdoc }
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: { name: entity.name.class.jsdoc }
          2: { name: entity.name.function.jsdoc }
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.static.jsdoc }
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.instance.jsdoc }
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.inner.jsdoc }
      - match: (\#)(event)(:)
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: keyword.event.jsdoc }
          3: { name: keyword.operator.jsdoc }
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: '#jsdoc-string'

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    old:
      name: meta.function.call.protea
      match: |
        (?x)
        (?<! # ignore qualified names
          \b (?: [?!]?\.=? | [?!:]:=?) (?: \b | ['"`\\({\[])
        )
        (?<=
          (?:
            # beginning of line
            ^
          | # or before a delimiter
            [,;({\[] \s*
          | # or before a sigil
            [$:] \s* \b
          | # key-value separator
            ['"`({\[)}\]\w]: \s
          | # operator
            (?:^ | ['"`({\[)}\]\w\s] | \\.) # anchor
            [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
          | # open/close bracket
            (?:['"`({\[)}\]] | \\.)
            (?: [?!]?\.=? | [?!:]:=?) # accessors
          | # command syntax
            (?:^ | [,;({\[] | \s) //? \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          | (?:
              (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
              \b
                (?: # keywords
                  in|of|as|is|new
                  |to|til|thru|by|del
                  |unset|ref|and|or|xor|not
                  |var|val|func|proc|type
                  |class|data|enum|module
                  |iter|macro|inter|object
                  |trait|style|elem|prop
                  |go|defer|do|with|from|where
                  |if|elif|else|then|def
                  |for|each|loop|while
                  |try|throw|catch|after
                  |match|case|pass|fail|goto
                  |break|next|redo|retry
                  |return|yield|await|mark
                  |use|show|hide|route
                  |debug|assert|check
                )
              \b
              (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            )
          ) \s* # before a space
        )
        \b
        (
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|val|func|proc|type
              |class|data|enum|module
              |iter|macro|inter|object
              |trait|style|elem|prop
              |go|defer|do|with|from|where
              |if|elif|else|then|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|pass|fail|goto
              |break|next|redo|retry
              |return|yield|await|mark
              |use|show|hide|route
              |debug|assert|check
            )
            (?!\B|\p{Pd}+\b)
          )
          (?:
            \b
            [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
            \b
            (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
          )*
          [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
        )
        \b
        (?=
          \s+
          (?:
              # prefix operator literal
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
              ['"`({\[]
            | # array literal
              \[
            | # command literal
               (?:^ | [,;({\[] | \s) //? \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
            | # ignore orphaned qualified name
              (?!
                (?: [?!]?\.=? | [?!:]:=?)
                ['"`\\({\[\w]
              )
              # prefix operator
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*
              (?:
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                  (?: # keywords
                    in|of|as|is|new
                    |to|til|thru|by|del
                    |unset|ref|and|or|xor|not
                    |var|val|func|proc|type
                    |class|data|enum|module
                    |iter|macro|inter|object
                    |trait|style|elem|prop
                    |go|defer|do|with|from|where
                    |if|elif|else|then|def
                    |for|each|loop|while
                    |try|throw|catch|after
                    |match|case|pass|fail|goto
                    |break|next|redo|retry
                    |return|yield|await|mark
                    |use|show|hide|route
                    |debug|assert|check
                  )
                  (?!\B|\p{Pd}+\b)
                )
                (?:
                  \b
                  [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
                  \b
                  (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
                )*
                [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
              )
              (?: # closing bracket
                  [,;'"`({\[)}\]\s]
                | # operator
                  [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
                | # end of line
                  $
              )
          )
          | \s* # optional space
          (?: # command or string literal
              (?: \\ )
            | # function application, composition and piping
              (?: \$ | \s \. | <\|{1,3}| <\+) ['"`\\({\[\w\s]
            | # C-style function call
              (?:[!?]\.=?|\.=)? \#?\(
            | # generics
              (?:[!?]\.=?|\.=)? < ['"`\\({\[\w]
            | # string literal or expression
              ['"`(]
          )
        )
      captures:
        1: { patterns: [include: '#function-names'] }

    patterns:
      - include: '#embedded-calls'
      - name: meta.function.call.protea
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|with|from|where
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|mark
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b
          (?=
            \s*
            (?: # function application, composition and piping
                (?: \$ | \s \. | <\|{1,3}| <\+) ['"`\\({\[\w\s]
              | # C-style function call
                (?:[!?]\.=?|\.=)? \#?\(
              | # generics
                (?:[!?]\.=?|\.=)? < ['"`\\({\[\w]
            )
          )
        captures:
          1: { patterns: [include: '#function-names'] }

      - name: meta.function.call.protea
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | \+>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|with|from|where
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|mark
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b
        captures:
          1: { patterns: [include: '#function-names'] }

  embedded-calls:
    patterns:
      - &function-names
        name: meta.function.name.protea
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? \( ) # opening bracket
            |
            (?<= ^ # beginning of line
              | ['"`({\[)}\]\w\s] # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? \( ) # opening bracket
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.protea
          2:
            patterns: *builtin-names
            name: entity.name.tag.protea support.class.component.protea
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.protea
          4:
            patterns: *builtin-names
            name: entity.name.function.method.protea
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.protea
          6:
            patterns: *builtin-names
            name: entity.name.type.protea
          7:
            patterns: *builtin-names
            name: entity.name.class.protea
          8:
            patterns: *builtin-names
            name: entity.name.function.protea

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.protea
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | \$ | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | \$ | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.protea
          2:
            patterns: *builtin-names
            name: entity.name.tag.protea support.class.component.protea
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.protea
          4:
            patterns: *builtin-names
            name: entity.name.function.method.protea
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.protea
          6:
            patterns: *builtin-names
            name: entity.name.type.protea
          7:
            patterns: *builtin-names
            name: entity.name.class.protea
          8:
            patterns: *builtin-names
            name: entity.name.function.protea
      - include: '#variables'
      - include: '#primary-operators'

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            [?!] # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.optional.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            \*\*? # spread
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.spread.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            //? # named
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.name.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            \& # reference
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.reference.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            \% # other
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.other.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^|[,;'"`({\[)}\]\s]|\\.)
              \b (?:
                var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop|as
              ) \b
              (?:$|[,;'"`\\({\[)}\]\s]) # var/val/as keyword
          )
            \s*
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.protea

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.protea
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.protea
      - match: (?i)\s*//?[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.protea
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.protea
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.protea
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.protea

  variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \b

      (?:
        (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
        (?: # Properties
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
      )\b
    captures:
      1: { name: variable.other.index.protea }
      2: { name: variable.other.constant.property.protea }
      3: { name: variable.other.property.static.protea }
      4: { name: variable.other.property.protea }
      5: { name: variable.other.global.protea }
      6: { name: variable.other.constant.object.protea }
      7: { name: variable.other.conditional.protea }
      8: { name: variable.other.object.protea }
      9: { name: variable.other.dollar.protea }
      10: { name: variable.other.constant.protea }
      11: { name: variable.other.class.protea }
      12: { name: variable.other.readwrite.protea }

  # Operators

  operators:
    patterns:
      - include: '#primary-operators'
      - include: '#infix-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - begin: (?<=^|[\s({\[])(\?)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`\\({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`\\({\[\w])
        captures:
          1: { name: keyword.operator.conditional.protea }
          2: { name: keyword.operator.conditional.protea }
        patterns:
          - include: $self
      - begin: (?<=^|[\s({\[])(\!)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`\\({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`\\({\[\w])
        captures:
          1: { name: keyword.operator.ternary.protea }
          2: { name: keyword.operator.ternary.protea }
        patterns:
          - include: $self

  infix-operators:
    patterns:
      - name: keyword.operator.infix.protea
        match: |
          (?xi)
          (?<=^|[\s({\[]) # opening
          (?:
            ( # 1: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 2: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 3: string / regex
              \+\+ | --
            ) |
            ( # 4: logical operator
              \&\& | \|\| | \^\^ | !
            ) |
            ( # 5: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 6: bitwise shift
              <<<? | >>>?
            ) |
            ( # 7: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 8: composition
              <\+ | \+>
            ) |
            ( # 9: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 10: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 11: equality
              == | != | === | !==
            ) |
            ( # 12: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 13: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 14: null coalescing
              \?+
            ) |
            ( # 15: non null coalescing
              !+
            ) |
            ( # 16: falsy coalescing
              \?:
            ) |
            ( # 17: truthy coalescing
              !:
            ) |
            ( # 18: function application
              [.$]
            ) |
            ( # 19: assignment
              :?=
            ) |
            ( # 20: range
              [>.]\.[.<]
            ) |
            ( # 21: fat arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 22: skinny arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 23: wavy arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 24: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 25: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 26: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 27: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: catch all
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            )
          )
          (?=$|[)}\]\s]) # closing
        captures:
          1: { name: keyword.operator.assignment.augmented.protea }
          2: { name: keyword.operator.arithmetic.protea }
          3: { name: keyword.operator.successor.protea }
          4: { name: keyword.operator.logical.protea }
          5: { name: keyword.operator.bitwise.protea }
          6: { name: keyword.operator.bitwise.shift.protea }
          7: { name: keyword.operator.pipeline.protea }
          8: { name: keyword.operator.compose.protea }
          9: { name: keyword.operator.class.protea }
          10: { name: keyword.operator.relational.protea }
          11: { name: keyword.operator.comparison.protea }
          12: { name: keyword.operator.similarity.protea }
          13: { name: keyword.operator.function.protea }
          14: { name: keyword.operator.null-coalescing.protea }
          15: { name: keyword.operator.coalescing.protea }
          16: { name: keyword.operator.conditional.protea }
          17: { name: keyword.operator.ternary.protea }
          18: { name: keyword.operator.macro.protea }
          19: { name: keyword.operator.assignment.protea }
          20: { name: keyword.operator.range.protea }
          21: { name: keyword.operator.arrow.fat.protea }
          22: { name: keyword.operator.arrow.skinny.protea }
          23: { name: keyword.operator.arrow.wavy.protea }
          24: { name: keyword.operator.logical.custom.protea }
          25: { name: keyword.operator.arithmetic.custom.protea }
          26: { name: keyword.operator.prototype.custom.protea }
          27: { name: keyword.operator.accessor.custom.protea }
          28: { name: keyword.operator.comparison.custom.protea }
          29: { name: keyword.operator.relational.custom.protea }
          30: { name: keyword.operator.private.custom.protea }
          31: { name: keyword.operator.math.custom.protea }
          32: { name: keyword.operator.currency.custom.protea }
          33: { name: keyword.operator.ascii.custom.protea }
          34: { name: keyword.operator.infix.protea }

  primary-operators:
    patterns:
      - name: keyword.operator.primary.protea
        match: |
          (?x)
          (?<=['"`)}\]\w]|\\.) # closing
          (?:
            ( # 1: optional accessor
            \?[.:]=?
            ) |
            ( # 2: assertion/call operator
              ![.:]=?
            ) |
            ( # 3: accessor operator
              (?:::|\.)=?
            ) |
            ( # 4: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 5: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 6: string / regex
              \+\+ | --
            ) |
            ( # 7: logical operator
              \&\& | \|\| | \^\^ | !
            ) |
            ( # 8: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 9: bitwise shift
              <<<? | >>>?
            ) |
            ( # 10: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 11: composition
              <\+ | \+>
            ) |
            ( # 12: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 13: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 14: equality
              == | != | === | !==
            ) |
            ( # 15: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 16: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 17: null coalescing
              \?+
            ) |
            ( # 18: non null coalescing
              !+
            ) |
            ( # 19: falsy coalescing
              \?:
            ) |
            ( # 20: truthy coalescing
              !:
            ) |
            ( # 21: function application
              [.$]
            ) |
            ( # 22: assignment
              :?=
            ) |
            ( # 23: range
              [>.]\.[.<]
            ) |
            ( # 24: fat arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 25: skinny arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 26: wavy arrow
                [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 27: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 35: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 36: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            ) |
            ( # 37: catch all
              [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+
            )
          )
          (?=['"`\\({\[\w]) # opening
        captures:
          1: { name: keyword.operator.optional.protea }
          2: { name: keyword.operator.assert.protea }
          3: { name: keyword.operator.accessor.protea }
          4: { name: keyword.operator.assignment.augmented.protea }
          5: { name: keyword.operator.arithmetic.protea }
          6: { name: keyword.operator.successor.protea }
          7: { name: keyword.operator.logical.protea }
          8: { name: keyword.operator.bitwise.protea }
          9: { name: keyword.operator.bitwise.shift.protea }
          10: { name: keyword.operator.pipeline.protea }
          11: { name: keyword.operator.compose.protea }
          12: { name: keyword.operator.class.protea }
          13: { name: keyword.operator.relational.protea }
          14: { name: keyword.operator.comparison.protea }
          15: { name: keyword.operator.similarity.protea }
          16: { name: keyword.operator.function.protea }
          17: { name: keyword.operator.null-coalescing.protea }
          18: { name: keyword.operator.coalescing.protea }
          19: { name: keyword.operator.conditional.protea }
          20: { name: keyword.operator.ternary.protea }
          21: { name: keyword.operator.macro.protea }
          22: { name: keyword.operator.assignment.protea }
          23: { name: keyword.operator.range.protea }
          24: { name: keyword.operator.arrow.fat.protea }
          25: { name: keyword.operator.arrow.skinny.protea }
          26: { name: keyword.operator.arrow.wavy.protea }
          27: { name: keyword.operator.logical.custom.protea }
          28: { name: keyword.operator.arithmetic.custom.protea }
          29: { name: keyword.operator.prototype.custom.protea }
          30: { name: keyword.operator.accessor.custom.protea }
          31: { name: keyword.operator.comparison.custom.protea }
          32: { name: keyword.operator.relational.custom.protea }
          33: { name: keyword.operator.private.custom.protea }
          34: { name: keyword.operator.math.custom.protea }
          35: { name: keyword.operator.currency.custom.protea }
          36: { name: keyword.operator.ascii.custom.protea }
          37: { name: keyword.operator.primary.protea }

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*
      ['"`\\({\[\w])
    name: keyword.operator.prefix.protea
    captures:
      1: { name: keyword.operator.module.all.protea }
      2: { name: keyword.operator.increment.protea }
      3: { name: keyword.operator.decrement.protea }
      4: { name: keyword.operator.intersection.protea }
      5: { name: keyword.operator.union.protea }
      6: { name: keyword.operator.symmetric.protea }
      7: { name: keyword.operator.logical.protea }
      8: { name: keyword.operator.private.protea }
      9: { name: keyword.operator.decorator.protea }
      10: { name: keyword.operator.bitwise.not.protea }
      11: { name: keyword.operator.existential.protea }
      12: { name: keyword.operator.assignment.protea }
      13: { name: keyword.operator.pipeline.protea }
      14: { name: keyword.operator.private.protea }
      15: { name: keyword.operator.prefix.protea }

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.protea
    captures:
      1: { name: keyword.operator.module.all.protea }
      2: { name: keyword.operator.increment.protea }
      3: { name: keyword.operator.decrement.protea }
      4: { name: keyword.operator.intersection.protea }
      5: { name: keyword.operator.union.protea }
      6: { name: keyword.operator.symmetric.protea }
      7: { name: keyword.operator.assert.protea }
      8: { name: keyword.operator.private.protea }
      9: { name: keyword.operator.decorator.protea }
      10: { name: keyword.operator.bitwise.protea }
      11: { name: keyword.operator.optional.protea }
      12: { name: keyword.operator.assignment.protea }
      13: { name: keyword.operator.pipeline.protea }
      14: { name: keyword.operator.private.protea }
      15: { name: keyword.operator.suffix.protea }

  # Types

  types:
    patterns:
      - include: '#line-continuation'
      - include: '#argument-list'
      - include: '#angle-brackets'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#type-brackets'
      - match: \s+
        name: meta.type.protea

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|inter|object
          |trait|style|elem|prop
          |go|defer|do|with|from|where
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|pass|fail|goto
          |break|next|redo|retry
          |return|yield|await|mark
          |use|show|hide|route
          |debug|assert|check
        )
        (?!\B|\p{Pd}+\b)
      )

      (?:
        (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
        (?: # Properties
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
      )\b
    captures: &type-variables
      1: { name: entity.name.module.protea }
      2: { name: entity.name.tag.protea }
      3: { name: entity.name.namespace.protea }
      4: { name: entity.name.interface.protea }
      5: { name: entity.name.tag.block.protea }
      6: { name: entity.name.tag.script.protea }
      7: { name: entity.name.tag.style.protea }
      8: { name: entity.name.tag.inline.protea }
      9: { name: entity.name.label.protea }
      10: { name: entity.name.project.protea }
      11: { name: entity.name.class.protea }
      12: { name: entity.name.type.protea }

  type-signature:
    applyEndPatternLast: true
    name: meta.type.protea
    begin: (:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: { name: punctuation.definition.annotation.protea }
    patterns:
      - include: '#types'
      - match: \s+
        name: meta.type.protea

  type-embedded-expression:
    begin: (\${)\s*
    end: \s*(})
    name: entity.quasi.component.protea
    captures:
      1: { name: punctuation.definition.variable.protea }
    patterns:
      - include: '#types'
      - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - include: '#string-double-quoted'
      - include: '#string-single-quoted'
      - include: '#string-unquoted'

  type-embedded:
    patterns:
      - include: '#embedded-format'
      - include: '#type-embedded-expression'

  type-embedded-verbatim:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.protea
      - include: '#embedded-format'
      - include: '#type-embedded-expression'

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*):(?=['"`\\({\[\w\s]|$)
            name: punctuation.separator.key-value.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.typeparameters.protea }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.mapping.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.dictionary.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea
    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.parameters.protea }
        patterns:
          - include: '#param-bracket-content'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.protea }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.tuple.protea }
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.expression.protea }
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.attribute-selector.protea }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.binding-pattern.array.protea }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.tuple.protea }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.expression.protea }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.extends.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.implements.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as|is)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type|name|size|key)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1of.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inst)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.instanceof.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(val)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.valueof.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(attr)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.attributeof.protea

  type-operators:
    patterns:
      - match: \s*(--?>|~~?>)
        name: keyword.operator.type.function.protea
      - match: \s*(<--?|<~~?)
        name: keyword.operator.type.channel.protea
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: { name: keyword.operator.type.function.protea }
          2: { name: keyword.operator.type.channel.protea }
          3: { name: keyword.operator.type.function.protea }
          4: { name: keyword.operator.type.channel.protea }
      - &primary-operators
        comment: Primary binary operators
        match: (?<=['"`)}\]\w])(?:([>.]\.[.<])|(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=['"`\\({\[\w])
        captures:
          1: { name: keyword.operator.range.protea }
          2: { name: keyword.operator.optional.protea }
          3: { name: keyword.operator.assert.protea }
          4: { name: keyword.operator.accessor.protea }
      - comment: type operators
        match: \s*(?:(\+)|(\-)|(\*)|(\/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|([<>]))(?=$|[({\[\w'"\s])
        captures:
          1: { name: keyword.operator.sum.protea }
          2: { name: keyword.operator.difference.protea }
          3: { name: keyword.operator.product.protea }
          4: { name: keyword.operator.quotient.protea }
          5: { name: keyword.operator.remainder.protea }
          6: { name: keyword.operator.only.protea }
          7: { name: keyword.operator.maybe.protea }
          8: { name: keyword.operator.intersection.protea }
          9: { name: keyword.operator.union.protea }
          10: { name: keyword.operator.symmetric.protea }
          11: { name: keyword.operator.negation.protea }
          12: { name: keyword.operator.macro.dollar.protea }
          13: { name: keyword.operator.class.protea }

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: { name: punctuation.definition.parameters.protea }
    patterns:
      - include: '#param-bracket-content'
      - include: $self

  declaration-clause:
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
        name: entity.name.namespace.protea
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: { name: storage.type.implements.protea }
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.namespace.protea
          - match: *entity-name
            name: entity.name.trait.protea
          - include: '#comments'
          - include: '#brackets'
          - include: '#comma'
          - include: '#line-continuation'
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: { name: storage.type.extends.protea }
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.module.protea
          - match: *entity-name
            name: entity.name.interface.protea
          - include: '#comments'
          - include: '#brackets'
          - include: '#comma'
          - include: '#line-continuation'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.protea
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - include: '#type-keywords'
      - include: '#type-square-brackets'
      - include: '#brackets'
      - include: '#type-signature'
      - include: '#literals'
      - applyEndPatternLast: true
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]))
        end: (?=)|$
        beginCaptures:
          1: { name: punctuation.definition.annotation.protea }
        patterns:
          - include: '#types'
      - match: '\.|::'
        name: punctuation.separator.namespace.protea
      - match: \s+
        name: meta.block.protea

  modifier-keywords:
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
            )
            (?!\B|\p{Pd}+\b)
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|inter|object
          |trait|style|elem|prop
        )
        (?!\B|\p{Pd}+\b)
      )
    captures:
      1:
        patterns:
          - include: '#modifiers'

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            pub|priv|prot|final|immut|mut|def
            |global|local|intern|extern|imply|exply
            |post|[gs]et|del
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.modifier.protea
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            seal|abst|impure|pure|early|late
            |covar|contra|a?sync|stat|dyn|lazy
            |eager|bound|free|uniq|struct|union
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.type.accessor.protea
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            rec|oper|curry|inline|req|opt
            |prefix|suffix|infix|binary|unary|left|right
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.type.property.protea

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl|def)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.declare.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.style.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.function.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.procedure.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.class.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.data.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.enum.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.module.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.iterator.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.macro.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.structure.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.object.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.trait.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.component.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.property.protea

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif|else)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.conditional.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.loop.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|after)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.trycatch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|case|fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.switch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|mark|yield|goto|pass)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.flow.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(use|show|hide|route)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.module.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from|ref|go|defer)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.$1.protea

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.delete.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|thru|by)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.range.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.void.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.logical.protea

  keywords:
    patterns:
      - include: '#modifier-keywords'
      - include: '#validation-expression'
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

    repository:
      control-expression:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|mark|goto|pass)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.control.flow.protea }
        patterns:
          - match: *entity-name
            name: constant.other.label.protea

      module-expression:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(use|show|hide|route)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.control.module.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|only|just|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.module.protea
              - include: '#type-keywords'
              - include: '#declarations'
              - include: '#strings'
              - include: '#symbols'
              - include: '#type-operators'
              - match: ','
                name: punctuation.separator.comma.protea
              - match: *entity-name
                name: variable.other.readwrite.alias.protea

      validation-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: { name: keyword.control.validate.protea }
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.protea
          - include: $self

      query-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: { name: keyword.control.query.protea }
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      query-body:
        patterns:
          - include: '#in-clause'
          - include: '#where-clause'
          - include: '#join-clause'
          - include: '#sort-clause'
          - include: '#select-clause'
          - include: '#group-clause'
          - include: '#limit-clause'
          - include: '#reduce-clause'

        repository:
          in-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
              2: { patterns: [include: $self] }
              3: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          join-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part|self|cross)?(?!\B|\p{Pd}+\b)\s*\b(?:inner|outer|left|right)?(?!\B|\p{Pd}+\b)\s*\bjoin)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
              2: { patterns: [include: $self] }
              3: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          where-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having|filter|reject)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          sort-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:sort|order)(?!\B|\p{Pd}+\b)\s*\b(?:asc|desc)?(?!\B|\p{Pd}+\b)\s*\b(?:by|with)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          select-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:select|map)(?!\B|\p{Pd}+\b)\s*\b(?:unique|any|all)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          limit-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit|offset)(?!\B|\p{Pd}+\b)\s*\b(?:first|last|head|tail)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          reduce-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?!\B|\p{Pd}+\b)\s*\b(?:left|right)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          group-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: { name: keyword.control.query.protea }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

  declarations:
    patterns:
      - include: '#variable'
      - include: '#declare'
      - include: '#style'
      - include: '#markup'
      - include: '#function'
      - include: '#procedure'
      - include: '#class'
      - include: '#data'
      - include: '#enum'
      - include: '#module'
      - include: '#iterator'
      - include: '#macro'
      - include: '#structure'
      - include: '#object'
      - include: '#trait'
      - include: '#component'
      - include: '#property'

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.style.protea }
        name: meta.style.protea
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.style.protea

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.component.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.component.protea
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.variable.protea }

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.other.declare.protea }

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.function.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.function.protea

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.procedure.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.procedure.protea

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.class.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.class.protea

      data:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.data.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.data.protea

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.enum.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.enum.protea

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.module.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.module.protea

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.iterator.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.iterator.protea

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.macro.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.macro.protea

      structure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.structure.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.structure.protea

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.object.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.object.protea

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.trait.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.trait.protea

      property:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.property.protea }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.property.protea

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.method.protea }
          2: { name: keyword.operator.assignment.protea }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.method.protea }
          2: { name: keyword.operator.assignment.protea }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.protea }
        endCaptures:
          1: { name: punctuation.separator.arguments.protea }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.function.protea }
          2: { name: keyword.operator.assignment.protea }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.function.protea }
          2: { name: keyword.operator.assignment.protea }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.protea }
        endCaptures:
          1: { name: punctuation.separator.arguments.protea }
        patterns:
          - include: '#param-bracket-content'
          - include: $self

  argument-list:
    name: meta.function.arguments.protea
    begin: |
      (?x)
      (?<=
        (?:
          # beginning of line
          ^
        | # or before a delimiter
          [,;({\[]
        | # operator
          [\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]+ \s
        | (?:
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|with|from|where
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|mark
                |use|show|hide|route
                |debug|assert|check
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
          )
        )
      ) \s* # before a space
      (\|)(?!\|)
    captures:
      1: { name: punctuation.separator.arguments.protea }
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: '#param-bracket-content'
      - include: $self

  clauses:
    patterns:
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#do-clause'
      - include: '#type-clause'
      - include: '#new-clause'
      - include: '#case-clause'

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?!\B|\p{Pd}+\b)
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.operator.expression.$1.protea }
        patterns:
          - match: *entity-name
            name: entity.name.instance.protea
          - include: '#type-keywords'
          - include: '#type-square-brackets'
          - include: '#parameter-brackets'
          - include: '#round-brackets'

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.operator.expression.$1.protea }
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            captures:
              1: { name: keyword.other.typedef.protea }
            patterns:
              - include: '#types'
              - match: \s*([?:]?=)\s*
                captures:
                  1: { name: keyword.operator.assignment.protea }

      catch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.catch.protea
        captures:
          1: { name: keyword.control.error.protea }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.protea
              - include: $self

      for-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|while)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.for.protea
        captures:
          1: { name: keyword.control.loop.protea }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.loop.protea
              - include: $self

      if-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.if.protea
        captures:
          1: { name: keyword.control.conditional.protea }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.conditional.protea
              - include: $self

      match-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.switch.protea
        captures:
          1: { name: keyword.control.match.protea }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.match.protea
              - include: $self

      case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.protea
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*(?=\()
            end: (?=)|$
            captures:
              1: { name: keyword.control.match.protea }
            patterns:
              - begin: \s*(\()\s*
                end: \s*(\))
                captures:
                  1: { name: punctuation.definition.expression.protea }
                patterns:
                  - include: '#argument-list'
                  - applyEndPatternLast: true
                    begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                    end: (?=)|$
                    beginCaptures:
                      1: { name: keyword.control.match.protea }
                    patterns:
                      - include: '#types'
                  - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.match.protea
                  - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.match.protea
                  - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|only|just|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.match.protea
                  - include: '#type-keywords'
                  - include: $self

      with-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.with.protea
        captures:
          1: { name: keyword.control.with.protea }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.protea }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await|as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.with.protea
              - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.function.protea }
          2: { name: punctuation.separator.key-value.protea }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|def
                |global|local|intern|extern|imply|exply
                |post|[gs]et|del

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct|union

                |rec|oper|curry|inline|req|opt
                |prefix|suffix|infix|binary|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.protea
        captures:
          1: { name: entity.name.function.protea }
          2: { name: punctuation.separator.key-value.protea }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.protea }
        endCaptures:
          1: { name: punctuation.separator.arguments.protea }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - match: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`\\({\[)}\]\w\s])
        name: meta.object-literal.key.protea
        captures:
          1:
            name: constant.other.object.key.protea
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#string-content'

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(\\)\s*(?=/[/*]\s|$)
    end: ^\s*
    captures:
      1: { name: punctuation.separator.continuation.line.protea }
    patterns:
      - include: '#comments'
  comma:
    match: \s*(,)
    name: punctuation.separator.comma.protea
  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.protea
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.protea

  brackets:
    patterns:
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'
      - include: '#angle-brackets'

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]\w\s])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: { name: punctuation.type.arguments.protea }
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`\\({\[)}\]\p{Pc}]]*):(?=['"`\\({\[\w\s]|$)
            name: punctuation.separator.key-value.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.typeparameters.protea }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.binding-pattern.object.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.mapping.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.dictionary.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.section.class.protea }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.block.protea }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.mapping.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.dictionary.protea }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.section.class.protea }
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.protea
        captures:
          1: { name: punctuation.definition.block.protea }
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.parameters.protea }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.protea }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.tuple.protea }
        patterns:
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.protea
        captures:
          1: { name: punctuation.definition.expression.protea }
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.attribute-selector.protea }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`({\[)}\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`\\({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.binding-pattern.array.protea }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.tuple.protea }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.protea
        captures:
          1: { name: punctuation.definition.expression.protea }
        patterns:
          - include: '#punctuation'
          - include: $self

  # Support

  css-property-names:
    match: (?x)\b( additive-symbols|additiveSymbols|adjust|after|align|align-content|align-items|align-last|align-self|alignContent|alignItems|alignLast|alignment|alignment-adjust|alignment-baseline|alignmentAdjust|alignmentBaseline|alignSelf|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|appearance|attachment|azimuth|backdrop-filter|backdropFilter|backface-visibility|backfaceVisibility|background|background-attachment|background-blend-mode|background-break|background-clip|background-color|background-image|background-origin|background-position|background-position-[xy]|background-repeat|background-size|backgroundAttachment|backgroundBlendMode|backgroundBreak|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|balance|baseline|baseline-shift|baselineShift|before|bidi|binding|bleed|block-size|blockSize|bookmark|bookmark-label|bookmark-level|bookmark-target|bookmarkLabel|bookmarkLevel|bookmarkTarget|border|border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color|border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end|border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color|border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width|border-length|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius|border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderLength|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|box-align|box-decoration-break|box-direction|box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|boxAlign|boxDecorationBreak|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|boxShadow|boxSizing|break|break-after|break-before|break-inside|breakAfter|breakBefore|breakInside|caption-side|captionSide|caret-color|caretColor|character|clear|clip|clip-path|clip-rule|clipPath|clipRule|collapse|color|color-adjust|color-interpolation|color-interpolation-filters|color-profile|color-rendering|colorAdjust|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|column|column-break-after|column-break-before|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columnBreakAfter|columnBreakBefore|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columns|columnSpan|columnWidth|contain|content|count|counter|counter-increment|counter-reset|counterIncrement|counterReset|crop|cue|cue-after|cue-before|cueAfter|cueBefore|cursor|cx|cy|decoration|decoration-break|decorationBreak|delay|direction|display|display-model|display-role|displayModel|displayRole|dominant-baseline|dominantBaseline|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|empty-cells|emptyCells|enable-background|enableBackground|fallback|family|fill|fill-opacity|fill-rule|fillOpacity|fillRule|filter|fit|fit-position|fitPosition|flex|flex-basis|flex-direction|flex-flow|flex-group|flex-grow|flex-shrink|flex-wrap|flexBasis|flexDirection|flexFlow|flexGroup|flexGrow|flexShrink|flexWrap|float|float-offset|floatOffset|flood-color|flood-opacity|floodColor|floodOpacity|font|font-display|font-family|font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch|font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures|font-variant-numeric|font-variant-position|font-variation-settings|font-weight|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyph-orientation-horizontal|glyph-orientation-vertical|glyphOrientationHorizontal|glyphOrientationVertical|grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start|grid-columns|grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-rows|grid-template|grid-template-areas|grid-template-columns|grid-template-rows|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumns|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRows|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hanging-punctuation|hangingPunctuation|header|height|hyphenate|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|hyphens|icon|image|image-orientation|image-rendering|image-resolution|imageOrientation|imageRendering|imageResolution|ime-mode|imeMode|increment|indent|index|initial-after-adjust|initial-after-align|initial-before-adjust|initial-before-align|initial-letter|initial-letter-align|initial-size|initial-value|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialLetter|initialLetterAlign|initialSize|initialValue|inline-box-align|inline-size|inlineBoxAlign|inlineSize|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|iteration-count|iterationCount|justify|justify-content|justify-items|justify-self|justifyContent|justifyItems|justifySelf|kerning|label|left|left-color|left-style|left-width|leftColor|leftStyle|leftWidth|length|letter-spacing|letterSpacing|level|lighting-color|lightingColor|line|line-break|line-clamp|line-height|line-stacking|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|lineBreak|lineClamp|lineHeight|lines|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|list|list-style|list-style-image|list-style-position|list-style-type|listStyle|listStyleImage|listStylePosition|listStyleType|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start|margin-left|margin-right|margin-top|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|mark|mark-after|mark-before|markAfter|markBefore|marker-end|marker-mid|marker-start|markerEnd|markerMid|markerStart|marks|marquee|marquee-direction|marquee-play-count|marquee-speed|marquee-style|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|mask|mask-border|mask-border-mode|mask-border-outset|mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode|mask-origin|mask-position|mask-repeat|mask-size|mask-type|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|max|max-block-size|max-height|max-inline-size|max-lines|max-width|max-zoom|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|min|min-block-size|min-height|min-inline-size|min-width|min-zoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mix-blend-mode|mixBlendMode|model|move-to|moveTo|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|navDown|navIndex|navLeft|navRight|navUp|negative|new|numeral|object-fit|object-position|objectFit|objectPosition|offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|ordinal-group|ordinalGroup|orient|orientation|origin|orphans|outline|outline-color|outline-offset|outline-style|outline-width|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflow-[xy]|overflow-anchor|overflow-block|overflow-inline|overflow-style|overflow-wrap|overflow[XY]|overflowAnchor|overflowBlock|overflowInline|overflowStyle|overflowWrap|overhang|overscroll-behavior|overscroll-behavior-[xy]|overscroll-behavior-block|overscroll-behavior-inline|overscrollBehavior|overscrollBehavior[XY]|overscrollBehaviorBlock|overscrollBehaviorInline|pack|pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left|padding-right|padding-top|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|page|page-break-after|page-break-before|page-break-inside|page-policy|pageBreakAfter|pageBreakBefore|pageBreakInside|pagePolicy|paint-order|paintOrder|pause|pause-after|pause-before|pauseAfter|pauseBefore|perspective|perspective-origin|perspectiveOrigin|phonemes|pitch|pitch-range|pitchRange|place-content|place-items|place-self|placeContent|placeItems|placeSelf|play-count|play-during|play-state|playCount|playDuring|playState|point|pointer-events|pointerEvents|position|prefix|presentation|presentation-level|presentationLevel|profile|property|punctuation|punctuation-trim|punctuationTrim|quotes|r|radius|range|rate|rendering-intent|renderingIntent|repeat|replace|reset|resize|resolution|resource|respond-to|respondTo|rest|rest-after|rest-before|restAfter|restBefore|richness|right|right-color|right-style|right-width|rightColor|rightStyle|rightWidth|role|rotate|rotation|rotation-point|rotationPoint|row-gap|rowGap|rows|ruby|ruby-align|ruby-merge|ruby-overhang|ruby-position|ruby-span|rubyAlign|rubyMerge|rubyOverhang|rubyPosition|rubySpan|rule|rule-color|rule-style|rule-width|ruleColor|ruleStyle|ruleWidth|rx|ry|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start|scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right|scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom|scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right|scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type|scrollbar-color|scrollbar-gutter|scrollbar-width|scrollbarColor|scrollbarGutter|scrollbarWidth|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|shadow|shape-image-threshold|shape-margin|shape-outside|shape-rendering|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|size-adjust|sizeAdjust|sizing|space|space-collapse|spaceCollapse|spacing|span|speak|speak-as|speak-header|speak-numeral|speak-punctuation|speakAs|speakHeader|speakNumeral|speakPunctuation|speech|speech-rate|speechRate|speed|src|stacking|stacking-ruby|stacking-shift|stacking-strategy|stackingRuby|stackingShift|stackingStrategy|stop-color|stop-opacity|stopColor|stopOpacity|stress|stretch|string-set|stringSet|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|style|style-image|style-position|style-type|styleImage|stylePosition|styleType|suffix|symbols|system|tab-size|table-layout|tableLayout|tabSize|target|target-name|target-new|target-position|targetName|targetNew|targetPosition|text|text-align|text-align-last|text-anchor|text-combine-upright|text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style|text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-height|text-indent|text-justify|text-orientation|text-outline|text-overflow|text-rendering|text-replace|text-shadow|text-size-adjust|text-transform|text-underline-position|text-wrap|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textHeight|textIndent|textJustify|textOrientation|textOutline|textOverflow|textRendering|textReplace|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|textWrap|timing-function|timingFunction|top|top-color|top-left-radius|top-right-radius|top-style|top-width|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|touch-action|touchAction|transform|transform-box|transform-origin|transform-style|transformBox|transformOrigin|transformStyle|transition|transition-delay|transition-duration|transition-property|transition-timing-function|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|trim|unicode|unicode-bidi|unicode-range|unicodeBidi|unicodeRange|up|user-select|user-zoom|userSelect|userZoom|variant|vertical-align|verticalAlign|visibility|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range|voice-rate|voice-stress|voice-volume|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|white-space|white-space-collapse|whiteSpace|whiteSpaceCollapse|widows|width|will-change|willChange|word|word-break|word-spacing|word-wrap|wordBreak|wordSpacing|wordWrap|wrap|writing-mode|writingMode|x|y|z-index|zIndex|zoom )(?!\B|\p{Pd}+\b)
    name: support.type.property-name.css.protea

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b( aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-standard-color-name.css.protea
      - match: (?x)\b( aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-extended-color-name.css.protea
      - match: (?x)\b(currentColor)(?!\B|\p{Pd}+\b)
        name: support.constant.color.current.css.protea
      - match: (?x)\b( ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText )(?!\B|\p{Pd}+\b)
        name: support.constant.color.system.css.protea
      - match: (?x)\b( above|absolute|active|add|additive|after-edge|afterEdge|alias|all|all-petite-caps|all-scroll|all-small-caps|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternate-reverse|alternateReverse|always|antialiased|auto|auto-pos|autoPos|available|avoid|avoid-column|avoid-page|avoid-region|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|before-edge|beforeEdge|below|bevel|bidi-override|bidiOverride|blink|block|block-axis|block-end|block-start|blockAxis|blockEnd|blockStart|bold|bolder|border|border-box|borderBox|both|bottom|bottom-outside|bottomOutside|break-all|break-word|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closeQuote|closest-corner|closest-side|closestCorner|closestSide|col-resize|collapse|color|color-burn|color-dodge|colorBurn|colorDodge|colResize|column|column-reverse|columnReverse|common-ligatures|commonLigatures|compact|condensed|contain|content|content-box|contentBox|contents|context-menu|contextMenu|contextual|copy|cover|crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|diagonalFractions|difference|digits|disabled|disc|discretionary-ligatures|discretionaryLigatures|distribute|distribute-all-lines|distribute-letter|distribute-space|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|double-circle|doubleCircle|downleft|downright|e-resize|each-line|eachLine|ease|ease-in|ease-in-out|ease-out|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|eResize|evenodd|ew-resize|ewResize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded|extraCondensed|extraExpanded|fallback|farthest-corner|farthest-side|farthestCorner|farthestSide|fill|fill-available|fill-box|fillAvailable|fillBox|filled|fit-content|fitContent|fixed|flat|flex|flex-end|flex-start|flexEnd|flexStart|flip|flow-root|flowRoot|forwards|free|from-image|fromImage|full-width|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|hardLight|help|hidden|hide|historical-forms|historical-ligatures|historicalForms|historicalLigatures|horizontal|horizontal-tb|horizontalTb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographAlpha|ideographic|ideographNumeric|ideographParenthesis|ideographSpace|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start|inline-table|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|inter-character|inter-ideograph|inter-word|interCharacter|interIdeograph|intersect|interWord|invert|isolate|isolate-override|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justify-all|justifyAll|kannada|keep-all|keepAll|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB|lineEdge|lineThrough|lining-nums|liningNums|list-item|listItem|local|loose|lowercase|lr|lr-tb|lrTb|ltr|luminance|luminosity|main-size|mainSize|mandatory|manipulation|manual|margin-box|marginBox|match-parent|match-source|matchParent|matchSource|mathematical|max-content|maxContent|medium|menu|message-box|messageBox|middle|min-content|minContent|miter|mixed|move|multiply|n-resize|narrower|ne-resize|nearest-neighbor|nearestNeighbor|neResize|nesw-resize|neswResize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures|no-drop|no-historical-ligatures|no-open-quote|no-repeat|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|none|nonzero|noOpenQuote|noRepeat|normal|not-allowed|notAllowed|nowrap|nResize|ns-resize|nsResize|numbers|numeric|nw-resize|nwResize|nwse-resize|nwseResize|oblique|oldstyle-nums|oldstyleNums|open|open-quote|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|padding-box|paddingBox|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|panDown|panLeft|panRight|panUp|panX|panY|paused|petite-caps|petiteCaps|pixelated|plaintext|pointer|portrait|pre|pre-line|pre-wrap|preLine|preserve-3d|preserve3d|preWrap|progress|progressive|proportional-nums|proportional-width|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|repeat[xy]|reset-size|resetSize|reverse|revert|ridge|right|rl|rl-tb|rlTb|round|row|row-resize|row-reverse|row-severse|rowResize|rowReverse|rowSeverse|rtl|ruby|ruby-base|ruby-base-container|ruby-text|ruby-text-container|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|run-in|runIn|running|s-resize|saturation|scale-down|scaleDown|screen|scroll|scroll-position|scrollPosition|se-resize|semi-condensed|semi-expanded|semiCondensed|semiExpanded|separate|seResize|sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashed-zero|slashedZero|slice|small|small-caps|small-caption|smallCaps|smallCaption|smaller|smooth|soft-light|softLight|solid|space|space-around|space-between|space-evenly|spaceAround|spaceBetween|spaceEvenly|spell-out|spellOut|square|sResize|sRGB|stacked-fractions|stackedFractions|start|static|status-bar|statusBar|step-end|step-start|stepEnd|stepStart|sticky|stretch|strict|stroke|stroke-box|strokeBox|structze|style|sub|subgrid|subpixel-antialiased|subpixelAntialiased|subtract|super|sw-resize|swap|swResize|symbolic|table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabular-nums|tabularNums|tb|tb-rl|tbRl|text|text-after-edge|text-before-edge|text-bottom|text-top|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titling-caps|titlingCaps|top|top-outside|topOutside|touch|traditional|transparent|triangle|ultra-condensed|ultra-expanded|ultraCondensed|ultraExpanded|under|underline|unicase|uniq|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|useGlyphOrientation|useScript|verso|vertical|vertical-ideographic|vertical-lr|vertical-rl|vertical-text|verticalIdeographic|verticalLr|verticalRl|verticalText|view-box|viewBox|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy|weight|whitespace|wider|words|wrap|wrap-reverse|wrapReverse|wResize|x|x-large|x-small|xLarge|xSmall|xx-large|xx-small|xxLarge|xxSmall|y|zero|zoom-in|zoom-out|zoomIn|zoomOut )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.css.protea
      - match: (?x)\b( arabic-indic|arabicIndic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimal-leading-zero|decimalLeadingZero|devanagari|disc|disclosure-closed|disclosure-open|disclosureClosed|disclosureOpen|ethiopic-halehame-am|ethiopic-halehame-ti-e[rt]|ethiopic-numeric|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hangulConsonant|hebrew|hiragana|hiragana-iroha|hiraganaIroha|japanese-formal|japanese-informal|japaneseFormal|japaneseInformal|kannada|katakana|katakana-iroha|katakanaIroha|khmer|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lower-alpha|lower-armenian|lower-greek|lower-latin|lower-roman|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|tradChineseFormal|tradChineseInformal|upper-alpha|upper-armenian|upper-latin|upper-roman|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.list-style-type.css.protea
      - match: (?x)\b( arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|monospace|sans-serif|sansSerif|serif|symbol|system|system-ui|systemUi|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings )(?!\B|\p{Pd}+\b)
        name: support.constant.font-name.css.protea

  html-tag-names:
    patterns:
      - match: (?x)\b( all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv )(?!\B|\p{Pd}+\b)
        name: support.constant.media.css.protea
      - match: (?x)\b( a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|element|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp )(?!\B|\p{Pd}+\b)
        name: entity.name.tag.css.protea

  entities:
    patterns:
      - include: '#function-names'
      - include: '#constant-names'
      - include: '#type-names'
      - include: '#variable-names'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)
            |Imag|Comp|Char|Rune|Str|Sym
            |(U?Int|[UI])(8|16|32|64|128)
            |([CI]?Float|[CI]?F)(16|32|64|128)
            # lower flat case
            |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)
            |imag|comp|char|rune|str|sym
            |(u?int|[ui])(8|16|32|64|128)
            |([ci]?float|[ci]?f)(16|32|64|128)
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.primitive.protea
      - comment: Data structure classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|List|Set|Hash|Seq|Str|Dict|Iter
            |Proc|Range|Stack|Heap|Queue|Tree|Trie|Rec
            |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
            # lower flat case
            |array|tuple|list|set|hash|seq|str|dict|iter
            |proc|range|stack|heap|queue|tree|trie|rec
            |future|stream|regexp?|func|buf|strbuf|bytes
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.protea
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Infin|Empty|Unit|Obj
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const
            # lower flat case
            |true|false|null|void|nan|infin|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const
          )(?!\B|\p{Pd}+\b)
        name: support.type.primitive.protea
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)(?!\B|\p{Pd}+\b)
        name: support.class.error.protea
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.interface.protea
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.namespace.protea
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able(?!\B|\p{Pd}+\b)
        name: support.class.trait.protea

  support-functions:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: Python and Perl 6/Raku built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)
          (
            # Python
            import|abs|all|any|ascii|bin|breakpoint|callable|chr|compile
            |copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter
            |format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance
            |issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct
            |open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted
            |sum|vars|zip|file|reduce|intern|rawInput|unicode|cmp|basestring|execfile
            |long|xrange|bool|bytearray|bytes|classmethod|complex|dict|float|frozenset
            |int|list|object|property|set|slice|staticmethod|str|tuple|type

            # JavaScript
            |isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI
            |decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|require
            |(?:clear|set)(?:Interval|Timeout)

            # Go
            |append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println
            |real|recover

            # Lua
            |coroutine|create|resume|running|status|wrap|yield|string|byte|char|dump|find
            |format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper|table|concat|insert
            |maxn|remove|sort|math|abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp
            |ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?
            |io|close|flush|input|lines|open|output|popen|read|tmpfile|type|write
            |os|clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname
            |package|cpath|loaded|loadlib|path|preload|seeall|debug|debug|[gs]etfenv
            |[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue
            |traceback|assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs
            |loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawset
            |require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall

            # Perl
            |eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints|chmod|split|reduce
            |min|max|reverse|truncate|zip|cat|roundrobin|classify|first|sum|keys|values|pairs
            |defined|delete|exists|elems|end|kv|any|all|one|wrap|shape|key|value|name|pop|push
            |shift|splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt|sin|cos|tan
            |round|strand|roots|cis|unpolar|polar|atan2|pick|chop|p5chop|chomp|p5chomp|lc
            |lcfirst|uc|ucfirst|capitalize|normalize|pack|unpack|quotemeta|comb|samecase
            |sameaccent|chars|nfd|nfc|nfkd|nfkc|printf|sprintf|caller|evalfile|run|runinstead
            |nothing|want|bless|chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin
            |getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print|open|read|write
            |readline|say|seek|close|opendir|readdir|slurp|spurt|shell|run|pos|fmt|vec|link
            |unlink|symlink|uniq|pair|asin|atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh
            |tanh|asinh|done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh|asech|ok
            |nok|planOk|diesOk|livesOk|skip|todo|pass|flunk|forceTodo|useOk|isaOk|diag|isDeeply
            |isnt|like|skipRest|unlike|cmpOk|evalDiesOk|nokError|evalLivesOk|approx|isApprox
            |throwsOk|versionLt|plan|eval|succ|pred|times|nonce|once|signature|new|connect
            |operator|undef|undefine|sleep|from|to|infix|postfix|prefix|circumfix|postcircumfix
            |minmax|lazy|count|unwrap|getc|pi|e|context|void|quasi|body|each|contains|rewinddir
            |subst|can|isa|flush|arity|assuming|rewind|callwith|callsame|nextwith|nextsame|attr
            |evalElsewhere|none|srand|trim|trimStart|trimEnd|lastcall|what|where|how|which|var
            |who|whence|accepts|rejects|not|true|iterator|by|re|im|invert|flip|gist|flat|tree
            |isPrime|throwsLike|trans
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.protea
      - comment: JavaScript StdLib functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
            scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
            sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|
            Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
            Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
            savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
            contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
            createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
            test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
            untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins|refresh|paddings|parse|
            print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
            fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
            forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
            abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
            releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
            Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
            Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
            moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.protea
      - comment: Python magic functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)
          (
            \p{Pc}+ (?:
              abs|add|aenter|aexit|aiter|and|anext|await|bool|call|ceil|cmp|coerce|complex
              |contains|copy|deepcopy|del|delattr|delete|delitem|delslice|dir|div|divmod|enter
              |eq|exit|float|floor|floordiv|format|ge|get|getattr|getattribute|getinitargs
              |getitem|getnewargs|getslice|getstate|gt|hash|hex|iadd|iand|idiv|ifloordiv|ilshift
              |imod|imul|index|init|instancecheck|int|invert|ior|ipow|irshift|isub|iter|itruediv
              |ixor|le|len|long|lshift|lt|missing|mod|mul|ne|neg|new|next|nonzero|oct|or|pos|pow
              |radd|rand|rdiv|rdivmod|reduce|reduceEx|repr|reversed|rfloordiv|rlshift|rmod|rmul
              |ror|round|rpow|rrshift|rshift|rsub|rtruediv|rxor|set|setattr|setitem|setslice
              |setstate|sizeof|str|sub|subclasscheck|truediv|trunc|unicode|xor|matmul|rmatmul
              |imatmul|initSubclass|setName|fspath|bytes|prepare|all|bases|builtins|class
              |classGetitem|code|debug|defaults|dict|doc|file|fn|kwdefaults|members|metaclass
              |methods|module|mro|mroEntries|name|qualname|postInit|self|signature|slots
              |subclasses|version|weakref|wrapped|annotations|classcell|spec|path|package
              |future|traceback
            ) \p{Pc}+
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea
      - comment: CSS, LESS and SASS functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            abs|acos|alpha|argb|asin|atan|average|blue|calc|ceil
            |color|contrast|convert|convert|cos|darken|data-uri
            |desaturate|difference|e|escape|exclusion|extract
            |fade|fadein|fadeout|floor|format|green|greyscale
            |hardlight|hsl|hsla|hsv|hsva|hsvhue|hsvsaturation
            |hsvvalue|hue|length|lighten|lightness|luma|max|min
            |mix|mod|multiply|negation|overlay|percentage|pi|pow
            |red|replace|round|saturate|saturation|screen|sin
            |softlight|spin|sqrt|tan|unit
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea
      - comment: Ruby kernel functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            # Ruby builtin functions
            abort|atExit|autoload|binding|callcc|caller|callerLocations
            |chomp|chop|eval|exec|exit|exit|fork|format|gets
            |globalVariables|gsub|lambda|load|localVariables|open
            |p|print|printf|proc|putc|puts|rand|readline|readlines
            |select|setTraceFunc|sleep|spawn|sprintf|srand|sub
            |syscall|system|test|traceVar|trap|untraceVar|warn

            # C StdLib
            |abort|abs|acos|asctime|asctimeR|asin|assert|atan|atan2|atexit|atof|atoi|atol|bsearch|btowc|calloc
            |catclose6|catgets6|catopen6|ceil|clearerr|clock|cos|cosh|ctime|ctime64|ctimeR|ctime64R|difftime
            |difftime64|div|erf|erfc|exit|exp|fabs|fclose|fdopen5|feof|ferror|fflush1|fgetc1|fgetpos1|fgets1
            |fgetwc6|fgetws6|fileno5|floor|fmod|fopen|fprintf|fputc1|fputs1|fputwc6|fputws6|fread|free|freopen
            |frexp|fscanf|fseek1|fsetpos1|ftell1|fwide6|fwprintf6|fwrite|fwscanf6|gamma|getc1|getchar1|getenv
            |gets|getwc6|getwchar6|gmtime|gmtime64|gmtimeR|gmtime64R|hypot|isalnum|isalpha|isascii4|isblank
            |iscntrl|isdigit|isgraph|islower|isprint|ispunct|isspace|isupper|iswalnum4|iswalpha4|iswblank4
            |iswcntrl4|iswctype4|iswdigit4|iswgraph4|iswlower4|iswprint4|iswpunct4|iswspace4|iswupper4|iswxdigit4
            |isxdigit4|j0|j1|jn|labs|ldexp|ldiv|localeconv|localtime|localtime64|localtimeR|localtime64R
            |log|log10|longjmp|malloc|mblen|mbrlen4|mbrtowc4|mbsinit4|mbsrtowcs4|mbstowcs|mbtowc|memchr|memcmp
            |memcpy|memmove|memset|mktime|mktime64|modf|nextafter|nextafterl|nexttoward|nexttowardl
            |nlLanginfo4|perror|pow|printf|putc1|putchar1|putenv|puts|putwc6|putwchar6|qsort|quantexpd32
            |quantexpd64|quantexpd128|quantized32|quantized64|quantized128|samequantumd32|samequantumd64
            |samequantumd128|raise|rand|randR|realloc|regcomp|regerror|regexec|regfree|remove|rename|rewind1
            |scanf|setbuf|setjmp|setlocale|setvbuf|signal|sin|sinh|snprintf|sprintf|sqrt|srand|sscanf
            |strcasecmp|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strfmon4|strftime|strlen
            |strncasecmp|strncat|strncmp|strncpy|strpbrk|strptime4|strrchr|strspn|strstr|strtod|strtod32
            |strtod64|strtod128|strtof|strtok|strtokR|strtol|strtold|strtoul|strxfrm|swprintf|swscanf|system
            |tan|tanh|time|time64|tmpfile|tmpnam|toascii|tolower|toupper|towctrans|towlower4|towupper4|ungetc1
            |ungetwc6|vaArg|vaCopy|vaEnd|vaStart|vfprintf|vfscanf|vfwprintf6|vfwscanf|vprintf|vscanf|vsprintf
            |vsnprintf|vsscanf|vswprintf|vswscanf|vwprintf6|vwscanf|wcrtomb4|wcscat|wcschr|wcscmp|wcscoll4|wcscpy
            |wcscspn|wcsftime|wcslen|wcslocaleconv|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsptime|wcsrchr|wcsrtombs4
            |wcsspn|wcsstr|wcstod|wcstod32|wcstod64|wcstod128|wcstof|wcstok|wcstol|wcstold|wcstombs|wcstoul
            |wcsxfrm4|wctob|wctomb|wctrans|wctype4|wcwidth|wmemchr|wmemcmp|wmemcpy|wmemmove|wmemset|wprintf6
            |wscanf6|y0|y1|yn
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.kernel.protea
      - comment: Event handler functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            on(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
            Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
            Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|
            Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
            Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
            Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
            Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
            Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.event-handler.protea
      - comment: DOM functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
            appendChild|appendData|before|blur|canPlayType|captureStream|
            caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
            cloneContents|cloneNode|cloneRange|close|closest|collapse|
            compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
            convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
            createAttributeNS|createCaption|createCDATASection|createComment|
            createContextualFragment|createDocument|createDocumentFragment|
            createDocumentType|createElement|createElementNS|createEntityReference|
            createEvent|createExpression|createHTMLDocument|createNodeIterator|
            createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
            createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
            deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
            deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
            enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
            exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
            getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
            getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
            getClientRects|getContext|getDestinationInsertionPoints|getElementById|
            getElementsByClassName|getElementsByName|getElementsByTagName|
            getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
            getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
            hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
            insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
            insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
            isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
            lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
            moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
            parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
            previousSibling|probablySupportsContext|queryCommandEnabled|
            queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
            querySelector|querySelectorAll|registerContentHandler|registerElement|
            registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
            removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
            removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
            requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
            scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
            setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
            setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
            setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
            slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
            submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
            toDataURL|toggle|toString|values|write|writeln
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.dom.protea
      - comment: Bash and Batch built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt
            |bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil
            |change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher
            |clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert
            |copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd
            |dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf
            |diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd
            |dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal
            |eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract
            |fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|freedisk
            |fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate
            |graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig
            |ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd
            |ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manageBde|mapadmin|md
            |mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt
            |msg|msiexec|msinfo32|mstsc|nbtstat|net|netcfg|netdiag|netdom|netsh|netstat
            |nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt
            |ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin
            |pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershellIse
            |print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd
            |pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta
            |rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32
            |relog|ren|rename|rendom|repadmin|repairBde|replace|reset|rxec|risetup
            |rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks
            |scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn
            |setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|sshAdd|sshAgent
            |sshKeygen|sshKeyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo
            |takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title
            |tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp
            |tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier
            |verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where
            |whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy
            |alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown
            |echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill
            |let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source
            |suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait
            |alias|apropos|apt|aptGet|aptitude|aspell|at|awk|basename|base32|base64
            |bash|bc|bg|bind|break|builtin|bzip2|cal|caller|when|cat|cd|cfdisk|chattr
            |chgrp|chmod|chown|chpasswd|chroot|chkconfig|cksum|clear|cmp|comm|command
            |continue|cp|cpio|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|declare
            |df|diff|diff3|dig|dir|dircolors|dirname|dirs|dos2unix|dmesg|dpkg|du|echo
            |egrep|eject|enable|env|ethtool|eval|exec|exit|expect|expand|export|expr
            |false|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|for|format|free|fsck|ftp
            |function|fuser|gawk|getopts|grep|groupadd|groupdel|groupmod|groups|gzip|hash
            |head|help|history|hostname|htop|iconv|id|if|ifconfig|ifdown|ifup|import|install
            |iostat|ip|jobs|join|kill|killall|less|let|link|ln|local|locate|logname|logout
            |look|lpc|lpr|lprint|lprintd|lprintq|lprm|lsattr|lsblk|ls|lsof|lspci|make|man
            |mapfile|mkdir|mkfifo|mkfile|mkisofs|mknod|mktemp|more|most|mount|mtools|mtr|mv
            |mmv|nc|netstat|nft|nice|nl|nohup|notifySend|nslookup|open|op|passwd|paste
            |pathchk|Perf|ping|pgrep|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd
            |quota|quotacheck|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice
            |remsync|return|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|select|seq|set|sftp
            |shift|shopt|shuf|shutdown|sleep|slocate|sort|source|split|ss|ssh|stat|strace
            |su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|tmux|touch|top
            |tput|traceroute|trap|tr|true|tsort|tty|type|ulimit|umask|umount|unalias|uname
            |unexpand|uniq|units|unix2dos|unrar|unset|unshar|until|uptime|useradd|userdel
            |usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|w|wait|watch|wc|whereis|which
            |while|who|whoami|wget|write|xargs|xdgOpen|xxd|xz|yes|zip
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.system.protea
      - comment: Bash and Batch built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            avg|checksumAgg|count|countBig|grouping|groupingId|max|min|sum|stdev|stdevp|var
            |varp|cumeDist|firstValue|lag|lastValue|lead|percentRank|percentileCont|percentileDisc
            |cast|convert|parse|tryCast|tryConvert|tryParse|cursorStatus|coalesce|nullif|choose
            |iif|sysdatetime|sysdatetimeoffset|sysutcdatetime|currentTime(?:stamp)?|getdate
            |getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts
            |datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts
            |datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate|cursorRows|connections
            |cpuBusy|datefirst|dbts|error|fetchStatus|identity|idle|ioBusy|langid|language
            |lockTimeout|maxConnections|maxPrecision|nestlevel|options|packetErrors|packReceived
            |packSent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks
            |totalErrors|totalRead|totalWrite|trancount|version|abs|acos|asin|atan|atn2|ceiling
            |cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square
            |tan|appName|applockMode|applockTest|assemblyproperty|colLength|colName|columnproperty
            |databasePrincipalId|databasepropertyex|dbId|dbName|fileId|fileIdex|fileName|filegroupId
            |filegroupName|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty
            |indexCol|indexkeyProperty|indexproperty|objectDefinition|objectId|objectName
            |objectSchemaName|objectproperty|objectpropertyex|originalDbName|parsename|schemaId|schemaName
            |scopeIdentity|serverproperty|statsDate|typeId|typeName|typeproperty|rank|denseRank|ntile
            |rowNumber|opendatasource|openrowset|openquery|openxml|certencoded|certprivatekey|currentUser
            |databasePrincipalId|hasPermsByName|isMember|isRolemember|isSrvrolemember|originalLogin|permissions
            |pwdcompare|pwdencrypt|schemaId|schemaName|sessionUser|suserId|suserSid|suserSname|systemUser
            |suserName|userId|userName|ascii|char|charindex|concat|difference|format|left|len|lower|ltrim
            |nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|stringAgg
            |stringEscape|stringSplit|stuff|substring|translate|trim|unicode|upper|patindex|textptr|textvalid
            |binaryChecksum|checksum|compress|connectionproperty|contextInfo|currentRequestId|currentTransactionId
            |decompress|errorLine|errorMessage|errorNumber|errorProcedure|errorSeverity|errorState|formatmessage
            |getFilestreamTransactionContext|getansinull|hostId|hostName|isnull|isnumeric|minActiveRowversion
            |newid|newsequentialid|rowcountBig|sessionContext|sessionId|exactState
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.database.protea
      - comment: predicate functions
        match: \s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+(?!\B|\p{Pd}+\b)\s*
        name: support.function.predicate.protea
      - comment: magic functions
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}][\w\p{Pd}]*)+\p{Pc}+(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea

  # Generated

  strings-prefixed:
    patterns:
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: (?<!'+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: (?<!"+)((?i:fprs|fpsr|frps|frsp|fspr|fsrp|pfrs|pfsr|prfs|prsf|psfr|psrf|rfps|rfsp|rpfs|rpsf|rsfp|rspf|sfpr|sfrp|spfr|sprf|srfp|srpf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: (?<!'+)((?i:frs|fsr|rfs|rsf|sfr|srf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: (?<!"+)((?i:frs|fsr|rfs|rsf|sfr|srf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: (?<!'+)((?i:prs|psr|rps|rsp|spr|srp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: (?<!"+)((?i:prs|psr|rps|rsp|spr|srp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, format, and template string
        begin: (?<!'+)((?i:fpr|frp|pfr|prf|rfp|rpf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, format, and template string
        begin: (?<!"+)((?i:fpr|frp|pfr|prf|rfp|rpf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated, format, and template string
        begin: (?<!'+)((?i:fps|fsp|pfs|psf|sfp|spf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated, format, and template string
        begin: (?<!"+)((?i:fps|fsp|pfs|psf|sfp|spf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim and interpolated string
        begin: (?<!'+)((?i:rs|sr))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
      - comment: double-quoted verbatim and interpolated string
        begin: (?<!"+)((?i:rs|sr))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.protea
          - include: '#embedded-expression'
      - comment: single-quoted interpolated and format string
        begin: (?<!'+)((?i:fs|sf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted interpolated and format string
        begin: (?<!"+)((?i:fs|sf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim and template string
        begin: (?<!'+)((?i:pr|rp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim and template string
        begin: (?<!"+)((?i:pr|rp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.protea
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated and template string
        begin: (?<!'+)((?i:ps|sp))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated and template string
        begin: (?<!"+)((?i:ps|sp))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted format and template string
        begin: (?<!'+)((?i:fp|pf))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted format and template string
        begin: (?<!"+)((?i:fp|pf))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim string
        begin: (?<!'+)((?i:r))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: "''"
            name: constant.character.escape.protea
      - comment: double-quoted verbatim string
        begin: (?<!"+)((?i:r))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - match: '""'
            name: constant.character.escape.protea
      - comment: single-quoted interpolated string
        begin: (?<!'+)((?i:s))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: double-quoted interpolated string
        begin: (?<!"+)((?i:s))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: single-quoted template string
        begin: (?<!'+)((?i:p))('''+|')\s*
        contentName: string.quoted.single.protea
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: double-quoted template string
        begin: (?<!"+)((?i:p))("""+|")\s*
        contentName: string.quoted.double.protea
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.protea }
          2: { name: punctuation.definition.string.protea }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'

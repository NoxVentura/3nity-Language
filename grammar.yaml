name: Protea
scopeName: source.dart
fileTypes: [dart, pta]
patterns: [include: "#core"]

information for contributors: |
  This is the grammar for the Protea programming language. The grammar
  is about 85% complete though there still need to be some fixes.

  Should any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo,
  and I will be very happy to receive it/them.

comment: |
  To-Do:
  - Revamp numeric literals again
  - Add type-regex literals
  - Document and add uncaught parsing errors

  Done:
  - Changed from indentation to curly bracket syntax
  - Map/set syntax should only activate next to an opening bracket, a colon
    beside a literal or closing bracket, or a non-suffix operator
  - Freed backslash to be used as part of operators
  - Added support for dashed identifiers, to support Lisp/train case
    - Fixed highlighting of "S-1" or "SX-1" scenario, where a dash would only
      highlight the first word
  - Removed unquoted strings
  - Added CSS keyword and function properties
  - Reworked JSX syntax, restored JSX fragments
  - Reworked format directives and embedded expressions, with a little
    help from recursion
  - Reworked number, string and JSX literals
  - Rework keywords in favor of a smaller set (see documentation)
  - Fix highlighting of CSS style rules to allow not repeating the "style"
    keyword for nested styles
  - Add highlighting for CSS dynamic properties

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.pta}
    2: {name: punctuation.separator.decimal.period.pta}
    3: {name: punctuation.separator.decimal.fraction.pta}
    4: {name: constant.numeric.other.exponent.pta}
    5: {name: constant.numeric.other.density.pta}
    6: {name: storage.type.numeric.pta}

  entity-name-clause: &entity-name-clause |
    (?x)\s*\b
    (?<=(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:ext|impl)\b|\s*[<>]\s+)\s*

    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|then|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    )(?!\B|\p{Pd}+\b)
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  class-name: &class-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|then|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    |ext|impl
    )(?!\B|\p{Pd}+\b)
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|val|func|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|compo|prop
    |go|defer|do|from|where|with
    |if|elif|else|then|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    )(?!\B|\p{Pd}+\b)
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

repository:
  core:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#brackets"
      - include: "#jsx"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbol-strings"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  embedded-content:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#format-specifier"
      - include: "#symbols"
      - include: "#operators"
      - include: "#strings"
      - include: "#numbers"
      - include: "#constants"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  # Function brackets (early here as not to break things)

  function-params:
    patterns:
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.optional.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.spread.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.name.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.reference.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.other.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.pta

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))\s*
    captures:
      1: {name: punctuation.definition.parameters.pta}
    patterns: &function-params
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.pta
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.pta
      - include: "#clauses"
      - include: "#constants"
      - include: "#declarations"
      - include: "#expression-keywords"
      - include: "#function-params"
      - include: "$self"

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.number.pta
      - match: '[\w]+?'
        name: invalid.illegal.variable.pta
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.pta
      - match: '[\p{S}\p{P}&&[^,;''"`(){}\[\]\p{Pc}]]+'
        name: invalid.illegal.operator.pta
      - match: \S+?
        name: invalid.illegal.uncaught.pta

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?!\B|\p{Pd}+\b)\s*
    name: invalid.illegal.keyword.pta

  # Support

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"
  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)
          |Imag|Comp|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          # lowerFlatCase
          |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)
          |imag|comp|char|rune|str|sym
          |u?int(8|16|32|64|128)
          |[ci]?float(16|32|64|128)
          |[ui](8|16|32|64|128)
          |[ci]?f(16|32|64|128)
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.primitive.pta
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map|Bag|Str)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          # lowerFlatCase
          |array|tuple|(mut)?(list|set|map|bag|str)|dict|func|iter
          |proc|seq|gen|range|stack|heap|queue|tree|trie
          |future|stream|regexp?|func|buf|strbuf|bytes
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.pta
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit|Obj
          |Any|Mixed|Just|Some|None|Never|(Im)?pure
          |Class|Enum|Module|Pack|Struct|Schema|Space|Pragma
          |Proc|Proto|Macro|Given|Style|Compo|Field
          |Ext|Pred|Data|Trait|Lemma|Iter|Sub|Prop|Const
          # lowerFlatCase
          |true|false|null|void|nan|infin|empty|unit|obj
          |any|mixed|just|some|none|never|(im)?pure|const
          )(?!\B|\p{Pd}+\b)
        name: support.type.primitive.pta
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)(?!\B|\p{Pd}+\b)
        name: support.class.error.pta
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.interface.pta
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.namespace.pta
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able(?!\B|\p{Pd}+\b)
        name: support.class.trait.pta
  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+(?!\B|\p{Pd}+\b)\s*
        name: support.function.predicate.pta
      - comment: magic functions
        match: (?x)\s*\b\p{Pc}+([\p{Pc}\p{L}][\w\p{Pd}]*)+\p{Pc}+(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.pta
      - match: |
          (?x)\s*\b(
          import|abs|all|any|ascii|bin|breakpoint|callable
          |chr|compile|copyright|credits|delattr|dir|divmod
          |enumerate|eval|exec|exit|filter|format|getattr
          |globals|hasattr|hash|help|hex|id|input
          |isinstance|issubclass|iter|len|license|locals|map
          |max|memoryview|min|next|oct|open|ord|pow|print
          |quit|range|reload|repr|reversed|round
          |setattr|sorted|sum|vars|zip|file|reduce|intern
          |rawInput|unicode|cmp|basestring|execfile|long|xrange
          |isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI
          |decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape
          |require|set(Interval|Timeout)|clear(Interval|Timeout)
          |eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints
          |chmod|split|reduce|min|max|reverse|truncate|zip|cat|roundrobin
          |classify|first|sum|keys|values|pairs|defined|delete|exists|elems
          |end|kv|any|all|one|wrap|shape|key|value|name|pop|push|shift
          |splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt
          |sin|cos|tan|round|strand|roots|cis|unpolar|polar|atan2|pick|chop
          |p5chop|chomp|p5chomp|lc|lcfirst|uc|ucfirst|capitalize|normalize|pack
          |unpack|quotemeta|comb|samecase|sameaccent|chars|nfd|nfc|nfkd|nfkc
          |printf|sprintf|caller|evalfile|run|runinstead|nothing|want|bless
          |chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin
          |getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print
          |open|read|write|readline|say|seek|close|opendir|readdir|slurp
          |spurt|shell|run|pos|fmt|vec|link|unlink|symlink|uniq|pair|asin
          |atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh|tanh|asinh
          |done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh
          |asech|ok|nok|planOk|diesOk|livesOk|skip|todo|pass|flunk
          |forceTodo|useOk|isaOk|diag|isDeeply|isnt|like|skipRest
          |unlike|cmpOk|evalDiesOk|nokError|evalLivesOk|approx
          |isApprox|throwsOk|versionLt|plan|eval|succ|pred|times|nonce
          |once|signature|new|connect|operator|undef|undefine|sleep|from
          |to|infix|postfix|prefix|circumfix|postcircumfix|minmax|lazy
          |count|unwrap|getc|pi|e|context|void|quasi|body|each|contains
          |rewinddir|subst|can|isa|flush|arity|assuming|rewind|callwith
          |callsame|nextwith|nextsame|attr|evalElsewhere|none|srand|trim
          |trimStart|trimEnd|lastcall|what|where|how|which|var|who
          |whence|accepts|rejects|not|true|iterator|by|re|im|invert
          |flip|gist|flat|tree|isPrime|throwsLike|trans
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.pta
      - match: |
          (?x)\s*\b(
          \p{Pc}+(?:
          abs|add|aenter|aexit|aiter|and|anext|await
          |bool|call|ceil|cmp|coerce|complex|contains
          |copy|deepcopy|del|delattr|delete|delitem
          |delslice|dir|div|divmod|enter|eq|exit|float
          |floor|floordiv|format|ge|get|getattr
          |getattribute|getinitargs|getitem|getnewargs
          |getslice|getstate|gt|hash|hex|iadd|iand|idiv
          |ifloordiv|ilshift|imod|imul|index|init
          |instancecheck|int|invert|ior|ipow|irshift|isub
          |iter|itruediv|ixor|le|len|long|lshift|lt
          |missing|mod|mul|ne|neg|new|next|nonzero|oct|or
          |pos|pow|radd|rand|rdiv|rdivmod|reduce
          |reduceEx|repr|reversed|rfloordiv|rlshift|rmod
          |rmul|ror|round|rpow|rrshift|rshift|rsub
          |rtruediv|rxor|set|setattr|setitem|setslice
          |setstate|sizeof|str|sub|subclasscheck|truediv
          |trunc|unicode|xor|matmul|rmatmul|imatmul
          |initSubclass|setName|fspath|bytes|prepare
          |all|bases|builtins|class|classGetitem|code|debug
          |defaults|dict|doc|file|func|kwdefaults|members
          |metaclass|methods|module|mro|mroEntries|name
          |qualname|postInit|self|signature|slots|subclasses
          |version|weakref|wrapped|annotations|classcell
          |spec|path|package|future|traceback
          )\p{Pc}+
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.pta
      - match: |
          (?x)\s*\b(
          abort|atExit|autoload|binding|callcc|caller|callerLocations
          |chomp|chop|eval|exec|exit|exit!|fork|format|gets
          |globalVariables|gsub|lambda|load|localVariables|open
          |p|print|printf|proc|putc|puts|rand|readline|readlines
          |select|setTraceFunc|sleep|spawn|sprintf|srand|sub
          |syscall|system|test|traceVar|trap|untraceVar|warn
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.kernel.pta
      - match: |
          (?x)\s*\b(
          on(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
          Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
          Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|
          Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
          Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
          Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
          Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
          Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.event-handler.pta
      - match: |
          (?x)\s*\b(
          shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
          scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
          sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|
          Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
          Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
          savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
          contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
          createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
          test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
          untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|
          print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
          fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
          forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
          abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
          releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
          Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
          Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
          moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.pta
      - match: |
          (?x)\s*\b(
          (acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
          appendChild|appendData|before|blur|canPlayType|captureStream|
          caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
          cloneContents|cloneNode|cloneRange|close|closest|collapse|
          compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
          convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
          createAttributeNS|createCaption|createCDATASection|createComment|
          createContextualFragment|createDocument|createDocumentFragment|
          createDocumentType|createElement|createElementNS|createEntityReference|
          createEvent|createExpression|createHTMLDocument|createNodeIterator|
          createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
          createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
          deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
          deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
          enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
          exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
          getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
          getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
          getClientRects|getContext|getDestinationInsertionPoints|getElementById|
          getElementsByClassName|getElementsByName|getElementsByTagName|
          getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
          getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
          hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
          insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
          insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
          isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
          lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
          moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
          parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
          previousSibling|probablySupportsContext|queryCommandEnabled|
          queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
          querySelector|querySelectorAll|registerContentHandler|registerElement|
          registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
          removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
          removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
          requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
          scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
          setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
          setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
          setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
          slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
          submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
          toDataURL|toggle|toString|values|write|writeln)
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.dom.pta
      - match: |
          (?x)\s*\b(
          adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt
          |bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil
          |change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher
          |clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert
          |copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd
          |dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf
          |diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd
          |dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal
          |eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract
          |fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|freedisk
          |fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate
          |graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig
          |ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd
          |ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manageBde|mapadmin|md
          |mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt
          |msg|msiexec|msinfo32|mstsc|nbtstat|net|netcfg|netdiag|netdom|netsh|netstat
          |nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt
          |ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin
          |pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershellIse
          |print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd
          |pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta
          |rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32
          |relog|ren|rename|rendom|repadmin|repairBde|replace|reset|rxec|risetup
          |rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks
          |scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn
          |setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|sshAdd|sshAgent
          |sshKeygen|sshKeyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo
          |takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title
          |tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp
          |tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier
          |verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where
          |whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy
          |alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown
          |echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill
          |let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source
          |suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait
          )
          (?!\B|\p{Pd}+\b)\s*
        name: support.function.command.pta
      - match: |
          (?x)\b(?:
          (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          |
          (?:# Objects
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
          |
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.pta}
          2: {name: entity.name.tag.pta support.class.component.pta}
          3: {name: entity.name.class.builtin.pta}
          4: {name: entity.name.function.method.pta}
          5: {name: variable.other.global.pta}
          6: {name: variable.other.constant.object.pta}
          7: {name: variable.other.conditional.pta}
          8: {name: variable.other.object.pta}
          9: {name: entity.name.function.tagged-template.pta}
          10: {name: entity.name.type.pta}
          11: {name: entity.name.class.pta}
          12: {name: entity.name.function.pta}
      - include: $self
  constant-names:
    comment: Names for constants, symbols and static properties
    patterns:
      - comment: Python
      - include: source.python#magic-variable-names
  variable-names:
    comment: Standard Library variable names
    patterns:
      - comment: Python
      - include: source.python#magic-function-names
  property-names:
    comment: Standard Library property names
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties

  # Literals and Constants

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )(?!\B|\p{Pd}+\b)\s*
        captures:
          1: {name: constant.language.boolean.true.pta}
          2: {name: constant.language.boolean.false.pta}
          3: {name: constant.language.null.pta}
          4: {name: constant.language.undefined.pta}
          5: {name: constant.language.nan.pta}
          6: {name: constant.language.infinity.pta}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (it|this|that|self)#1
          |(args)#2
          |(ctor)#3
          |(prot)#4
          |(proto)#5
          )(?!\B|\p{Pd}+\b)\s*
        captures:
          1: {name: variable.language.$1.pta}
          2: {name: variable.language.arguments.pta}
          3: {name: variable.language.constructor.pta}
          4: {name: variable.language.prototype.pta}
          5: {name: variable.language.proto.pta}

  symbols:
    patterns:
      - match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
        name: entity.name.class.decorator.pta
      - match: \s*\B(:)(?=['"])
        name: punctuation.definition.symbol.pta
      - match: \s*\B(:)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.symbol.pta}
          2: {name: constant.other.symbol.pta}

  # Numbers

  numbers:
    patterns:
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)#radix
          (?:\d+(?:\p{Pc}*\d+)*)#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (s)(?:\d+(?:\p{Pc}*\d+)*))?|#rep
          (n)(?:\d+(?:\p{Pc}*\d+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)#radix
          (?:\d+(?:\p{Pc}*\d+)*)?#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (s)(?:\d+(?:\p{Pc}*\d+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0b)#radix
          (?:[01]+(?:\p{Pc}*[01]+)*)#int/numer
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:#frac
          (s)(?:[01]+(?:\p{Pc}*[01]+)*))?|#rep
          (n)(?:[01]+(?:\p{Pc}*[01]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.binary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0b)#radix
          (?:[01]+(?:\p{Pc}*[01]+)*)?#int/numer
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:#frac
          (s)(?:[01]+(?:\p{Pc}*[01]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.binary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0q)#radix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)#int/numer
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:#frac
          (s)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?|#rep
          (n)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0q)#radix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)?#int/numer
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:#frac
          (s)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0s)#radix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)#int/numer
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:#frac
          (s)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?|#rep
          (n)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.senary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0s)#radix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)?#int/numer
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:#frac
          (s)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.senary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0o)#radix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)#int/numer
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:#frac
          (s)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?|#rep
          (n)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.octal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0o)#radix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)?#int/numer
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:#frac
          (s)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.octal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0z)#radix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)#int/numer
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:#frac
          (s)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?|#rep
          (n)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0z)#radix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)?#int/numer
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:#frac
          (s)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0x)#radix
          (?:\h+(?:\p{Pc}*\h+)*)#int/numer
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:#frac
          (s)(?:\h+(?:\p{Pc}*\h+)*))?|#rep
          (n)(?:\h+(?:\p{Pc}*\h+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0x)#radix
          (?:\h+(?:\p{Pc}*\h+)*)?#int/numer
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:#frac
          (s)(?:\h+(?:\p{Pc}*\h+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ()#radix
          (?:\d+(?:\p{Pc}*\d+)*)#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (s)(?:\d+(?:\p{Pc}*\d+)*))?|#rep
          (n)(?:\d+(?:\p{Pc}*\d+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ()#radix
          (?:\d+(?:\p{Pc}*\d+)*)?#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (s)(?:\d+(?:\p{Pc}*\d+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))#radix
          (?:\w+(?:\p{Pc}*\w+)*)#int/numer
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:#frac
          (s)(?:\w+(?:\p{Pc}*\w+)*))?|#rep
          (n)(?:\w+(?:\p{Pc}*\w+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))#radix
          (?:\w+(?:\p{Pc}*\w+)*)?#int/numer
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:#frac
          (s)(?:\w+(?:\p{Pc}*\w+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}

  symbol-strings:
    patterns:
      - comment: multi-single quoted string
        begin: (?<=^|\s+)(:('''+))
        contentName: string.quoted.single.pta
        end: \s*((\2)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
      - comment: single quoted string
        begin: (?<=^|\s+)(:('))
        contentName: string.quoted.single.pta
        end: \s*((\2)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
      - comment: multi-double quoted string
        begin: (?<=^|\s+)(:("""+))
        contentName: string.quoted.double.pta
        end: \s*((\2)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"
      - comment: double quoted string
        begin: (?<=^|\s+)(:("))
        contentName: string.quoted.double.pta
        end: \s*((\2)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"

  strings:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#embedded-raw"
      - comment: single quoted string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
          - include: "#embedded-raw"
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-content"
      - comment: double quoted string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-content"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: (?ix)\\b[01]{1,21}
        name: constant.character.escape.binary.pta
      - comment: Binary escape sequences
        begin: (?ix)\\b{
        end: \s*}
        name: constant.character.escape.binary.pta
        patterns:
          - match: \b[01]{1,21}\b
            name: constant.character.escape.binary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Quaternary escape sequences
        match: (?ix)\\q[0-3]{1,11}
        name: constant.character.escape.quaternary.pta
      - comment: Quaternary escape sequences
        begin: (?ix)\\q{
        end: \s*}
        name: constant.character.escape.quaternary.pta
        patterns:
          - match: \b[0-3]{1,11}\b
            name: constant.character.escape.quaternary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Senary escape sequences
        match: (?ix)\\s[0-5]{1,8}
        name: constant.character.escape.senary.pta
      - comment: Senary escape sequences
        begin: (?ix)\\s{
        end: \s*}
        name: constant.character.escape.senary.pta
        patterns:
          - match: \b[0-5]{1,8}\b
            name: constant.character.escape.senary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Octal escape sequences
        match: (?ix)\\o[0-7]{1,7}
        name: constant.character.escape.octal.pta
      - comment: Octal escape sequences
        begin: (?ix)\\o{
        end: \s*}
        name: constant.character.escape.octal.pta
        patterns:
          - match: \b[0-7]{1,7}\b
            name: constant.character.escape.octal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Decimal escape sequences
        match: (?ix)\\d?\d{1,7}
        name: constant.character.escape.decimal.pta
      - comment: Decimal escape sequences
        begin: (?ix)\\d{
        end: \s*}
        name: constant.character.escape.decimal.pta
        patterns:
          - match: \b\d{1,7}\b
            name: constant.character.escape.decimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Duodecimal escape sequences
        match: (?ix)\\z[\dab]{1,6}
        name: constant.character.escape.duodecimal.pta
      - comment: Duodecimal escape sequences
        begin: (?ix)\\z{
        end: \s*}
        name: constant.character.escape.duodecimal.pta
        patterns:
          - match: \b[\dab]{1,6}\b
            name: constant.character.escape.duodecimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Hexadecimal escape sequences
        match: (?ix)\\[ux]\h{1,6}
        name: constant.character.escape.hexadecimal.pta
      - comment: Hexadecimal escape sequences
        begin: (?ix)\\[ux]{
        end: \s*}
        name: constant.character.escape.hexadecimal.pta
        patterns:
          - match: \b\h{1,6}\b
            name: constant.character.escape.hexadecimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.pta
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.pta
        patterns: [include: "#latex-sublanguage"]
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.pta
      - match: (?i)\\[a-z]
        name: constant.character.escape.pta
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.pta
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.pta
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.pta

  embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.section.embedded.pta}
        patterns: [include: $self]
      - comment: Oniguruma supports only 20 levels of recursion
        match: |
          (?x)(\$)
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          \b[\p{Pc}\p{L}][\p{Pd}\w]*\b
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.pta}
          2: {patterns: [include: "#embedded-content"]}
  format-specifier:
    comment: Oniguruma supports only 20 levels of recursion
    match: |
      (?x)(%)
      (
      (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
      (
      (?<sw>
      /\g<ident>
      (?<val>:
      (?<expr>
      # Recursive brackets
      ([?!]?\.|[?!:]:)?(?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      ([?!]?\.|[?!:]:)?(?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
      (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Rest of identifier characters
      [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
      (\w+[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)*
      (?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
      )*
      )?
      )*
      )
      )
    captures:
      1: {name: punctuation.definition.directive.pta}
      2:
        name: storage.type.format.pta
        patterns:
          - include: "#format-language"
          - match: .+
            name: string.other.format.pta
  embedded-placeholder:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.pta}
          2: {name: constant.numeric.decimal.pta}
      - match: (\#)((?:[*&%$]\??|\?)?[\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.anchor.pta}
          2: {patterns: [include: "#placeholder-variables"]}
      - begin: (\#{)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.definition.anchor.pta}
        patterns:
          - include: "#function-params"
          - include: $self
  embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"
  embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.pta
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"

  # Format Specifier Language

  format-language:
    comment: Grammar for Protea's format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: type specifier
        match: (?<=[^\\%]%)\w+
        name: entity.other.attribute-name.pta
      - comment: Format switch with value /x:24
        applyEndPatternLast: 1
        begin: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)(:)
        beginCaptures:
          1: {name: punctuation.separator.mapping.pta}
          2: {name: entity.other.attribute-name.class.pta}
          3: {name: punctuation.separator.key-value.pta}
        end: (?=)|$
        patterns: [include: "#html-properties"]
      - comment: Format switch without value
        match: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.separator.mapping.pta}
          2: {name: entity.other.attribute-name.id.pta}

  # Unicode Named Character Language

  latex-sublanguage:
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - include: "#embedded"
      - name: line.separator.math.pta
        match: (\\\\)$
        captures:
          1: {name: punctuation.line.separator.math.pta}
      - name: meta.function.math.pta
        begin: ((\\)([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*))(\{)
        beginCaptures:
          1: {name: storage.type.function.math.pta}
          2: {name: punctuation.definition.function.math.pta}
          3:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: entity.name.namespace.pta
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: entity.name.function.pta
              - match: \b\:\b
                name: punctuation.separator.namespace.pta
              - match: \b\.\b
                name: punctuation.accessor.pta
          4: {name: punctuation.definition.arguments.begin.math.pta}
        end: \}
        endCaptures:
          0: {name: punctuation.definition.arguments.end.math.pta}
        patterns:
          - include: "#latex-sublanguage"
      - match: (\\)\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
        captures:
          1: {name: punctuation.definition.constant.pta}
          2:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: constant.other.character-class.pta
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: constant.character.math.pta
              - match: \b\:\b
                name: punctuation.separator.namespace.pta
              - match: \b\.\b
                name: punctuation.accessor.pta
      - match: "[-+*/^]"
        name: punctuation.math.operator.latex
      - include: "#string-escapes"
      - include: "#literals"
      - include: source.yaml#flow-collection
      - match: '[^\\(){}\[\]]+?'
        name: string.unquoted.plain.in.pta

  # Regular expressions

  regexps:
    patterns:
      - comment: Replacement section
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        contentName: string.replace.regexp.pta
        captures:
          1: {name: punctuation.section.regexp.end.pta}
          2: {name: keyword.other.flag.pta}
        patterns:
          - include: "#back-references"
          - include: "#string-content"
      - comment: Pattern section
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        contentName: string.pattern.regexp.pta
        beginCaptures:
          1: {name: keyword.modifier.pta}
          2: {name: punctuation.section.regexp.begin.pta}
        endCaptures:
          1: {name: punctuation.section.regexp.end.pta}
          2: {name: keyword.other.flag.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*|&)
        name: keyword.other.back-reference.pta
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings"
      - match: \|
        name: keyword.operator.or.pta
      - match: \&
        name: keyword.operator.compose.pta
      - match: \.
        name: constant.character.all.pta
      - match: \\[bB]({[\w\s]+})?
        name: keyword.control.anchor.pta
      - match: \$|\\[yYzZ]({[\w\s]+})?
        name: keyword.control.end.pta}
      - match: \^|\\[AmM]({[\w\s]+})?
        name: keyword.control.begin.pta
      - match: \\K
        name: keyword.control.keepout.pta
      - match: \\G
        name: keyword.control.search.pta
      - match: \\R
        name: constant.character.control.pta
      - match: \\[XO]
        name: constant.character.unicode.pta
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.pta}
          2: {name: keyword.operator.quantifier.lazy.pta}
          3: {name: keyword.operator.quantifier.eager.pta}
          4: {name: keyword.operator.quantifier.greedy.pta}
      - match: \\\d+
        name: keyword.other.back-reference.pta
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.pta
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.pta
        captures:
          1: {name: keyword.other.subroutine.pta}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|'|"))
        end: \s*(\2)
        name: constant.other.subroutine.pta
        captures:
          1: {name: keyword.other.subroutine.pta}
        patterns: *regex-back-references
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.pta}
          2: {name: keyword.operator.modifier.eager.pta}
          3: {name: keyword.operator.modifier.greedy.pta}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.pta}
          2: {name: keyword.operator.quantifier.eager.pta}
          3: {name: keyword.operator.quantifier.greedy.pta}
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: \\.
        name: constant.character.escape.other.pta
  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(\??([*+])
        end: \s*(\))\s*
        name: constant.other.pcre.pta
        captures:
          0: {name: punctuation.section.expression.pta}
        patterns:
          - include: $self
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.pta
        end: \s*(\))\s*
        name: comment.block.regexp.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - match: \\.
            name: comment.block.regexp.pta
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))\s*
        name: meta.group.look-ahead.pta
        captures:
          1: {name: punctuation.definition.group.look-ahead.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))\s*
        name: meta.group.look-behind.pta
        captures:
          1: {name: punctuation.definition.group.look-behind.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))\s*
        name: meta.group.negative-look-ahead.pta
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))\s*
        name: meta.group.negative-look-behind.pta
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: |
          (?x)(\(\?%)
          (
          (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (
          (?<sw>
          /\g<ident>
          (?<val>:
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          (\w+[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)*
          (?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
          )*
          )?
          )*
          )
          )
        captures:
          1: {name: punctuation.definition.directive.pta}
          2:
            name: storage.type.format.pta
            patterns:
              - include: "#format-language"
              - match: .+
                name: string.other.format.pta
        end: \s*(\))\s*
        name: meta.group.directive.pta
        patterns: [include: "#regexp-patterns"]
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))\s*
        name: meta.group.longest.pta
        captures:
          1: {name: punctuation.definition.group.longest.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))\s*
        name: meta.group.flag.pta
        captures:
          0: {name: punctuation.definition.group.flag.pta}
          1: {name: punctuation.definition.group.flag.pta}
          2: {name: constant.numeric.index.pta}
          3: {name: keyword.control.recursion.pta}
          4: {name: keyword.other.flag.pta}
          5: {name: punctuation.separator.colon.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))\s*
        name: meta.group.call-out.pta
        captures:
          1: {name: punctuation.definition.group.call-out.pta}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.pta
            captures:
              1: {name: punctuation.definition.group.call-out.pta}
              2: {name: keyword.operator.range.pta}
              3: {name: punctuation.definition.tag.pta}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.pta}
            patterns:
              - include: $self
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))\s*
        name: meta.group.atomic.pta
        captures:
          1: {name: punctuation.definition.group.atomic.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))\s*
        name: meta.group.non-capturing.pta
        captures:
          1: {name: punctuation.definition.group.non-capturing.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))\s*
        name: meta.group.branch.pta
        captures:
          1: {name: punctuation.definition.group.branch.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))\s*
        name: meta.group.absent.pta
        captures:
          1: {name: punctuation.definition.group.absent.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.pta
        captures:
          0: {name: punctuation.definition.group.back-reference.pta}
          1: {name: punctuation.definition.group.back-reference.pta}
          2: {name: constant.numeric.index.pta}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))\s*
        name: meta.group.named.pta
        captures:
          0: {name: punctuation.definition.group.named.pta}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.pta
            captures:
              1: {name: punctuation.definition.group.named.pta}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))\s*
        name: meta.group.named.pta
        captures:
          0: {name: punctuation.definition.group.named.pta}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|'|")
            end: \s*(\1)
            name: constant.other.group.pta
            captures:
              1: {name: punctuation.definition.group.named.pta}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.pta
        captures:
          1: {name: punctuation.definition.group.pta}
        patterns: [include: "#regexp-patterns"]
  regexp-char-class:
    patterns:
      - include: "#embedded"
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.pta
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.pta
        patterns:
          - include: "#attribute-selectors"
      - begin: \\j{
        end: \s*}
        name: constant.character.entity.named.pta
        patterns: [include: "#latex-sublanguage"]
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.pta
      - match: (?i)\\p(\w\w?)
        name: constant.other.character-class.unicode.pta
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.pta
      - match: (?x)\\[a-z]
        name: constant.other.character-class.pta
      - match: (?x)\\[A-Z]
        name: constant.other.character-class.negated.pta
      - match: (?i)\\n{[\w\s\p{Pd}]+}
        name: constant.character.escape.unicode.name.pta
      - match: (?i)\\[\p{L}\p{N}]
        name: constant.character.escape.pta
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.pta
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.pta
      - match: (?x)\\\p{C}
        name: invalid.illegal.unknown-escape.pta
  regexp-char-ops:
    patterns:
      - match: (?<!\|)\|\|(?!\|)
        name: keyword.operator.union.pta
      - match: (?<!&)&&(?!&)
        name: keyword.operator.intersection.pta
      - match: (?<!\^)\^\^(?!\^)
        name: keyword.operator.symmetric.pta
      - match: (?<!~)~~(?!~)
        name: keyword.operator.negation.pta
      - match: (?<!-)--(?!-)
        name: keyword.operator.difference.pta
      - match: (?<![^\\][\\\[])-(?![-\[\]])
        name: keyword.operator.range.pta
      - match: ([^-\\\[\]]|\\.)(?<!-+)(?=(?<!\\)-)
        name: constant.other.character-class.range.from.pta
      - match: (?<=[^\\]-)(?!-+)([^-\\\[\]]|\\.)
        name: constant.other.character-class.range.to.pta
      - match: \\.
        name: constant.character.escape.other.pta
  regexp-char-set:
    patterns:
      - begin: (\[[:])
        end: (\])
        name: constant.other.character-class.posix.pta
        captures:
          1: {name: punctuation.definition.character-class.posix.pta}
        patterns: [include: "#attribute-selectors"]
      - begin: (\[[!^])
        end: (\])
        name: constant.other.character-class.negated.pta
        captures:
          1: {name: punctuation.definition.character-class.negated.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"
      - begin: (\[)
        end: (\])
        name: constant.other.character-class.pta
        captures:
          1: {name: punctuation.definition.character-class.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"

  attribute-selectors:
    patterns:
      - match: ","
        name: punctuation.separator.sequence.pta
      - include: "#comments"
      - include: "#strings"
      - match: (?xi)\b[is]\b(?=[)}\]]|&&|\|\||\^\^)
        name: storage.modifier.ignore-case.pta
      - include: "#string-escapes"
      - match: "[:!=</>.^$%?*+|&~]?="
        name: keyword.operator.pattern.pta
      - match: ([&|^])\1|!
        name: keyword.operator.logical.pta
      - match: \b(i[ns])\b
        name: keyword.operator.expression.$1.pta
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.pta}
          2: {name: keyword.operator.pattern.pta}
        end: (?=&&|\|\||\^\^|[\s,:;'"`(){}\[\]])
        name: string.unquoted.attribute-name.pta
        patterns: [include: "#html-properties"]
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: {name: entity.other.attribute-name.pta}
          2: {name: keyword.operator.pattern.pta}
      - include: "#operators"

  # Markdown

  markdown:
    comment: Only inline Markdown syntax would be supported, plus some enhancements HAML, Textile and more. Coming soon.
    patterns: []

  # Special code blocks

  html-properties:
    patterns:
      - include: "#brackets"
      - include: "#literals"
      - include: source.yaml#flow-collection
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional
      - include: source.css#numeric-values
      - include: source.css#property-keywords
      - include: source.css#color-keywords
      - include: source.css#property-names
      - include: "#tag-names"
      - include: "#embedded"
  tag-names:
    match: \b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
    name: entity.name.tag.pta
    captures:
      1:
        name: entity.name.tag.pta
        patterns:
          - match: "[.:]"
            name: punctuation.separator.namespace.pta
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
            name: entity.name.tag.namespace.pta
          - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)\b
            name: support.class.component.pta
          - match: |
              (?x)\s*\b(

              (?:
              # Html
              a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound
              |big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command
              |content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset
              |figcaption|figure|font|footer|form|frame|frameset|h(?:0|[1-9]\d*)|head|header|hgroup|hr|html|i
              |iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark
              |marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript
              |object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc
              |ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong
              |style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr
              |track|tt|u|ul|var|video|wbr|xmp

              # Svg
              |altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform
              |circle|clipPath|colorProfile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix
              |feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap
              |feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur
              |feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting
              |feSpotLight|feTile|feTurbulence|filter|fontFace|fontFaceFormat|fontFaceName
              |fontFaceSrc|fontFaceUri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern
              |line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata
              |missingGlyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor
              |stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern

              # MathML
              |annotation|annotationXml|maction|maligngroup|malignmark|math|menclose|merror|mfenced
              |mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot
              |mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup
              |msup|mtable|mtd|mtext|mtr|munder|munderover|semantics
              )

              )
              (?!\B|\p{Pd}+\b)\s*
            name: entity.name.tag.css.pta
  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    captures:
      1: {name: punctuation.definition.block.pta}
    patterns: [include: "#style-properties"]
  style-properties:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#style-block"
      - applyEndPatternLast: 1
        begin: |
          (?x)
          \s*
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )
          (:)\s+
        beginCaptures:
          1:
            name: support.type.property-name.pta
            patterns: &embedded-brackets
              - include: "#embedded"
              - include: "#brackets"
          8: {name: punctuation.separator.key-value.pta}
        end: (?=)|$
        name: string.unquoted.pta
        patterns:
          - include: "#html-properties"
          - match: \s+
            name: meta.var.expr.pta
      - include: "#style-rules"
      - include: $self
  style-rules:
    patterns:
      - begin: \s*(\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - include: "#function-params"
          - include: "#style-properties"
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.pta}
        patterns: [include: "#attribute-selectors"]
      - include: "#style-selectors"
      - include: "#format-language"
      - include: "#tag-names"
  style-selectors:
    patterns:
      - match: \s*(\@|\#|\&|\*|\.|\:|::)(?=[\w$])
        name: punctuation.definition.entity.pta
      - match: |
          (?x)
          \s*(?<=[^*]\*)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.name.type.alias.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^&]\&)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.name.type.anchor.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^@]\@)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: keyword.control.at-rule.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^\#]\#)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.id.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^.]\.)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.class.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^:]::?)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          (?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.pseudo-component.pta
            patterns: *embedded-brackets

  # JSX

  jsx:
    applyEndPatternLast: 1
    comment: Only after opening brackets, commas, semicolons, keywords, and operators. In addition, < > starts a JSX fragment.
    begin: |
      (?x)
      (?<=
      (?:
      (?:^|[,;]|\#?[({\[])\s*|
      \b[\p{Pc}\p{L}][\w\p{Pd}]*\b|
      (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+
      )\s*
      )
      (?=<[\p{Pc}\p{L}]|<\s+>)
    end: (?=)|$
    patterns: [include: "#tag-component-name"]
  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: invalid.illegal.invalid-prop.pta
        begin: \s*(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.pta}
        endCaptures:
          1: {name: punctuation.definition.tag.pta}
        patterns:
          - include: "#tag-termination"
      - comment: Tags that end > are trapped in tag-termination
        contentName: invalid.illegal.invalid-prop.pta
        begin: |
          (?x)\s*+(<)#start tag begin
          ([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)#tag name
          (?=[\/>\s])(?![:])(?<!\.|:)
        end: \s*(?:(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>)
        beginCaptures:
          1: {name: punctuation.definition.tag.pta}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.pta}
          3: {name: punctuation.definition.tag.pta}
          4: {name: invalid.illegal.termination.pta}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"
  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: string.unquoted.html.pta
    name: string.unquoted.html.pta
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.pta}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-component-name"
      - include: "#string-content"
      - include: markdown.math.block
      - include: text.html.markdown#inline
  tag-attributes:
    patterns:
      - applyEndPatternLast: 1
        begin: \s*(=)\s*
        beginCaptures:
          1: {name: punctuation.separator.key-value.pta}
        end: (?=)|$
        name: string.unquoted.pta
        patterns: [include: "#html-properties"]
      - include: "#style-selectors"
      - include: "#attributes"
      - include: "#comments"
      - include: "#type-operators"
  attributes:
    match: |
      (?x)
      \s*
      (
      [\p{Pd}$]?
      (?:
      # Recursive brackets
      \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
      (?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      (?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
      (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Rest of identifier characters
      \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
      )+
      )\s*
    captures:
      1:
        name: entity.other.attribute-name.${1:/downcase}.pta
        patterns: [include: "#embedded", include: "#brackets"]
    name: string.unquoted.pta
  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.pta
  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.pta}
          2: {name: punctuation.definition.entity.pta}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.pta
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.pta
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.pta
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.pta
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.pta
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.pta
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.pta
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.pta
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.pta
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.pta

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"
  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.documentation.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*(/\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"
  line-comments:
    patterns:
      - begin: \s*(///)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.documentation.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*(//)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.number-sign.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: text.html.markdown#inline
  nested-jsdoc:
    begin: (/\*\*?)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.documentation.nested.pta
    captures:
      1: {name: punctuation.definition.comment.pta}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"
  nested-block:
    begin: (/\*)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.nested.pta
    captures:
      1: {name: punctuation.definition.comment.pta}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"
  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc
  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}
  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}
  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"
  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}
  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"
  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"
  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}
  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}
  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"
  jsdoc-name-path-scopes:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#jsdoc-string"
  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - comment: |
          Function calls (with spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b\s+
          (?=<\|{1,3}\s+|<\+\s+)
        captures:
          1: {patterns: [include: "#function-names"]}
      - comment: |
          Function calls (optional spacing)
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*
          )
          \b
          (?=['"`]|
          (?:[!?]\.=?|\.=)?\#?\(|
          (?:[!?]\.=?|\.=)?<(?:\b|['"`\\({\[])
          )
        captures:
          1: {patterns: [include: "#function-names"]}

  # Variables

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.pta
      - match: (?i)\s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.pta
      - match: (?i)\s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.pta
      - match: (?i)\s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.pta
      - match: (?i)\s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.pta
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.pta

  variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.pta}
      2: {name: variable.other.constant.property.pta}
      3: {name: variable.other.property.static.pta}
      4: {name: variable.other.property.pta}
      5: {name: variable.other.global.pta}
      6: {name: variable.other.constant.object.pta}
      7: {name: variable.other.conditional.pta}
      8: {name: variable.other.object.pta}
      9: {name: variable.other.dollar.pta}
      10: {name: variable.other.constant.pta}
      11: {name: variable.other.class.pta}
      12: {name: variable.other.readwrite.pta}

  # Operators

  operators:
    patterns:
      - include: "#pipeline-operator"
      - include: "#unary-ops"
      - include: "#binary-ops"
  special-operators:
    patterns:
      - begin: (?<=^|\s)(\?)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.conditional.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\!)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.ternary.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\$)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.macro.dollar.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            name: entity.name.function.pta
          - include: $self
  binary-ops:
    patterns:
      - comment: augmented assignment += -= *= /= etc
        match: (?<=^|[\s'"`({\[])([\p{S}\p{P}&&[^!:~.<=>,;'"`(){}\[\]\p{Pc}]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=)(?=$|[\s'"`)}\]])
        name: keyword.operator.assignment.augmented.pta
      - comment: |
          BUILT-IN OPERATORS

          1: assignment : :=
          2: arithmetic + - * ** *** / // /// % %% *> <*
          3: increment/decrement ++ --
          4: logical && || ^^ !& !| !^ &| &!
          5: bitwise & | ^ ~
          6: bitwise shift << >> <<< >>>
          7: function pipeline <| |> <|| ||> <||| |||>
          8: function composition +> <+
          9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
          10: relational < > <= >=
          11: regex =< <> </ /> <$ $> <+> <*> </> <$>
          12: equality == != === !==
          13: wavy operators ~> <~ ~~> <~~
          14: fat arrow-like => ==> <==
          15: skinny arrow-like -> --> <- <--
          16: null-coalescing ??
          17: non-null coalescing !!
          18: compact ternary operator ?:
          19: inverse ternary operator !:
          20: infix function call $:
        captures:
          1: {name: keyword.operator.assignment.pta}
          2: {name: keyword.operator.arithmetic.pta}
          3: {name: keyword.operator.successor.pta}
          4: {name: keyword.operator.logical.pta}
          5: {name: keyword.operator.bitwise.pta}
          6: {name: keyword.operator.bitwise.shift.pta}
          7: {name: keyword.operator.pipeline.pta}
          8: {name: keyword.operator.compose.pta}
          9: {name: keyword.operator.class.pta}
          10: {name: keyword.operator.relational.pta}
          11: {name: keyword.operator.regexp.pta}
          12: {name: keyword.operator.comparison.pta}
          13: {name: keyword.operator.similarity.pta}
          14: {name: keyword.operator.arrow.fat.pta}
          15: {name: keyword.operator.arrow.skinny.pta}
          16: {name: keyword.operator.null-coalescing.pta}
          17: {name: keyword.operator.coalescing.pta}
          18: {name: keyword.operator.conditional.pta}
          19: {name: keyword.operator.ternary.pta}
          20: {name: keyword.operator.macro.dollar.pta}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          (:?=)#1
          |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
          |(\+\+|--)#3
          |(&&|\|\||\^\^)#4
          |([&|^~])#5
          |(<<<?|>>>?)#6
          |(\|{1,3}>|<\|{1,3})#7
          |(\+>|<\+)#8
          |([<>][!:]|[!:][<>])#9
          |([<>]=?|<=?>)#10
          |(=<|<?[/*|+$:]>?)#11
          |([!=]==?|[!=]~|~[!=])#12
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*~>|
          <~[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#13
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=>|
          <=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#14
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*->|
          <-[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#15
          |(\?\?)#16
          |(!!)#17
          |(\?:)#18
          |(!:)#19
          |(\$:)#20
          )
          (?=$|[\s'"`)}\]])# closing
      - comment: |
          CUSTOM OPERATORS

          1: custom bitwise (& | ^ ~)
          2: custom arithmetic (+ - * / %)
          3: custom prototype (:)
          4: custom accessor (.)
          5: custom equality (= !)
          6: custom comparison (< >)
          7: custom private (? #)
          8: custom mathematical (Unicode Sm)
          9: custom currency (Unicode Sc)
          10: custom ASCII (between \x80 and \xff)
          11: custom infix operators (all other chars)
        captures:
          1: {name: keyword.operator.bitwise.custom.pta}
          2: {name: keyword.operator.arithmetic.custom.pta}
          3: {name: keyword.operator.prototype.custom.pta}
          4: {name: keyword.operator.accessor.custom.pta}
          5: {name: keyword.operator.comparison.custom.pta}
          6: {name: keyword.operator.relational.custom.pta}
          7: {name: keyword.operator.private.custom.pta}
          8: {name: keyword.operator.math.custom.pta}
          9: {name: keyword.operator.currency.custom.pta}
          10: {name: keyword.operator.ascii.custom.pta}
          11: {name: keyword.operator.infix.custom.pta}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          ([&|^~][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#1
          |([+\-*/%][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#2
          |([@:][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |(\.[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |([!=][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#4
          |([<>][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          |([?\#][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#6
          |(\p{Sm}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#7
          |(\p{Sc}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#8
          |([\p{S}\p{P}&&[\x80-\xFF]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#9
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#10
          )
          (?=$|[\s'"`)}\]])# closing
  unary-ops:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`)}\]])# closing
          (?:
          ([>.]\.[.<])#1
          |(\?[.:]=?)#2
          |(![.:]=?)#3
          |((?:::|\.)=?)#4
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          )
          (?=\b|['"`({\[])# opening
        captures:
          1: {name: keyword.operator.range.pta}
          2: {name: keyword.operator.optional.pta}
          3: {name: keyword.operator.assert.pta}
          4: {name: keyword.operator.accessor.pta}
          5: {name: keyword.operator.primary.pta}
      - &prefix-operators
        comment: Prefix operators
        match: |
          (?x)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
          (?=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          [\w({\['"`])
        name: keyword.operator.prefix.pta
        captures:
          1: {name: keyword.operator.module.all.pta}
          2: {name: keyword.operator.increment.pta}
          3: {name: keyword.operator.decrement.pta}
          4: {name: keyword.operator.intersection.pta}
          5: {name: keyword.operator.union.pta}
          6: {name: keyword.operator.symmetric.pta}
          7: {name: keyword.operator.logical.pta}
          8: {name: keyword.operator.private.pta}
          9: {name: keyword.operator.decorator.pta}
          10: {name: keyword.operator.bitwise.not.pta}
          11: {name: keyword.operator.existential.pta}
          12: {name: keyword.operator.assignment.pta}
          13: {name: keyword.operator.pipeline.pta}
          14: {name: keyword.operator.private.pta}
          15: {name: keyword.operator.prefix.pta}
      - &suffix-operators
        comment: Suffix operators
        match: |
          (?x)
          (?<=[)}\]\w'"`]
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
        name: keyword.operator.suffix.pta
        captures:
          1: {name: keyword.operator.module.all.pta}
          2: {name: keyword.operator.increment.pta}
          3: {name: keyword.operator.decrement.pta}
          4: {name: keyword.operator.intersection.pta}
          5: {name: keyword.operator.union.pta}
          6: {name: keyword.operator.symmetric.pta}
          7: {name: keyword.operator.assert.pta}
          8: {name: keyword.operator.private.pta}
          9: {name: keyword.operator.decorator.pta}
          10: {name: keyword.operator.bitwise.pta}
          11: {name: keyword.operator.optional.pta}
          12: {name: keyword.operator.assignment.pta}
          13: {name: keyword.operator.pipeline.pta}
          14: {name: keyword.operator.private.pta}
          15: {name: keyword.operator.suffix.pta}
  pipeline-operator:
    patterns:
      - applyEndPatternLast: 1
        begin: |
          (?x)\s*(?:(\+>)|(\|{1,3}>))(?=\s*(
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|compo|prop
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\w]+
          (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# primary
          [\w]+)*
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# suffix
          )\s*([^(]|$|;))
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.compose.pta}
          2: {name: keyword.operator.pipeline.pta}
        patterns:
          - match: |
              (?x)\s*\b
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
              \b(?:# keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|val|func|proc|type
              |class|data|enum|module
              |iter|macro|struct|object
              |trait|style|compo|prop
              |go|defer|do|from|where|with
              |if|elif|else|then|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|goto|pass
              |break|next|redo|retry
              |return|yield|await|label
              |import|export|route
              |debug|assert|check
              )(?!\B|\p{Pd}+\b)
              )
              (?:
              (?:# Objects
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
              |
              (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
              (?:# Properties
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              |
              (?:# Regular variables
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              )\b
            captures:
              1: {name: variable.other.global.pta}
              2: {name: variable.other.constant.object.pta}
              3: {name: variable.other.conditional.pta}
              4: {name: variable.other.object.pta}
              5: {name: entity.name.tag.pta}
              6: {name: entity.name.tag.pta support.class.component.pta}
              7: {name: entity.name.class.builtin.pta}
              8: {name: entity.name.function.method.pta}
              9: {name: entity.name.function.tagged-template.pta}
              10: {name: entity.name.type.pta}
              11: {name: entity.name.class.pta}
              12: {name: entity.name.function.pta}
          - *primary-operators

  # Types

  types:
    patterns:
      - match: \s*(==?>|--?>|~~?>)
        name: keyword.operator.type.function.pta
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.pta
      - include: "#params-clause"
      - include: "#angle-brackets"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#type-variables"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#type-strings"
      - include: "#literals"
  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
      \b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?!\B|\p{Pd}+\b)
      )
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )\b
    captures: &type-variables
      1: {name: entity.name.module.pta}
      2: {name: entity.name.tag.pta}
      3: {name: entity.name.namespace.pta}
      4: {name: entity.name.interface.pta}
      5: {name: entity.name.tag.block.pta}
      6: {name: entity.name.tag.script.pta}
      7: {name: entity.name.tag.style.pta}
      8: {name: entity.name.tag.inline.pta}
      9: {name: entity.name.label.pta}
      10: {name: entity.name.project.pta}
      11: {name: entity.name.class.pta}
      12: {name: entity.name.type.pta}
  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.pta}
    patterns:
      - include: "#types"
  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.pta
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.pta
        patterns:
          - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.binding-pattern.object.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.dictionary.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
      round-brackets: &type-round-brackets
        repository:
          function-params:
            patterns:
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.optional.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.spread.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.name.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.reference.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.other.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.pta
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.pta
        patterns:
          - begin: \s*(\#?\()\s*
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - include: "#punctuation"
              - include: "#function-params"
              - include: "#types"
              - include: $self
      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
                captures:
                  1: {name: punctuation.separator.slice.pta}
              - match: ","
                name: punctuation.separator.sequence.pta
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.attribute-selector.pta}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.sequence.pta}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.pta
              - include: "#types"
              - include: $self
          - begin: \s*(\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.array.pta}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.pta
              - include: "#types"
              - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#type-embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
          - include: "#type-embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"

  type-embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.section.embedded.pta}
        patterns: [include: "types", include: $self]
      - match: |
          (?x)(\$)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.pta}
          2:
            {patterns: [include: "#types", include: "#embedded-content"]}

  type-embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.pta
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.extends.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.implements.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|attrof|infer|as|is)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(instof)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.instanceof.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(valof)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.valueof.pta

  type-operators:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`\\)}\]])
          (?:
          ([>.]\.[.<])
          |(\?[.:]=?)
          |(![.:]=?)
          |((?:::|\.)=?)
          )
          (?=\b|['"`\\({\[])
        captures:
          1: {name: keyword.operator.range.pta}
          2: {name: keyword.operator.optional.pta}
          3: {name: keyword.operator.assert.pta}
          4: {name: keyword.operator.accessor.pta}
      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.pta}
          2: {name: keyword.operator.difference.pta}
          3: {name: keyword.operator.product.pta}
          4: {name: keyword.operator.quotient.pta}
          5: {name: keyword.operator.remainder.pta}
          6: {name: keyword.operator.only.pta}
          7: {name: keyword.operator.maybe.pta}
          8: {name: keyword.operator.intersection.pta}
          9: {name: keyword.operator.union.pta}
          10: {name: keyword.operator.symmetric.pta}
          11: {name: keyword.operator.negation.pta}
          12: {name: keyword.operator.macro.dollar.pta}
          13: {name: keyword.operator.private.pta}
          14: {name: keyword.operator.class.pta}

  # Clauses and Keywords

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
        name: entity.name.namespace.pta
      - applyEndPatternLast: 1
        begin: \s+(impl)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.implements.pta}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.pta
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.namespace.pta
          - match: *class-name
            name: entity.name.trait.pta
          - include: "#comma"
      - applyEndPatternLast: 1
        begin: \s+(ext)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.pta}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.pta
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.module.pta
          - match: *class-name
            name: entity.name.interface.pta
          - include: "#comma"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.pta
      - include: "#regexps"
      - include: "#strings"
      - include: "#symbols"
      - include: "#constants"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]))
        end: (?=)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.pta}
        patterns: [include: "#types"]
      - include: "#comments"
      - include: "#brackets"
      - include: "#comma"
      - match: '\.|::'
        name: punctuation.separator.namespace.pta

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      # Visibility and mutability
      pub|priv|prot|after|mut|immut
      |glo|loc|early|late|covar|contra
      |seal|abst|inter|exter|imply|exply
      |sub|impure|pure

      # Concurrency/thread
      |sync|async|stat|dyn|lazy|eager|bound|free

      # Function and methods
      |rec|gen|oper|get|set|post|del|curry|inline
      |prefix|suffix|infix|binary|unary|left|right
      )
      )(?!\B|\p{Pd}+\b)\s*
      )*
      )
      (?=
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - &decorators
            match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
            name: entity.name.class.decorator.pta
          - &modifiers
            match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|after|mut|immut
              |glo|loc|early|late|covar|contra
              |seal|abst|inter|exter|imply|exply
              |sub|impure|pure
              )|
              (# Function or method modifiers
              sync|async|stat|dyn|lazy|eager|bound|free
              )|
              (# Property modifiers
              rec|gen|oper|get|set|post|del|curry|inline
              |prefix|suffix|infix|binary|unary|left|right
              )
              )(?!\B|\p{Pd}+\b)\s*
            captures:
              1: {name: storage.modifier.pta}
              2: {name: storage.type.accessor.pta}
              3: {name: storage.type.property.pta}
              4: {name: keyword.operator.expression.pta}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.declare.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.style.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.function.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.procedure.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.class.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.data.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.enum.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.module.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.iterator.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.macro.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.structure.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.object.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.trait.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.component.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.property.pta

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif|else)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.conditional.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|loop|while)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.loop.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|after)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.trycatch.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|case|fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.switch.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.flow.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.module.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from|ref|go|defer)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.$1.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.$1.pta

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.delete.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.range.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.void.pta
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.logical.pta

  keywords:
    patterns:
      - include: "#validation-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.flow.pta}
        patterns:
          - match: *entity-name
            name: constant.other.label.pta

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.module.pta}
            patterns:
              - *modifiers
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.module.pta
              - include: "#type-keywords"
              - include: "#declarations"
              - include: "#strings"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.pta
              - match: *entity-name
                name: variable.other.readwrite.alias.pta

      validation-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.validate.pta}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.pta
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.pta
          - include: $self

      query-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.query.pta}
          2: {patterns: [include: $self]}
          3: {name: keyword.control.query.pta}
        end: (?<=})|(?=[,;)\]])
        patterns:
          - include: "#query-body"
          - include: $self
      query-body:
        patterns:
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"
        repository:
          join-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part|self|cross)?(?!\B|\p{Pd}+\b)\s*\b(?:inner|outer|left|right)?(?!\B|\p{Pd}+\b)\s*\bjoin)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(on|equals|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          where-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having|filter|reject)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          sort-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sort(?!\B|\p{Pd}+\b)\s*\b(?:asc|desc)?(?!\B|\p{Pd}+\b)\s*\b(?:by|with)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - include: "#query-body"
              - include: $self
          select-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:select|map)(?!\B|\p{Pd}+\b)\s*\b(?:unique|any|all)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          limit-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit)(?!\B|\p{Pd}+\b)\s*\b(?:first|last|head|tail)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          reduce-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?!\B|\p{Pd}+\b)\s*\b(?:left|right)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          group-clause:
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?<=})|(?=[,;)\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#function"
      - include: "#procedure"
      - include: "#class"
      - include: "#data"
      - include: "#enum"
      - include: "#module"
      - include: "#iterator"
      - include: "#macro"
      - include: "#structure"
      - include: "#object"
      - include: "#trait"
      - include: "#component"
      - include: "#property"

    repository:
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.pta}
        patterns:
          - include: "#style-rules"
          - include: "#style-block"
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.pta

      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.pta}
      declare:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.pta}

      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.pta
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.pta
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.pta
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.data.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.pta
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.pta
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.pta
      iterator:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.iterator.pta
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.pta
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.structure.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.pta
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.pta
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.pta
      component:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.component.pta
      property:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.property.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.property.pta

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.method.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.method.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|[,;]\s*|\#?[({\[]\s*
      |(?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+
      |\b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|val|func|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|compo|prop
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.pta}
    end: (?<!\|)(\|)(?!\|)
    patterns: *function-params

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#params-clause"
      - include: "#function-clause"

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - include: "#function-params"
      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?!\B|\p{Pd}+\b)
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.pta}
        patterns:
          - match: *entity-name
            name: entity.name.instance.pta
          - include: "#type-keywords"
          - include: "#illegal-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"
      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.pta}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.pta}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.pta}
              - include: "#types"
      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.catch.pta
        captures:
          1: {name: keyword.control.error.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.pta
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.error.pta
          - include: $self
      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|while)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.for.pta
        captures:
          1: {name: keyword.control.loop.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - &for-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.loop.pta
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - *for-clause-keywords
              - include: $self
          - include: $self
      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.if.pta
        captures:
          1: {name: keyword.control.conditional.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - include: $self
      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;|})|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.switch.pta
        captures:
          1: {name: keyword.control.switch.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - begin: (\#\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.section.class.pta}
            patterns:
              - &case-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.pta}
                  2: {name: punctuation.separator.colon.pta}
                patterns:
                  - include: "#params-clause"
                  - applyEndPatternLast: 1
                    begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                    end: (?=)|$
                    beginCaptures:
                      1: {name: keyword.control.switch.pta}
                    patterns:
                      - include: "#types"
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.switch.pta
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.switch.pta
                  - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                    name: keyword.control.switch.pta
                  - include: "#type-keywords"
                  - include: $self
              - &default-clause
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?!\B|\p{Pd}+\b)\s*
                end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
                captures:
                  1: {name: keyword.control.switch.pta}
                  2: {name: punctuation.separator.colon.pta}
                patterns:
                  - include: $self
              - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.pta}
            patterns:
              - *case-clause
              - *default-clause
              - include: $self
          - include: $self
      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.with.pta
        captures:
          1: {name: keyword.control.with.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.with.pta
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - *with-clause-keywords
              - include: $self
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          def|func|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: punctuation.separator.key-value.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: punctuation.separator.key-value.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params
      - match: |
          (?x)
          (?<=^|{|;|,|\s)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
        name: meta.object-literal.key.pta
        captures:
          1:
            name: constant.other.object.key.pta
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"
          2: {name: punctuation.separator.key-value.pta}

  # Punctuation

  punctuation:
    patterns:
      - include: "#comma"
      - include: "#semicolon"

  line-continuation:
    match: \\\n*|(\\)\s*(?=/[/*+]|$)
    name: punctuation.separator.continuation.line.pta
  comma:
    match: \s*(,)
    name: punctuation.separator.comma.pta
  double-semi:
    match: \s*(;;)
    name: punctuation.terminator.expression.pta
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.pta

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
      - include: "#angle-brackets"

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments.flowtype
        begin: (?<=\b|['"`)}\]])(<)(?=\b|['"`({\[])
        end: (?<=\b|['"`)}\]>])(>)
        captures:
          1: {name: punctuation.type.arguments.pta}
        patterns:
          - include: "#types"
          - include: "#punctuation"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.pta
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.pta
      closures:
        patterns:
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.switch.pta}
              2: {name: punctuation.separator.colon.pta}
            patterns:
              - include: "#params-clause"
              - applyEndPatternLast: 1
                begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                end: (?=)|$
                beginCaptures:
                  1: {name: keyword.control.switch.pta}
                patterns:
                  - include: "#types"
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.switch.pta
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|set|get|const)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.switch.pta
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.switch.pta
              - include: "#type-keywords"
              - include: $self
          - begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def)(?!\B|\p{Pd}+\b)\s*
            end: (?<=;)|(?={)|$|(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
            captures:
              1: {name: keyword.control.switch.pta}
              2: {name: punctuation.separator.colon.pta}
            patterns:
              - include: $self
          - include: $self
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.typeparameters.pta}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.object.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.mapping.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.dictionary.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.section.class.pta}
        patterns:
          - include: "#closures"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.pta}
        patterns:
          - include: "#closures"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.pta
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.pta
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.pta
    patterns:
      - begin: \s*(?<=[\w'"`)}\]>]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - include: "#punctuation"
          - include: "#clauses"
          - include: "#constants"
          - include: "#declarations"
          - include: "#expression-keywords"
          - include: "#function-params"
          - include: $self
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.pta}
        patterns:
          - include: "#labels"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.expression.pta}
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
            captures:
              1: {name: punctuation.separator.slice.pta}
          - match: ","
            name: punctuation.separator.sequence.pta
    patterns:
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.array.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.attribute-selector.pta}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.sequence.pta}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.pta
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.array.pta}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.pta
          - include: $self

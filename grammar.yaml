name: SagaScript
scopeName: source.coffee
fileTypes: [sa, coffee]
patterns: [{include: "#core"}]

information_for_contributors: |
  SagaScript is a modern functional, imperative and object-oriented programming language
  with a syntax inspired by Python, and compile(s) to JavaScript and WebAssembly.

  SagaScript is additionally inspired by Ruby, Elixir, Clojure, LiveScript, Haskell, OCaml, Go,
  Scala, Flix, Nim, Bash and YAML.

  Should you want to provide a fix or improvement, or even a new feature,
  please create a pull request against this repo - https://github.com/nxltm/sagascript
  and I will be very happy to receive them.

  Once accepted, I am happy to receive your request and feedback.

  This document is always under construction, and there's still a couple of things that
  need to be fixed. All this info would be on my Trello which I will be posting very soon.
  I will come back to fix them if I have the time.

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.sa}
    2: {name: punctuation.separator.decimal.period.sa}
    3: {name: constant.numeric.other.separator.sa}
    4: {name: constant.numeric.other.exponent.sa}
    5: {name: constant.numeric.other.density.sa}
    6: {name: storage.type.numeric.sa}

  entity-name: &entity-name |
    (?x)\s*\b

    (?!
    \b(?:# don't match keywords
    in|of|as|is|new|infer|unset
    |typeof|nameof|sizeof|keyof|valof
    |len|del|to|til|thru|at|by
    |and|x?or|not|para|seq|spawn
    |def|func?|fn|macro|proc|sub
    |let|var|val|const|decl
    |class|given|law|enum|rel|lat
    |proj|prot|ext|impl|frag|inter|struct
    |module|nspace|object|record|label
    |raw|data|query|schema|style|trait|alias|type
    |if|else|elif|eless|unless|guard
    |for|each|while|until|repeat|do|redo
    |switch|case|fail|default|match|when|pass|fallthru
    |try|retry|throw|raise|catch|rescue|finally
    |with|ref|defer|refer|show|hide|enter|exit
    |then|begin|end|debug|check|assert
    |break|continue|halt|skip|fixed|lock
    |(?:return|give|await|yield|throw|raise)s?
    |yield\b\s*\bfrom|import|export|show|hide
    |from|where|join|equals|[io]nto|order
    |take|drop|fold|scan|select|use|using
    |fi|rof|done|esac|wend|yrt|disc|wout
    |open|close
    )\b
    )

    ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
    \b

  posix-class: &posix-class |
    (?xi)
    \\o|
    \\p(?:
    # POSIX
    alpha|alnum|ascii|blank|cntrl|x?digit
    |graph|lower|print|punct|space|upper|word
    # Extended-POSIX
    |symbol|open|close|dash|link|start|final|math|money
    |number|letter|title|mark|modify
    |binary|quater|senary|octal|decim|dozen|hexa
    )

repository:
  core:
    patterns:
      - include: "#embedded-langs"
      - include: "#declarations"
      - include: "#clauses"
      - include: "#keywords"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"
      - include: source.ruby
      - include: source.python
      - include: source.fsharp

  illegal:
    patterns:
      - match: '\p{n}[\p{l}\p{m}\p{n}_.+-/\\]*?'
        name: invalid.illegal.numeric.other.sa
      - match: '[_\p{l}\p{m}\p{n}]+?'
        name: invalid.illegal.variable.other.sa
      - match: '[\p{ps}\p{pe}]+?'
        name: invalid.illegal.missing-bracket.sa
      - match: '\S+?'
        name: invalid.illegal.syntax.sa

  clause-content:
    patterns:
      - include: "#embedded-langs"
      - include: "#declarations"
      - include: "#clauses"
      - include: "#keywords"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"

  function-names:
    comment: Names for built-in functions
    patterns: []

  method-names:
    comment: Names for static and instance methods
    patterns: []

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns: []

  variable-names:
    comment: Standard Library variable names
    patterns: []

  property-names:
    comment: Standard Library property names
    patterns: []

  type-names:
    comment: Names for types and more
    patterns:
      - comment: primitive data types
        match: |
          (?x)\s*\b(
          bool|u?int|float|nat|ratio|real|imag|complex|number
          |char|rune|string|symbol|regexp?|func|buffer|binary
          |# numeric types
          (?:c|i|f|s|u|n|[nr]at|u?int|float|imag|comp)
          (?:8|16|32|64|128)
          |(?:c|i|)(?:half|float|double|quad|octa)
          )\b
        name: support.type.builtin.primitive.sa
      - comment: built-in constant types and data structures
        match: |
          (?x)\s*\b(
          true|yes|on|false|no|off|null|nil|none|undef|void|nan|inf|infin
          |any|empty|object|record|unit|mixed
          |array|tuple|(?:mut)?(?:list|set|map)|dict|seq|gen|range
          )\b
        name: support.type.builtin.sa
      - comment: built-in primitive classes
        match: |
          (?x)\s*\b(
          Bool|U?Int|Float|Nat|Ratio|Real|Imag|Complex|Number
          |Char|Rune|String|Symbol|RegExp?|Func|Buffer|Binary
          |# numeric types
          (?:C|I|F|S|U|N|[NR]at|U?Int|Real|Imag|Comp)
          (?:8|16|32|64|128)
          |(?:C|I|)(?:Half|Float|Double|Quad|Octa)
          )\b
        name: support.type.builtin.class.sa
      - comment: built-in primitive type classes
        match: |
          (?x)\s*\b(
          True|False|Nil|Null|Void|NaN|Infin
          |Any|Empty|Object|Record|Unit|Mixed
          |Array|Tuple|(?:Mut)?(?:List|Set|Map)|Dict|Seq|Gen|Range
          )\b
        name: support.type.class.sa
      - comment: interface classes (beginning with I)
        match: (?x)\s*\b(I((\p{lu}\p{ll}*)+))\b
        name: entity.name.interface.sa
      - comment: namespace classes (beginning with NS)
        match: (?x)\s*\b(NS((\p{lu}\p{ll}*)+))\b
        name: entity.name.namespace.sa
      - comment: error classes (ending with Error)
        match: (?x)\s*\b(((\p{lu}\p{ll}*)+)Error)\b
        name: support.class.error.sa

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*\b(?:
          (true|yes|on)|(false|no|off)|(null|nil|none)|(undef|void)|(nan)|(inf|infin)
          )\b\s*
        captures:
          1: {name: constant.language.boolean.true.sa}
          2: {name: constant.language.boolean.false.sa}
          3: {name: constant.language.null.sa}
          4: {name: constant.language.undefined.sa}
          5: {name: constant.language.nan.sa}
          6: {name: constant.language.infinity.sa}
      - match: |
          (?x)\s*\b(?:
          (params|args)|(super|this|self)|(_|proto)|(ctor)|(targ)
          )\b\s*
        captures:
          1: {name: variable.language.arguments.sa}
          2: {name: variable.language.$2.sa}
          3: {name: variable.language.prototype.sa}
          4: {name: variable.language.constructor.sa}
          5: {name: variable.language.target.sa}

  numbers:
    patterns:
      - match: (?<=(^|\p{ps})\s*\d\w*)\.
        name: punctuation.separator.decimal.period.sa
      - match: (?<=(?:^|\p{ps})\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.sa
      - match: |-
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)
          (?:(\.)(?:\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)?)?
          (?:(\*)\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)?
          (?:(\.)(?:\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)?)
          (?:(\*)\p{alnum}+(?:(?:,|_+)?*\p{alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0b)
          (?:[01]+(?:(?:,|_+)?*[01]+)*)
          (?:(\.)(?:[01]+(?:(?:,|_+)?*[01]+)*)?)?
          (?:(\*)[01]+(?:(?:,|_+)?*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0b)
          (?:[01]+(?:(?:,|_+)?*[01]+)*)?
          (?:(\.)(?:[01]+(?:(?:,|_+)?*[01]+)*)?)
          (?:(\*)[01]+(?:(?:,|_+)?*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)
          (?:(\.)(?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?)?
          (?:(\*)[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (?:(\.)(?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?)
          (?:(\*)[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)
          (?:(\.)(?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?)?
          (?:(\*)[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (?:(\.)(?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?)
          (?:(\*)[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)
          (?:(\.)(?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?)?
          (?:(\*)[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (?:(\.)(?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?)
          (?:(\*)[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)
          (?:(\.)(?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?)?
          (?:(\*)[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (?:(\.)(?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?)
          (?:(\*)[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0x)
          (?:\h+(?:(?:,|_+)?*\h+)*)
          (?:(\.)(?:\h+(?:(?:,|_+)?*\h+)*)?)?
          (?:(\*)\h+(?:(?:,|_+)?*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (0x)
          (?:\h+(?:(?:,|_+)?*\h+)*)?
          (?:(\.)(?:\h+(?:(?:,|_+)?*\h+)*)?)
          (?:(\*)\h+(?:(?:,|_+)?*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          ()
          (?:\d+(?:(?:,|_+)?*\d+)*)
          (?:(\.)(?:\d+(?:(?:,|_+)?*\d+)*)?)?
          (?:(\*)\d+(?:(?:,|_+)?*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          ()
          (?:\d+(?:(?:,|_+)?*\d+)*)?
          (?:(\.)(?:\d+(?:(?:,|_+)?*\d+)*)?)
          (?:(\*)\d+(?:(?:,|_+)?*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:(?:,|_+)?*\w+)*)
          (?:(\.)(?:\w+(?:(?:,|_+)?*\w+)*)?)?
          (?:(\*)\w+(?:(?:,|_+)?*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.sa}
          <<: *number-literal
      - match: |-
          (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:(?:,|_+)?*\w+)*)?
          (?:(\.)(?:\w+(?:(?:,|_+)?*\w+)*)?)
          (?:(\*)\w+(?:(?:,|_+)?*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.sa}
          <<: *number-literal

  strings-quoted:
    patterns:
      - comment: single quoted raw string
        begin: \s*('{3,})
        contentName: string.quoted.single.sa
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.sa}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: \s*(')
        contentName: string.quoted.single.sa
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.sa}
        patterns:
          - match: "''"
            name: constant.character.escape.sa
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: \s*("{3,}|")
        contentName: string.quoted.double.sa
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.sa}
        patterns:
          - include: "#string-escapes"

  strings-unquoted:
    patterns:
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.sa}
          2: {name: storage.modifier.chomping-indicator.sa}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.sa}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.sa
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.sa
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.sa}
          2: {name: storage.modifier.chomping-indicator.sa}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.sa}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.syntax.sa
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.sa
            patterns:
              - include: "#string-escapes"
              - include: text.html.markdown#inline
          - include: $self
      - match: |
          (?x)
          \s*(\\)
          ((?:\\.|[^\s,:;])+?)
          (?=[\p{ps}\p{pe}\s,:;]|$)\s*
        name: string.unquoted.sa
        captures:
          1: {name: punctuation.definition.string.sa}
          2: {patterns: [{include: "#string-escapes"}]}

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.sa
      - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
        name: constant.character.escape.binary.sa
      - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
        name: constant.character.escape.quaternary.sa
      - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
        name: constant.character.escape.senary.sa
      - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
        name: constant.character.escape.octal.sa
      - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
        name: constant.character.escape.decimal.sa
      - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
        name: constant.character.escape.duodecimal.sa
      - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.hexadecimal.sa
      - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.unicode.sa
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.sa
        patterns:
          - include: "#regexp-patterns"
      - match: (?i)\\[abceflnprtvz]
        name: constant.character.escape.sa
      - match: \\[\p{s}\p{p}]
        name: constant.character.escape.symbol.sa
      - match: \\[\p{l}\p{n}\p{z}\p{c}]
        name: constant.character.escape.illegal.sa
      - include: "#embedded"

  embedded:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.sa}
          2: {name: constant.numeric.decimal.sa}
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.sa}
          2: {name: storage.type.format.sa}
      - match: |
          (?xi)
          #(?<!\\)# no backslash
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.sa}
          2: {patterns: [{include: "#core"}]}
      - begin: (?#?<!\\)(\${)\s*
        end: (})
        name: entity.quasi.element.sa
        captures:
          1: {name: punctuation.quasi.element.sa}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.sa}
          2: {name: constant.numeric.decimal.sa}
      - match: ([$%]){2}
        name: constant.character.escape.sa
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.sa}
          2: {name: storage.type.format.sa}
      - match: |
          (?xi)
          (?<!\$)# no dollar
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.sa}
          2: {patterns: [{include: "#core"}]}
      - begin: (?<!\$)(\${)\s*
        end: (})
        name: entity.quasi.element.sa
        captures:
          1: {name: punctuation.quasi.element.sa}
        patterns:
          - include: $self

  symbols:
    match: |
      (?x)
      \s*\b
      (:)((?:\w|\\.)(?:\\.|[^\s,:;])*?)
      \b\s*
    name: meta.symbol.sa
    captures:
      1: {name: punctuation.definition.symbol.sa}
      2: {name: constant.other.symbol.sa}

  labels:
    match: |
      (?x)
      (?<=^|[\p{ps}\s,;])\s*

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|seq|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|disc|wout
      |open|close
      )\b
      )

      ((?:\w|\\.)(?:\\.|[^\s,:;])*?)
      (?=:\s+)
    name: meta.object-literal.key.sa
    captures:
      1: {name: constant.other.object.key.sa}
      2: {name: punctuation.separator.key-value.sa}

  regexps:
    patterns:
      - begin: (\p{alnum}*)(\`)\s*
        end: \s*(?!\\)(\`(?!\`))(\p{alnum}*)
        contentName: string.pattern.regexp.sa
        beginCaptures:
          1: {name: keyword.modifier.sa}
          2: {name: punctuation.section.regexp.begin.sa}
        endCaptures:
          1: {name: punctuation.section.regexp.end.sa}
          2: {name: keyword.other.flag.sa}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - begin: (\`)(\`)\s*\n?
            end: \s*(?=(?!\\)\`)
            contentName: string.replace.regexp.sa
            beginCaptures:
              1: {name: punctuation.section.regexp.end.sa}
              2: {name: punctuation.section.regexp.begin.sa}
            patterns:
              - include: "#back-references"
      - begin: |
          (?x)\s*
          (\\\<)\s*
          ([-+*/<=>])?\s*
          (?:(\w+)?\b\s*\b
          (
          \w+\s*
          (?:[+-]\s*
          (?:(?:\w+)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.sa}
          2: {name: storage.modifier.chomping-indicator.sa}
          3: {name: keyword.modifier.sa}
          4: {name: keyword.other.flag.sa}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.sa
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.out.sa
            patterns:
              - include: "#regexp-patterns"
          - include: $self

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.sa
      - match: \${2}
        name: constant.character.escape.sa
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.sa
        beginCaptures:
          1: {name: keyword.other.back-reference.sa}
        endCaptures:
          1: {name: keyword.other.back-reference.sa}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-escapes"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.sa
      - match: \&
        name: keyword.operator.match.sa
      - match: \!
        name: keyword.operator.disjunction.sa
      - match: \.
        name: constant.character.all.sa
      - match: (?i)\\[by]({\p{alpha}+})?
        name: keyword.control.anchor.sa
      - match: (?i)(\^|\\<|\\a(?:{\p{alpha}+})?)|(\$|\\>|\\z(?:{\p{alpha}+})?)
        captures:
          1: {name: keyword.control.begin.sa}
          2: {name: keyword.control.end.sa}
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.sa}
          2: {name: keyword.operator.quantifier.lazy.sa}
          3: {name: keyword.operator.quantifier.eager.sa}
          4: {name: keyword.operator.quantifier.greedy.sa}
      - match: \\\d+
        name: keyword.other.back-reference.sa
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.sa
      - begin: (\\Q)
        contentName: string.quoted.single.sa
        end: (\\E)
        name: string.quoted.raw.sa
        captures:
          1: {name: keyword.control.quote.sa}
        patterns:
          - include: "#string-escapes"
      - begin: (\\q)
        contentName: string.quoted.double.sa
        end: (\\e)
        name: string.quoted.sa
        captures:
          1: {name: keyword.control.quote.sa}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.sa
        beginCaptures:
          1: {name: keyword.other.back-reference.sa}
        endCaptures:
          1: {name: keyword.other.back-reference.sa}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.sa
        beginCaptures:
          1: {name: keyword.other.subroutine.sa}
        endCaptures:
          1: {name: keyword.other.subroutine.sa}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.sa}
          2: {name: keyword.control.keepout.sa}
          3: {name: keyword.control.search.sa}
          4: {name: constant.character.unicode.sa}
      - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.sa}
          2: {name: keyword.operator.modifier.eager.sa}
          3: {name: keyword.operator.modifier.greedy.sa}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.sa}
          2: {name: keyword.operator.quantifier.eager.sa}
          3: {name: keyword.operator.quantifier.greedy.sa}
      - match: \\.
        name: constant.character.escape.other.sa

    repository:
      regexp-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.sa
            captures:
              0: {name: punctuation.section.expression.sa}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.sa
            end: \s*(\))
            name: comment.block.regexp.sa
            captures:
              1: {name: punctuation.definition.comment.sa}
            patterns:
              - match: \\.
                name: comment.block.regexp.sa
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.look-ahead.sa
            captures:
              1: {name: punctuation.definition.group.look-ahead.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.look-behind.sa
            captures:
              1: {name: punctuation.definition.group.look-behind.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.negative-look-ahead.sa
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.negative-look-behind.sa
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{lower}+(?:[+-]\p{lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.flag.sa
            captures:
              0: {name: punctuation.definition.group.flag.sa}
              1: {name: punctuation.definition.group.flag.sa}
              2: {name: entity.name.function.method.sa}
              3: {name: keyword.control.recursion.sa}
              4: {name: keyword.other.flag.sa}
              5: {name: punctuation.separator.key-value.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.call-out.sa
            captures:
              1: {name: punctuation.definition.group.call-out.sa}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.sa
                captures:
                  1: {name: punctuation.definition.group.call-out.sa}
                  2: {name: keyword.operator.range.sa}
                  3: {name: punctuation.definition.tag.sa}
                  4: {patterns: [{include: "#function-entities"}]}
                  5: {name: punctuation.definition.tag.sa}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.atomic.sa
            captures:
              1: {name: punctuation.definition.group.atomic.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.non-capturing.sa
            captures:
              1: {name: punctuation.definition.group.non-capturing.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.branch.sa
            captures:
              1: {name: punctuation.definition.group.branch.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.absent.sa
            captures:
              1: {name: punctuation.definition.group.absent.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([_\p{l}\p{Nl}][_\\d\p{l}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.back-reference.sa
            captures:
              0: {name: punctuation.definition.group.back-reference.sa}
              1: {name: punctuation.definition.group.back-reference.sa}
              2: {name: entity.name.function.method.sa}
              3: {name: variable.other.sa}
              4: {name: punctuation.separator.key-value.sa}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.named.sa
            beginCaptures:
              0: {name: punctuation.definition.group.named.sa}
              1: {patterns: [{include: "#variables"}]}
            endCaptures:
              0: {name: punctuation.definition.group.named.sa}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.sa
                beginCaptures:
                  1: {name: punctuation.definition.group.named.sa}
                endCaptures:
                  1: {name: punctuation.definition.group.named.sa}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            name: meta.group.sa
            captures:
              0: {name: punctuation.definition.group.sa}
            patterns:
              - include: "#regexp-patterns"

      regexp-char-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.sa
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.sa
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.sa
            patterns:
              - include: "#regexp-patterns"
          - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
            name: constant.character.escape.binary.sa
          - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
            name: constant.character.escape.quaternary.sa
          - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
            name: constant.character.escape.senary.sa
          - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
            name: constant.character.escape.octal.sa
          - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
            name: constant.character.escape.decimal.sa
          - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
            name: constant.character.escape.duodecimal.sa
          - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.hexadecimal.sa
          - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.unicode.sa
          - match: (?i:\\[cm][a-z])|\\R
            name: constant.character.control.sa
          - match: *posix-class
            name: constant.other.character-class.posix.sa
          - match: (?i:\\p(c[cfos]?|l[lmotu]?|m[cen]?|n[dlo]?|p[c-fios]?|s[ckmo]?|z[lps]))
            name: constant.other.character-class.unicode.sa
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.sa
          - match: \.|\\[dhlns-w]
            name: constant.other.character-class.sa
          - match: \\[DHLNS-W]
            name: constant.other.character-class.negated.sa
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.sa
          - match: (?i)\\[abceflnprtvz]
            name: constant.character.escape.sa
          - match: \\[\p{s}\p{p}]
            name: constant.character.escape.symbol.sa
          - match: \\\p{z}
            name: constant.character.escape.symbol.sa
          - match: \\[\p{l}\p{n}\p{z}\p{c}]
            name: constant.character.escape.illegal.sa
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: \--
            name: keyword.operator.optional.sa
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.sa
          - match: \|\|
            name: keyword.operator.union.sa
          - match: \&&
            name: keyword.operator.intersection.sa
          - match: \^\^
            name: keyword.operator.only.sa
          - match: ~~
            name: keyword.operator.maybe.sa
          - match: \.
            name: constant.other.character-class.range.sa
          - match: \\.
            name: constant.character.escape.other.sa

      regexp-char-set:
        patterns:
          - begin: (\[=)
            end: \s*(\])
            name: constant.other.character-class.posix.sa
            captures:
              1: {name: punctuation.definition.character-class.posix.sa}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\.)
            end: \s*(\])
            name: constant.other.character-class.posix.sa
            captures:
              1: {name: punctuation.definition.character-class.posix.sa}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[:)
            end: \s*(\])
            name: constant.other.character-class.posix.sa
            captures:
              1: {name: punctuation.definition.character-class.posix.sa}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.negated.sa
            captures:
              1: {name: punctuation.definition.character-class.negated.sa}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.sa
            captures:
              1: {name: punctuation.definition.character-class.sa}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"

  document:
    patterns:
      - include: "#document-inline-tags"
      - include: "#document-access"
      - include: "#document-as-name-path"
      - include: "#document-simple-name-path"
      - include: "#document-module"
      - include: "#document-type-name"
      - include: "#document-type-no-name"
      - match: (?<=^|[''"\`\\\s\p{ps}])@([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\b
        name: storage.type.class.sa

    repository:
      document-access:
        match: |
          (?x)
          (@acc)\b\s*\b
          (?:
          (?:
          pub|prot|pvt|pte|priv|read|a?sync|inline|lazy|eager|trans|part
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          # Function or method modifiers
          |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |# Function or method modifiers
          (?:pre|in|post|suf|af|trans|inter)fix|
          (?:u|bi|ter|)nary|oper
          |# Decorators
          @(?:
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )\s*\b
          )*
          (?=\s|$)
        captures:
          1: {name: storage.type.class.sa}
          0: {name: storage.modifier.sa}
      document-as-name-path:
        begin: (@(borrows|lends)\b)\s*(?=(?![}\]]\#)\S+(?:(?:\s*\bas\b\s*(?![}\]]\#)\S+)?)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - include: "#document-name-path-scopes"
      document-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.sa
        beginCaptures:
          1: {name: string.linktext.sa}
          2: {name: meta.brace.curly.sa}
        endCaptures:
          1: {name: meta.brace.curly.sa}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.sa}
              3: {name: string.sa}
      document-module:
        begin: |
          (?x)(@(
          (?:(?:im|ex)port|listen|require|use)s?
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - include: "#document-typedef-scopes"
          - match: (?:(module)(:))?(((?![}\]]\#)\S)+)
            captures:
              1: {name: keyword.module.sa}
              2: {name: punctuation.sa}
              3: {name: string.module-name.sa}
      document-name-scopes:
        patterns:
          - match: ((?![}\]]\#)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.sa}
          - begin: \[
            end: \]|^
            name: variable.other.sa
            patterns:
              - include: "#document-string"
              - include: "#document-name-scopes"
      document-simple-name-path:
        begin: |
          (?x)(@(
          (?:use|call|emit|event|fire)s?|alias|name|mixes|prop
          |this|that|it|self|super
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#types"
      document-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.sa
      document-type-name:
        begin: |
          (?x)(@(
          def|func?|fn|macro|proc|sub|class|given|law|const|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct|module|nspace|object|record|raw
          |data|query|schema|style|trait|alias|type|decl|let|va[rl]
          |arg|ctor|member|method|mixin|param
          )\b)\s*
          (?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#document-name-scopes"
      document-type-no-name:
        begin: |
          (?x)
          (@(
          pub|prot|pvt|pte|priv|read|a?sync|inline|lazy|eager|trans|part
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          # Function or method modifiers
          |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |# Function or method modifiers
          (?:pre|in|post|suf|af|trans|inter)fix|
          (?:u|bi|ter|)nary|oper
          |# Decorators
          @(?:
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - include: "#document-typedef-scopes"
      document-typedef-obj:
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.sa}
        patterns:
          - include: "#types"
      document-typedef-scopes:
        begin: "{"
        end: "}|^"
        name: entity.name.type.instance.sa
        captures:
          0: {name: meta.brace.curly.sa}
        patterns:
          - include: "#types"

  comments:
    patterns:
      - begin: \s*((#\())
        end: (\s*(\)))
        name: comment.block.inline.sa
        captures:
          1: {name: comment.block.inline.sa}
          2: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      - begin: \s*((#{))
        end: (\s*(}#))
        name: comment.block.documentation.sa
        captures:
          1: {name: comment.block.documentation.sa}
          2: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      - begin: \s*((#\[))
        end: (\s*(\]#))
        name: comment.block.sa
        captures:
          1: {name: comment.block.sa}
          2: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-block"
      - begin: ((^\s*)|\s*)((#=))
        end: \s*$
        name: comment.line.special.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.special.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          1: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#comment-special"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((##))
        end: \s*$
        name: comment.line.playground.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.playground.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          0: {name: comment.line.playground.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#:))
        end: \s*$
        name: comment.line.documentation.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.documentation.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          0: {name: comment.line.documentation.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#!))
        end: \s*$
        name: comment.line.shebang.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.shebang.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          0: {name: comment.line.shebang.sa}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#\?))
        end: \s*$
        name: comment.line.doctype.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.doctype.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          0: {name: comment.line.doctype.sa}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#))
        end: \s*$
        name: comment.line.number-sign.sa
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.sa}
          3: {name: comment.line.double-slash.sa}
          4: {name: punctuation.definition.comment.sa}
        endCaptures:
          0: {name: comment.line.number-sign.sa}
        patterns:
          - include: "#markdown-inline"

    repository:
      markdown-inline:
        patterns:
          - include: text.html.markdown#inline
      nested-block:
        begin: (#\[)\s*
        end: \s*(\]#)
        captures:
          1: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-block"
      nested-document-block:
        begin: (#{)\s*
        end: \s*(}#)
        captures:
          1: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      nested-inline:
        begin: (\()\s*
        end: \s*(\))
        name: comment.block.inline.sa
        captures:
          1: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      nested-special:
        begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.comment.sa}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-special"

  calls:
    patterns:
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not|para|seq|spawn
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|law|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|query|schema|style|trait|alias|type
          |if|else|elif|eless|unless|guard
          |for|each|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|select|use|using
          |fi|rof|done|esac|wend|yrt|disc|wout
          |open|close
          )\b
          )
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          )
          \b\s+
          (?=
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not|para|seq|spawn
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|law|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|query|schema|style|trait|alias|type
          |if|else|elif|eless|unless|guard
          |for|each|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|select|use|using
          |fi|rof|done|esac|wend|yrt|disc|wout
          |open|close
          )\b
          )
          [_\p{l}\p{m}\p{n}]+|\[(?!<))
        captures:
          1: {patterns: [{include: "#function-entities"}]}
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not|para|seq|spawn
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|law|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|query|schema|style|trait|alias|type
          |if|else|elif|eless|unless|guard
          |for|each|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|select|use|using
          |fi|rof|done|esac|wend|yrt|disc|wout
          |open|close
          )\b
          )
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          )
          \b
          (?=
          !(?:\.=?)?\s*|
          \s+[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*

          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not|para|seq|spawn
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|law|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|query|schema|style|trait|alias|type
          |if|else|elif|eless|unless|guard
          |for|each|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|select|use|using
          |fi|rof|done|esac|wend|yrt|disc|wout
          |open|close
          )\b
          )

          [_\p{l}\p{m}\p{n}]+|\[<|
          (?:[!?~]?\.=?|[?!:]:=?|->)?\s*['"\`\\\p{ps}&&[^\[{]]
          )
        captures:
          1: {patterns: [{include: "#function-entities"}]}

  function-entities:
    patterns:
      - match: |
          (?x)\b(?:
          (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          |
          (?:# Objects and maps
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

          |
          (?:# Regular variables
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.sa}
          2: {name: entity.name.tag.sa support.class.component.sa}
          3: {name: entity.name.class.builtin.sa}
          4: {name: entity.name.function.method.sa}
          5: {name: variable.other.global.sa}
          6: {name: variable.other.constant.object.sa}
          7: {name: variable.other.conditional.sa}
          8: {name: variable.other.object.sa}
          9: {name: entity.name.function.tagged-template.sa}
          10: {name: entity.name.type.sa}
          11: {name: entity.name.class.sa}
          12: {name: entity.name.function.sa}
      - include: $self

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|seq|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|disc|wout
      |open|close
      )\b
      )

      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.sa}
      2: {name: variable.other.constant.property.sa}
      3: {name: variable.other.property.static.sa}
      4: {name: variable.other.property.sa}
      5: {name: variable.other.global.sa}
      6: {name: variable.other.constant.object.sa}
      7: {name: variable.other.conditional.sa}
      8: {name: variable.other.object.sa}
      9: {name: variable.other.dollar.sa}
      10: {name: variable.other.constant.sa}
      11: {name: variable.other.class.sa}
      12: {name: variable.other.readwrite.sa}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops-builtin:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+(?<![!:~.<=>])=)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.assignment.augmented.sa
          - comment: "assignment : :="
            match: (?<=^|['"\`\\\p{ps}\s])(:?=)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.assignment.sa
          - comment: arithmetic + - * ** *** / // /// % %% *> <*
            match: (?<=^|['"\`\\\p{ps}\s])((?<!<)\+(?!>|\++)|(?<!<)-(?!>|-+)|\*{1,3}|/{1,3}(?!\\)|%%?|\*+>|<\*+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arithmetic.sa
          - comment: increment/decrement ++ --
            match: (?<=^|['"\`\\\p{ps}\s])((?:[+-])+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.successor.sa
          - comment: logical && || ^^ /\ / \ \\ etc.
            match: (?<=^|['"\`\\\p{ps}\s])((?:[&^]){2,}|\|\|+(?!>)|/\\|\\/|\\+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.logical.sa
          - comment: bitwise & | ^ ~
            match: (?<=^|['"\`\\\p{ps}\s])([&^]|\|(?!>)|~(?![!=<>]))(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.sa
          - comment: shift << >> <<< >>>>
            match: (?<=^|['"\`\\\p{ps}\s])(<{2,}(?![!:=+|*])|(?<![!:=+|*])>{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.shift.sa
          - comment: function composition +> <+
            match: (?<=^|['"\`\\\p{ps}\s])(<\++|\++>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.compose.sa
          - comment: pipeline |> <|
            match: (?<=^|['"\`\\\p{ps}\s])(<\|+|\|+>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.pipeline.sa
          - comment: "class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<"
            match: (?<=^|['"\`\\\p{ps}\s])([<>][!:][<>]?|[!:][<>])(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.class.sa
          - comment: relational < > <= >=
            match: (?<=^|['"\`\\\p{ps}\s])([<>]=?)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.relational.sa
          - comment: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
            match: (?<=^|['"\`\\\p{ps}\s])(<>|=<|<(?:[/*+$])+>?|(?:[/*+$])+>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.regexp.sa
          - comment: equality == != === !==
            match: (?<=^|['"\`\\\p{ps}\s])([!=]=+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.comparison.sa
          - comment: similarity operators
            match: (?<=^|['"\`\\\p{ps}\s])([!=~]+~|~[!=~]+|[<~>]+~[<~>]*|~[<~>]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.similarity.sa
          - comment: fat arrow-like => ==> <==
            match: (?<=^|['"\`\\\p{ps}\s])([=>]+|[<=]+|[=>]+[<=]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arrow.fat.sa
          - comment: skinny arrow-like -> <- --> <--
            match: (?<=^|['"\`\\\p{ps}\s])([->]+|[<-]+|[->]+[<-]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arrow.skinny.sa
          - comment: wavy arrow-like ~> <~ ~~> <~~
            match: (?<=^|['"\`\\\p{ps}\s])([~>]+|[<~]+|[~>]+[<~]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arrow.wavy.sa
          - comment: null-coalescing ??
            match: (?<=^|['"\`\\\p{ps}\s])(\?{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.null-coalescing.sa
          - comment: non-null coalescing !!
            match: (?<=^|['"\`\\\p{ps}\s])(!{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.coalescing.sa
          - comment: "false coalescing ?:"
            match: (?<=^|['"\`\\\p{ps}\s])(\?+:+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.conditional.sa
          - comment: "true coalescing !:"
            match: (?<=^|['"\`\\\p{ps}\s])(!+:+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.ternary.sa
          - comment: "infix function $:"
            match: (?<=^|['"\`\\\p{ps}\s])(\$+:+|\${2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.macro.dollar.sa
          - comment: custom bitwise (leading &|^ ~)
            match: (?<=^|['"\`\\\p{ps}\s])([&|^~][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.sa
          - comment: custom arithmetic (leading + - * / %)
            match: (?<=^|['"\`\\\p{ps}\s])([+\-*/%][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arithmetic.sa
          - comment: "custom accessor (leading : .)"
            match: (?<=^|['"\`\\\p{ps}\s])([:.][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.prototype.sa
          - comment: custom equality (leading = !)
            match: (?<=^|['"\`\\\p{ps}\s])([!=][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.comparison.sa
          - comment: custom comparison (leading < >)
            match: (?<=^|['"\`\\\p{ps}\s])([<>][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.relational.sa
          - comment: custom optional (leading ?)
            match: (?<=^|['"\`\\\p{ps}\s])(\?[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.private.sa
          - comment: custom mathematical (leading Unicode category Sm)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{sm}&&[\x{80}-\x{10ffff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.math.sa
          - comment: custom currency-based (leading Unicode category Sc)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{sc}&&[^$]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.currency.sa
          - comment: custom ASCII (leading Unicode 0x80 to 0xFF)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[\x{80}-\x{ff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.ascii.sa
          - comment: other custom (leading anything not covered above)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.infix.sa

      binary-ops:
        match: (?<=^|['"\`\\\s\p{ps}])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
        captures:
          0: {patterns: [{include: "#binary-ops-builtin"}]}

      unary-ops:
        patterns:
          - &transfix-operators
            comment: transfix binary operators
            match: |
              (?x)(?<=\b|^|[\p{pe}'"\`\\\s])
              (?:([>.]\.[.<])|(\?\.=?)|(~\.=?)|(!\.=?)|((?:::|\.)=?)|(->))
              (?=\b|$|[\p{ps}'"\`\\\s])
            captures:
              1: {name: keyword.operator.range.sa}
              2: {name: punctuation.accessor.optional.sa}
              3: {name: punctuation.accessor.cascade.sa}
              4: {name: punctuation.accessor.call.sa}
              5: {name: punctuation.accessor.sa}
              6: {name: punctuation.accessor.module.sa}

          - &prefix-operators
            comment: prefix operators
            match: |
              (?x)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])#14
              (?=[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*
              [\p{l}\p{m}\p{n}\p{ps}_,;'"\`])
            name: keyword.operator.prefix.sa
            captures:
              1: {name: keyword.operator.module.all.sa}
              2: {name: keyword.operator.increment.sa}
              3: {name: keyword.operator.decrement.sa}
              4: {name: keyword.operator.intersection.sa}
              5: {name: keyword.operator.union.sa}
              6: {name: keyword.operator.sym-diff.sa}
              7: {name: keyword.operator.logical.sa}
              8: {name: keyword.operator.private.sa}
              9: {name: keyword.operator.decorator.sa}
              10: {name: keyword.operator.bitwise.not.sa}
              11: {name: keyword.operator.existential.sa}
              12: {name: keyword.operator.assignment.sa}
              13: {name: keyword.operator.pipeline.sa}
              14: {name: keyword.operator.prefix.sa}

          - &suffix-operators
            comment: suffix operators
            match: |
              (?x)
              (?<=[\p{l}\p{m}\p{n}\p{pe}_,;'"\`]
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])#14
            name: keyword.operator.suffix.sa
            captures:
              1: {name: keyword.operator.module.all.sa}
              2: {name: keyword.operator.increment.sa}
              3: {name: keyword.operator.decrement.sa}
              4: {name: keyword.operator.intersection.sa}
              5: {name: keyword.operator.union.sa}
              6: {name: keyword.operator.sym-diff.sa}
              7: {name: punctuation.accessor.call.sa}
              8: {name: keyword.operator.private.sa}
              9: {name: keyword.operator.decorator.sa}
              10: {name: keyword.operator.bitwise.sa}
              11: {name: punctuation.accessor.optional.sa}
              12: {name: keyword.operator.assignment.sa}
              13: {name: keyword.operator.pipeline.sa}
              14: {name: keyword.operator.suffix.sa}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# prefix

              (?!
              \b(?:# don't match keywords
              in|of|as|is|new|infer|unset
              |typeof|nameof|sizeof|keyof|valof
              |len|del|to|til|thru|at|by
              |and|x?or|not|para|seq|spawn
              |def|func?|fn|macro|proc|sub
              |let|var|val|const|decl
              |class|given|law|enum|rel|lat
              |proj|prot|ext|impl|frag|inter|struct
              |module|nspace|object|record|label
              |raw|data|query|schema|style|trait|alias|type
              |if|else|elif|eless|unless|guard
              |for|each|while|until|repeat|do|redo
              |switch|case|fail|default|match|when|pass|fallthru
              |try|retry|throw|raise|catch|rescue|finally
              |with|ref|defer|refer|show|hide|enter|exit
              |then|begin|end|debug|check|assert
              |break|continue|halt|skip|fixed|lock
              |(?:return|give|await|yield|throw|raise)s?
              |yield\b\s*\bfrom|import|export|show|hide
              |from|where|join|equals|[io]nto|order
              |take|drop|fold|scan|select|use|using
              |fi|rof|done|esac|wend|yrt|disc|wout
              |open|close
              )\b
              )

              [_\p{l}\p{m}\p{n}]+
              (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# transfix
              [_\p{l}\p{m}\p{n}]+)*
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# suffix
              )\s*([^(]|$|;))
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.compose.sa}
              2: {name: keyword.operator.pipeline.sa}
            patterns:
              - match: |
                  (?x)\s*\b

                  (?!
                  \s*\b
                  (?:# don't match keywords
                  new|unset|len|del|to|til|thru|at|by
                  |and|x?or|not|para|seq|spawn
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|law|enum|rel|lat
                  |proj|prot|ext|impl|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|query|schema|style|trait|alias|type
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|repeat|do|redo
                  |switch|case|fail|default|match|when|pass|fallthru
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|fixed|lock
                  |(?:return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|select|use|using
                  |fi|rof|done|esac|wend|yrt|disc|wout
                  |open|close
                  )\b
                  )

                  (?:
                  (?:# Objects and maps
                  (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
                  ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
                  ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  )
                  (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

                  |
                  (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
                  (?:# Properties (note all properties are by default, symbols)
                  (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
                  ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
                  ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  )

                  |
                  (?:# Regular variables
                  (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
                  ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
                  ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  )
                  )\b
                captures:
                  1: {name: variable.other.global.sa}
                  2: {name: variable.other.constant.object.sa}
                  3: {name: variable.other.conditional.sa}
                  4: {name: variable.other.object.sa}
                  5: {name: entity.name.tag.sa}
                  6: {name: entity.name.tag.sa support.class.component.sa}
                  7: {name: entity.name.class.builtin.sa}
                  8: {name: entity.name.function.method.sa}
                  9: {name: entity.name.function.tagged-template.sa}
                  10: {name: entity.name.type.sa}
                  11: {name: entity.name.class.sa}
                  12: {name: entity.name.function.sa}
              - *transfix-operators

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.sa}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.sa}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.sa}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.sa
              - include: $self

  constant-types:
    - include: "#literals"

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \s*\b
      (?:# don't match keywords
      new|unset|len|del|to|til|thru|at|by
      |and|x?or|not|para|seq|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|disc|wout
      |open|close
      )\b
      )

      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.tag.block.sa}
      2: {name: entity.name.tag.script.sa}
      3: {name: entity.name.tag.style.sa}
      4: {name: entity.name.tag.inline.sa}
      5: {name: entity.name.module.sa}
      6: {name: entity.name.tag.sa}
      7: {name: entity.name.namespace.sa}
      8: {name: entity.name.interface.sa}
      9: {name: entity.name.label.sa}
      10: {name: entity.name.project.sa}
      11: {name: entity.name.class.sa}
      12: {name: entity.name.type.sa}

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.sa
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.sa
              - match: (?<=^|\p{ps})\s*([*+-](?:\s+[*+-])*)
                name: punctuation.definition.block.sequence.item.saga

        patterns:
          - begin: \s*(\{\|)
            end: \s*(\|\})
            captures:
              1: {name: punctuation.definition.mapping.sa}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\{)
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.sa}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.sa
        patterns:
          - begin: \s*(\(\|)
            end: \s*(\|\))
            captures:
              1: {name: punctuation.definition.parameters.sa}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.sa}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<=\b|^|[\p{pe}'"\`\\\s])(:)(?=\b|$|[\p{ps}'"\`\\\s])
                captures:
                  1: {name: punctuation.separator.slice.sa}
              - match: ","
                name: punctuation.separator.sequence.sa
        patterns:
          - begin: \s*(\[<)
            end: \s*(>\])
            captures:
              1: {name: punctuation.definition.typeparameters.sa}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[\|)
            end: \s*(\|\])
            captures:
              1: {name: punctuation.definition.sequence.sa}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.sa}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: |
          (?x)\s*\b
          (ext)\b\s*
        name: storage.type.extends.sa
      - match: |
          (?x)\s*\b
          (impl)\b\s*
        name: storage.type.implements.sa
      - match: |
          (?x)\s*\b
          ((?:type|name|size|key)of|only|infer|in|of|as|is)\b\s*
        name: keyword.operator.expression.$1.sa
      - match: |
          (?x)\s*\b
          (valof)\b\s*
        name: keyword.operator.expression.valueof.sa

  type-operators:
    patterns:
      - comment: transfix binary operators
        match: |
          (?x)(?<=^|[\p{pe}_\p{l}\p{m}\p{n}'"\`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[\p{ps}_\p{l}\p{m}\p{n}'"\`])
        captures:
          1: {name: punctuation.accessor.optional.sa}
          2: {name: punctuation.accessor.cascade.sa}
          3: {name: punctuation.accessor.call.sa}
          4: {name: punctuation.accessor.sa}
          5: {name: punctuation.accessor.module.sa}

      - comment: sum type +
        match: \s*(\+)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.sum.sa
      - comment: difference type -
        match: \s*(\-)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.difference.sa
      - comment: product type *
        match: \s*(\*)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.product.sa
      - comment: quotient type /
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.quotient.sa
      - comment: remainder type %
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.remainder.sa
      - comment: result/return type !
        match: \s*(\!)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.only.sa
      - comment: some or maybe type ?
        match: \s*(\?)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.maybe.sa
      - comment: intersection type &
        match: \s*(\&)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.intersection.sa
      - comment: union type |
        match: \s*(\|)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.union.sa
      - comment: symmetric difference type ^
        match: \s*(\^)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.sym-diff.sa
      - comment: complement type ~
        match: \s*(\~)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.negation.sa
      - comment: class type < >
        match: \s*([<>])(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.class.sa

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=\O)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.sa}
    patterns:
      - include: "#types"

  types:
    patterns:
      - include: "#type-keywords"
      - include: "#modifier-keywords"
      - include: "#constant-types"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-operators"
      - include: "#type-brackets"

      - match: \s*(=+>|-+>)\s*
        name: storage.type.function.arrow.sa

      - match: (?!^)\s*\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|strings|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|numbers|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
        captures:
          1: {name: support.type.builtin.class.sa}
      - match: \s*\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        captures:
          2: {name: support.type.builtin.class.sa}
          4: {name: keyword.operator.accessor.sa}
          5: {name: support.type.builtin.class.sa}
      - match: \s*\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        captures:
          2: {name: support.type.builtin.class.sa}
          4: {name: keyword.operator.accessor.sa}
          5: {name: support.type.builtin.class.sa}

  modifier-keywords:
    match: |
      (?x)
      ((?:
      \s*(?:
      (?:# Access modifiers
      pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
      |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
      # Function or method modifiers
      |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
      |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
      |# Function or method modifiers
      (?:pre|in|post|suf|af|trans|inter)fix|
      (?:u|bi|ter|)nary|oper
      |# Decorators
      @(?:
      [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
      (?:(?:[?!~]?\.|[?!:]:|->)
      (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
      )
      )
      )
      \s*)*)
      (?=\s*\b
      (?:
      def|func?|fn|macro|proc|sub
      |let|va[rl]|const
      |class|ext
      |given|law
      |enum|rel|lat
      |proj
      |frag|struct
      |inter|schema
      |module|lat
      |nspace
      |object|record
      |raw
      |data|query
      |style
      |trait|impl
      |type|alias
      |decl
      |do|redo
      )\b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - match: |
              (?x)\s*@(?:
              [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
              )\s*
            name: entity.name.class.decorator.sa
          - match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
              )|
              (# Function or method modifiers
              [gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              )|
              (# Property modifiers
              (?:pre|in|post|suf|af|trans|inter)fix|
              (?:u|bi|ter|)nary|oper
              )
              )\b\s*
            captures:
              1: {name: storage.modifier.sa}
              2: {name: storage.type.accessor.sa}
              3: {name: storage.type.property.sa}

  support:
    patterns:
      - include: "#support-constants"
      - include: "#type-names"
      - include: "#support-functions"

  clause-keywords:
    comment: clause keywords
    match: |
      (?x)\s*\b(?:
      (def|func?|fn|macro|proc|sub)# function
      |(let|va[rl]|const)# variable
      |(class|ext)# class
      |(given|law)# constraint
      |(enum|rel|lat)# enumeration
      |(proj)# project
      |(frag|struct)# fragment
      |(inter|schema)# interface
      |(module|lat)# module
      |(nspace)# function
      |(object|record)# object
      |(raw)# markup
      |(data|query)# indented GraphQL
      |(style)# inline CSS
      |(trait|impl)# trait
      |(type|alias)# type alias
      |(decl)# declaration
      )\b\s*
    captures:
      1: {name: storage.type.function.sa}
      2: {name: storage.type.sa}
      3: {name: storage.type.class.sa}
      4: {name: storage.type.constraint.sa}
      5: {name: storage.type.enum.sa}
      6: {name: storage.type.project.sa}
      7: {name: storage.type.fragment.sa}
      8: {name: storage.type.interface.sa}
      9: {name: storage.type.module.sa}
      10: {name: storage.type.namespace.sa}
      11: {name: storage.type.object.sa}
      12: {name: storage.type.raw.sa}
      13: {name: storage.type.schema.sa}
      14: {name: storage.type.style.sa}
      15: {name: storage.type.trait.sa}
      16: {name: keyword.other.typedef.sa}
      17: {name: keyword.other.declare.sa}

  general-keywords:
    comment: general keywords
    match: |
      (?x)\s*\b(?:
      (if|else|elif|eless|unless|guard|fi)#1
      |(for|each|while|until|repeat|rof)#2
      |(switch|case|fail|default|fallthru|esac)#3
      |(match|when|pass|wend)#4
      |(try|retry|throw|raise|catch|rescue|finally|yrt)#5
      |(with|wout)#6
      |(ref|refer|show|hide|enter|exit)#7
      |(then)#8
      |(debug|check|assert)#9
      |(break|continue|halt|skip|return|give|label|await|yield|throw|raise|yield\b\s+\bfrom)# 10
      |((?:im|ex)port|show|hide)# 11
      |(para|seq|spawn|disc)#12
      |(do|redo|done)#13
      |(begin|end)#14
      )\b\s*
    captures:
      1: {name: keyword.control.conditional.sa}
      2: {name: keyword.control.loop.sa}
      3: {name: keyword.control.switch.sa}
      4: {name: keyword.control.match.sa}
      5: {name: keyword.control.error.sa}
      6: {name: keyword.control.with.sa}
      7: {name: keyword.control.sa}
      8: {name: keyword.control.then.sa}
      9: {name: keyword.other.$10.sa}
      10: {name: keyword.control.flow.sa}
      11: {name: keyword.control.module.sa}
      12: {name: keyword.control.thread.sa}
      13: {name: keyword.control.do.sa}
      14: {name: keyword.control.$14.sa}

  expression-keywords:
    comment: expression keywords
    match: |
      (?x)\s*\b(?:
      (in)|(of)|(as)|(is)|(new)|(infer)
      |(typeof|nameof|sizeof|keyof)
      |(valof)|(len)|(del)|(to|til|thru|at|by)|(unset)
      |(and|x?or|not)
      )\b\s*
    captures:
      1: {name: keyword.operator.expression.in.sa}
      2: {name: keyword.operator.expression.of.sa}
      3: {name: keyword.operator.expression.as.sa}
      4: {name: keyword.operator.expression.is.sa}
      5: {name: keyword.operator.expression.new.sa}
      6: {name: keyword.operator.expression.infer.sa}
      7: {name: keyword.operator.expression.$7.sa}
      8: {name: keyword.operator.expression.valueof.sa}
      9: {name: keyword.operator.expression.length.sa}
      10: {name: keyword.operator.expression.delete.sa}
      11: {name: keyword.operator.expression.range.sa}
      12: {name: keyword.operator.expression.void.sa}
      13: {name: keyword.operator.expression.logical.sa}

  keywords:
    patterns:
      - include: "#query-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#modifier-keywords"
      - include: "#clause-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: \s*\b(halt|skip|break|continue|goto|label)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.flow.sa}
        patterns:
          - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*
            captures:
              1: {name: constant.other.label.sa}

      module-expression:
        applyEndPatternLast: 1
        begin: \s*\b(import|export|open|close|use|using)\b\s*
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.module.sa}
        patterns:
          - include: "#modifier-keywords"
          - include: "#type-keywords"
          - match: \s*\b(from|to|as|all|any|show|hide|to|and|x?or|not)\b\s*
            name: keyword.control.module.sa
          - match: \s*\*
            name: keyword.operator.module.all.sa
          - include: "#module-string"
          - include: "#type-names"
          - include: "#custom-types"
          - include: "#types"
          - include: "#operators"
          - include: "#punctuation"
        repository:
          module-string:
            patterns:
              - comment: single quoted raw string
                begin: \s*('{3,})
                contentName: string.quoted.template.sa
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.sa}
                patterns:
                  - include: "#embedded-raw"
              - comment: simple single quoted raw string
                begin: \s*(')
                contentName: string.quoted.template.sa
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.sa}
                patterns:
                  - match: "''"
                    name: constant.character.escape.sa
                  - include: "#embedded-raw"
              - comment: double quoted standard string
                begin: \s*("{3,}|")
                contentName: string.quoted.module.sa
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.sa}
                patterns:
                  - include: "#string-escapes"

      query-expression:
        patterns:
          - begin: \s*\b(from)\b\s*
            end: \s*\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.sa}
            patterns:
              - include: $self
          - match: \s*\b((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.sa
          - begin: \s*\b(group)\b\s*
            end: \s*\b(by)\b\s*
            captures:
              1: {name: keyword.query.sa}
            patterns:
              - include: $self
          - begin: \s*\b(join)\b\s*
            end: \s*\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.sa}
            patterns:
              - include: $self
          - match: \s*\b(equals?|[io]nto)\b\s*
            name: keyword.query.sa
          - match: \s*\b((\b(order)\b)\s*(\b((a|de)sc)\b)?\s*(\b(by)\b)?)\b\s*
            name: keyword.query.sa
          - match: \s*\b(select)\b\s*
            name: keyword.query.sa
          - match: \s*\b((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.sa
          - match: \s*\b(where)\b\s*
            name: keyword.query.sa

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.sa}
    patterns: &function-params
      - include: "#clauses"
      - include: "#keywords"
      - match: (?i)\s*\?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.optional.sa
      - match: (?i)\s*\*[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.spread.sa
      - match: (?i)\s*\&[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.name.sa
      - match: (?i)\s*\%[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.reference.sa
      - match: (?i)\s*\$[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.other.sa
      - match: (?i)\s*\b[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b\s*
        name: variable.parameter.sa
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#type-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#curly-brackets"
      - include: "#type-annotation"
      - include: "#type-operators"
      - *transfix-operators
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]))
        end: (?=\O)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.sa}
        patterns:
          - include: "#types"

  declarations:
    patterns:
      - include: "#function"
      - include: "#raw"
      - include: "#schema"
      - include: "#style"
      - include: "#class"
      - include: "#enum"
      - include: "#interface"
      - include: "#trait"
      - include: "#fragment"
      - include: "#module"
      - include: "#namespace"
      - include: "#object"
      - include: "#constraint"
      - include: "#project"

    repository:
      class:
        applyEndPatternLast: 1
        begin: \s*\b(class|ext)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.class.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.class.sa}
          - include: "#block-entities"
      constraint:
        applyEndPatternLast: 1
        begin: \s*\b(given|law)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.constraint.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.constraint.sa}
          - include: "#block-entities"
      enum:
        applyEndPatternLast: 1
        begin: \s*\b(enum|rel)\b\s*
        end: $|(?=.)
        name: meta.enum.declaration.sa
        beginCaptures:
          1: {name: storage.type.enum.sa}
          2: {name: entity.name.enum.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.enum.sa}
          - include: "#block-entities"
      project:
        applyEndPatternLast: 1
        begin: \s*\b(proj|impl)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.project.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.project.sa}
          - include: "#block-entities"
      fragment:
        applyEndPatternLast: 1
        begin: \s*\b(frag|struct)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.fragment.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.fragment.sa}
          - include: "#block-entities"
      function:
        applyEndPatternLast: 1
        begin: \s*\b(def|func?|fn|macro|proc|sub)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.function.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.function.sa}
          - include: "#block-entities"
      interface:
        applyEndPatternLast: 1
        begin: \s*\b(inter|schema)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.interface.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.interface.sa}
          - include: "#block-entities"
      module:
        applyEndPatternLast: 1
        begin: \s*\b(module|lat)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.module.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.module.sa}
          - include: "#block-entities"
      namespace:
        applyEndPatternLast: 1
        begin: \s*\b(nspace)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.namespace.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.namespace.sa}
          - include: "#block-entities"
      object:
        applyEndPatternLast: 1
        begin: \s*\b(object|record)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.object.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.object.sa}
          - include: "#block-entities"
      raw:
        applyEndPatternLast: 1
        begin: \s*\b(raw)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.raw.sa}
        patterns:
          - match: *entity-name
            name: entity.name.raw.sa
          - include: "#block-entities"
      schema:
        applyEndPatternLast: 1
        begin: \s*\b(data|query)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.schema.sa}
        patterns:
          - match: *entity-name
            name: entity.name.schema.sa
          - include: "#block-entities"
      style:
        applyEndPatternLast: 1
        begin: \s*\b(style)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.style.sa}
        patterns:
          - match: *entity-name
            name: entity.name.style.sa
          - include: "#block-entities"
      trait:
        applyEndPatternLast: 1
        begin: \s*\b(trait|impl)\b\s*
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.trait.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.trait.sa}
          - include: "#block-entities"

  clauses:
    patterns:
      - include: "#variable-clause"
      - include: "#constant-clause"
      - include: "#arguments-clause"
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      arguments-clause:
        patterns:
          - begin: (?<=(?:[\p{ps}]\|?|\bdo\b)\s*)(\|)(?=[\w\s])
            captures:
              1: {name: punctuation.separator.arguments.sa}
            end: (?<!\|)(\|)(?!\|)
            patterns:
              - include: "#function-params"

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.sa}
        patterns:
          - include: "#function-params"

      method-clause:
        patterns:
          - begin: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (

              (?:(?:# Access modifiers
              pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
              # Function or method modifiers
              |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|inter)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
              )
              )\s*\b)*

              )\s*
              (\|)
              (?=[\w\s])
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.method.sa}
              2: {name: keyword.operator.assignment.sa}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.sa}
            endCaptures:
              1: {name: punctuation.separator.arguments.sa}
            patterns:
              - include: "#function-params"
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+

              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+

              ((?:
              \s*(?:
              (?:# Access modifiers
              pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
              # Function or method modifiers
              |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|inter)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              def|func?|fn|macro|proc|sub
              )\b
              )
            captures:
              1: {name: entity.name.function.method.sa}
              2: {name: keyword.operator.assignment.sa}
              3: {patterns: *modifier-keywords}

      function-clause:
        patterns:
          - begin: |
              (?x)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (

              (?:(?:# Access modifiers
              pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
              # Function or method modifiers
              |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|inter)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
              )
              )\s*\b)*

              )\s*
              (\|)
              (?=[\w\s])
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.sa}
              2: {name: keyword.operator.assignment.sa}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.sa}
            endCaptures:
              1: {name: punctuation.separator.arguments.sa}
            patterns:
              - include: "#function-params"
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+

              ((?:
              \s*(?:
              (?:# Access modifiers
              pub|prot|priv|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|final
              # Function or method modifiers
              |[gs]et|ref|rec|gen|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|inter)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              def|func?|fn|macro|proc|sub
              )\b
              )
            captures:
              1: {name: entity.name.function.sa}
              2: {name: keyword.operator.assignment.sa}
              3: {patterns: *modifier-keywords}

      variable-clause:
        applyEndPatternLast: 1
        begin: \s*\b(var|let)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: storage.type.sa}
        patterns:
          - include: $self

      constant-clause:
        applyEndPatternLast: 1
        begin: \s*\b(val|const)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: storage.type.sa}
        patterns:
          - match: *entity-name
            captures:
              1: {name: variable.other.constant.sa}
          - include: "#block-entities"

      new-clause:
        applyEndPatternLast: 1
        begin: \s*\b(new)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.sa}
        patterns:
          - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            name: entity.name.instance.sa
          - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: \s*\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.sa}
            patterns:
              - include: "#types"
          - begin: \s*\b(type|alias)\b\s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\b\s*(?:(:?=)|(:))?\s*
            end: ^(?=\S)|(?!\G)
            name: meta.type-alias.sa
            beginCaptures:
              1: {name: keyword.other.typedef.sa}
              2: {patterns: [{include: "#types"}]}
              3: {name: keyword.operator.assignment.sa}
              4: {name: punctuation.separator.colon.sa}
            patterns:
              - begin: ^((\p{zs})+)(?!\2)
                end: ^(?!\1|\s*$)
                name: meta.type-alias.sa
                patterns:
                  - include: "#types"
              - include: $self
          - applyEndPatternLast: 1
            begin: \s*\b(type|alias)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.typedef.sa}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.sa}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: \s*\b(decl)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.declare.sa}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.sa}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*\b(
              (?:return|give|await|yield|throw|raise)s
              )\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.modifier.sa}
            patterns:
              - include: "#types"

      case-clause:
        begin: \s*\b(case|fail|default)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        beginCaptures:
          1: {name: keyword.control.switch.sa}
        patterns:
          - include: "#clause-content"

      catch-clause:
        begin: \s*\b(try|retry|catch|rescue|finally)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.catch.sa
        beginCaptures:
          1: {name: keyword.control.error.sa}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.sa}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.error.sa
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.error.sa
          - include: "#clause-content"

      thread-clause:
        begin: \s*\b(para|seq|spawn|fixed|lock)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.thread.sa
        beginCaptures:
          1: {name: keyword.control.thread.sa}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.sa}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.thread.sa
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.thread.sa
          - include: "#clause-content"

      do-clause:
        begin: \s*\b(do|redo)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.do.sa
        beginCaptures:
          1: {name: keyword.control.do.sa}
        patterns:
          - include: "#clause-content"

      for-clause:
        begin: \s*\b(for|each|while|until|repeat)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.for.sa
        beginCaptures:
          1: {name: keyword.control.loop.sa}
        patterns:
          - match: \s*\b(in|of|to|til|thru|at|by)\b
            name: keyword.control.loop.sa
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.sa}
            patterns:
              - match: \s*\b(in|of|to|til|thru|at|by)\b
                name: keyword.control.loop.sa
              - include: $self
          - include: "#clause-content"

      if-clause:
        begin: \s*\b(if|elif|else|unless|eless|guard)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.if.sa
        beginCaptures:
          1: {name: keyword.control.conditional.sa}
        patterns:
          - include: "#clause-content"

      match-clause:
        begin: \s*\b(match)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.match.sa
        beginCaptures:
          1: {name: keyword.control.match.sa}
        patterns:
          - include: "#clause-content"

      switch-clause:
        begin: \s*\b(switch)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.switch.sa
        beginCaptures:
          1: {name: keyword.control.switch.sa}
        patterns:
          - include: "#clause-content"

      when-clause:
        begin: \s*\b(when)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        beginCaptures:
          1: {name: keyword.control.match.sa}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.sa}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*\b((?:return|give|await|yield|throw|raise)s?)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.sa}
            patterns:
              - include: "#types"
          - begin: \s*\b(if|elif|else|unless|eless|guard)\b
            end: (?=[\p{pe};]|:(?=\s+|$)|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.sa}
            beginCaptures:
              1: {name: keyword.control.match.sa}
            patterns:
              - include: $self
          - include: "#type-operators"
          - include: "#clause-content"

      with-clause:
        begin: \s*\b(with)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.sa}
        name: meta.with.sa
        beginCaptures:
          1: {name: keyword.control.with.sa}
        patterns:
          - begin: \s*
            end: \s*(?=[{,])
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.with.sa
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.sa}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.with.sa
              - include: $self
          - include: "#clause-content"

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#semicolon"
      - include: "#double-semi"

    repository:
      line-continuation:
        match: (\\)\s*(?=#|$)
        captures:
          1: {name: punctuation.separator.continuation.line.sa}
      comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.separator.comma.sa}
      right-arrow:
        match: (?:^|['"\`\\\p{ps}\s]*)(->)(?:$|['"\`\\\s\p{pe}])
        captures:
          1: {name: punctuation.definition.arrow.sa}
      double-semi:
        match: \s*(;;)
        captures:
          1: {name: punctuation.terminator.statement.sa}
      semicolon:
        match: \s*(;)(?!;)
        captures:
          1: {name: punctuation.terminator.expression.sa}

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.sa
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.sa
          - match: (?<=^|\p{ps})\s*([*+-](?:\s+[*+-])*)
            name: punctuation.definition.block.sequence.item.saga

    patterns:
      - begin: (\{\|)\s*
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.mapping.sa}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.sa}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.sa

    patterns:
      - begin: (\(\|)\s*
        end: \s*(\|\))
        captures:
          1: {name: punctuation.definition.parameters.sa}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.sa}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<=\b|^|[\p{pe}'"\`\\\s])(:)(?=\b|$|[\p{ps}'"\`\\\s])
            captures:
              1: {name: punctuation.separator.slice.sa}
          - match: ","
            name: punctuation.separator.sequence.sa

    patterns:
      - begin: (\[<)\s*
        end: \s*(>\])
        captures:
          1: {name: punctuation.definition.typeparameters.sa}
        patterns:
          - include: "#types"
          - include: $self
      - begin: (\[\|)\s*
        end: \s*(\|\])
        captures:
          1: {name: punctuation.definition.sequence.sa}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.sa}
        patterns:
          - include: "#punctuation"
          - include: $self

  embedded-langs:
    patterns:
      - include: "#raw-haml"
      - include: "#raw-stylus"
      - include: "#raw-yaml"
      - include: "#raw-python"
      - include: "#raw-ruby"
      - include: "#raw-pug"
      - include: "#raw-markdown"
      - include: "#raw-css"
      - include: "#raw-scss"
      - include: "#raw-less"
      - include: "#raw-html"
      - include: "#raw-javascript"
      - include: "#raw-typescript"

    repository:
      raw-yaml:
        begin: \s*\b(raw)\b\s*\b((?i:yaml))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.yaml.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.yaml.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.yaml
          - include: $self
      raw-python:
        begin: \s*\b(raw)\b\s*\b((?i:py|python))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.python.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.python.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.python
          - include: $self
      raw-ruby:
        begin: \s*\b(raw)\b\s*\b((?i:rb|ruby))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.ruby.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.ruby.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.ruby
          - include: $self
      raw-css:
        begin: \s*\b(raw)\b\s*\b((?i:css))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.css.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.css.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.css
          - include: $self
      raw-javascript:
        begin: \s*\b(raw)\b\s*\b((?i:js|javascript))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.js.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.js.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.js
          - include: $self
      raw-typescript:
        begin: \s*\b(raw)\b\s*\b((?i:ts|typescript))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.ts.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.ts.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.ts
          - include: $self
      raw-html:
        begin: \s*\b(raw)\b\s*\b((?i:html))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.html.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.html.sa
            patterns:
              - include: "#embedded-raw"
              - include: text.html
          - include: $self
      raw-scss:
        begin: \s*\b(raw)\b\s*\b((?i:s[ca]ss))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.scss.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.scss.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.css.scss
          - include: $self
      raw-less:
        begin: \s*\b(raw)\b\s*\b((?i:less))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.less.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.less.sa
            patterns:
              - include: "#embedded-raw"
              - include: source.less
          - include: $self
      raw-pug:
        begin: \s*\b(raw)\b\s*\b((?i:pug))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.pug.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.pug.sa
            patterns:
              - include: "#embedded-raw"
              - include: text.pug
          - include: $self
      raw-markdown:
        begin: \s*\b(raw)\b\s*\b((?i:md|mdown|markdown))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.markdown.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.markdown.sa
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown
          - include: $self
      raw-haml:
        begin: \s*\b(raw)\b\s*\b((?i:haml))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.haml.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.haml.sa
            patterns:
              - include: "#embedded-raw"
              - include: "#embedded-haml"
          - include: $self
      raw-stylus:
        begin: \s*\b(raw)\b\s*\b((?i:styl|stylus))\b\s*(?:(:?=)|(:))?\s*
        end: ^(?=\S)|(?!\G)
        name: meta.embedded.haml.sa
        beginCaptures:
          1: {name: storage.type.raw.sa}
          2: {name: entity.name.raw.sa}
          3: {name: keyword.operator.assignment.sa}
          4: {name: punctuation.separator.colon.sa}
        patterns:
          - begin: ^((\p{zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: meta.embedded.stylus.sa
            patterns:
              - include: "#embedded-raw"
              - include: "#embedded-stylus"
          - include: $self

  embedded-haml:
    patterns:
      - begin: ^(\s*)==
        contentName: string.quoted.double.ruby
        end: $\n*
        patterns:
          - include: "#interpolated_ruby"
      - begin: ^(\s*):ruby
        end: ^(?!\1\s+|$\n*)
        name: source.ruby.embedded.filter.haml
        patterns:
          - include: source.ruby
      - match: ^(!!!)($|\s.*)
        name: meta.prolog.haml
        captures:
          1: {name: punctuation.definition.prolog.haml}
      - begin: ^(\s*):javascript
        end: ^(?!\1\s+|$\n*)
        name: js.haml
        patterns:
          - include: source.js
      - begin: ^(\s*):ruby$
        end: ^(?!\1\s+|$\n*)
        name: source.ruby.embedded.filter.haml
        patterns:
          - include: source.ruby
      - match: ^(\s*)(\/\[[^\]].*?$\n?)
        name: comment.line.slash.haml
        captures:
          1: {name: punctuation.section.comment.haml}
      - begin: ^(\s*)(\-\#|\/|\-\s*\\#[\[{]+)
        end: ^(?!\1\s+|\n)
        name: comment.block.haml
        beginCaptures:
          2: {name: punctuation.section.comment.haml}
        patterns:
          - include: text.haml
      - begin: ^\s*(?:((%)([-\w:]+))|(?=\.|#))
        end: $|(?!\.|#|\{|\(|\[|&amp;|=|-|~|!=|&=|/)
        captures:
          1: {name: meta.tag.haml}
          2: {name: punctuation.definition.tag.haml}
          3: {name: entity.name.tag.haml}
        patterns:
          - begin: "=="
            contentName: string.quoted.double.ruby
            end: $\n?
            patterns:
              - include: "#interpolated_ruby"
          - match: (\.[\w\-\:]+)
            name: meta.selector.css
            captures:
              1: {name: entity.other.attribute-name.class}
          - match: (#[\w-]+)
            name: meta.selector.css
            captures:
              1: {name: entity.other.attribute-name.id}
          - begin: (?<!\#)\{(?=.+(,|(do)|\{|\}|\||(\#.*))\s*)
            end: \s*\}(?!\s*\,)(?!\s*\|)(?!\#\{.*\})
            name: meta.section.attributes.haml
            patterns:
              - include: source.ruby
              - include: "#continuation"
              - include: "#rubyline"
          - begin: \(
            end: \)
            name: meta.section.attributes.plain.haml
            patterns:
              - match: ([\w-]+)
                name: constant.other.symbol.ruby
              - match: \=
                name: punctuation
              - include: "#variables"
              - begin: '"'
                end: '"'
                name: string.quoted.double.ruby
                patterns:
                  - match: \\(x\h{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)
                    name: constant.character.escape.ruby
                  - include: "#interpolated_ruby"
              - include: "#interpolated_ruby"
          - begin: \[(?=.+(,|\[|\]|\||(\#.*))\s*)
            end: \s*\](?!.*(?!\#\[)\])
            name: meta.section.object.haml
            patterns:
              - include: source.ruby
              - include: "#continuation"
              - include: "#rubyline"
          - include: "#interpolated_ruby_line"
          - include: "#rubyline"
          - match: /
            name: punctuation.terminator.tag.haml
      - begin: ^(\s*):(ruby|opal)$
        end: ^(?!\1\s+|$\n*)
        name: source.ruby.embedded.filter.haml
        patterns:
          - include: source.ruby
      - begin: ^(\s*):ruby$
        end: ^(?!\1\s+|$\n*)
        name: source.ruby.embedded.filter.haml
        patterns:
          - include: source.ruby
      - begin: ^(\s*):(style|sass)$
        end: ^(?=\1\s+|$\n*)
        name: source.sass.embedded.filter.haml
        patterns:
          - include: source.sass
      - begin: ^(\s*):coffee(script)?
        end: ^(?!\1\s+|$\n*)
        name: source.coffee.embedded.filter.haml
        patterns:
          - include: source.coffee
      - begin: ^(\s*):plain$
        end: ^(?=\1\s+|$\n*)
        name: text.plain.embedded.filter.haml
        patterns:
          - include: text.plain
      - begin: ^(\s*)(:ruby)
        end: (?m:(?<=\n)(?!\1\s+|$\n*))
        name: source.ruby.embedded.filter.haml
        beginCaptures:
          2: {name: keyword.control.filter.haml}
        patterns:
          - include: source.ruby
      - begin: ^(\s*)(:sass)
        end: ^(?!\1\s+|$\n*)
        name: source.embedded.filter.sass
        beginCaptures:
          2: {name: keyword.control.filter.haml}
        patterns:
          - include: source.sass
      - begin: ^(\s*):(styles|sass)$
        end: ^(?=\1\s+|$\n*)
        name: source.sass.embedded.filter.haml
        patterns:
          - include: source.sass
      - begin: ^(\s*):plain$
        end: ^(?=\1\s+|$\n*)
        name: text.plain.embedded.filter.haml
        patterns:
          - include: text.plain
      - match: ^\s*(\.)
        captures:
          1: {name: meta.escape.haml}
      - begin: ^\s*(?==|-|~|!=|&=)
        end: $
        patterns:
          - include: "#interpolated_ruby_line"
          - include: "#rubyline"
      - begin: ^(\s*)(:php)
        end: ^(?!\1\s+|$\n*)
        name: meta.embedded.php
        captures:
          2: {name: entity.name.tag.haml}
        patterns:
          - include: text.html.php#language
      - begin: ^(\s*)(:markdown)
        end: ^(?!\1\s+|$\n*)
        name: meta.embedded.markdown
        captures:
          2: {name: entity.name.tag.haml}
        patterns:
          - include: text.html.markdown
      - begin: ^(\s*)(:(css|styles?))$
        end: ^(?!\1\s+|$\n*)
        name: meta.embedded.css
        captures:
          2: {name: entity.name.tag.haml}
        patterns:
          - include: source.css
      - begin: ^(\s*)(:sass)$
        end: ^(?!\1\s+|$\n*)
        name: meta.embedded.sass
        captures:
          2: {name: entity.name.tag.haml}
        patterns:
          - include: source.sass
      - begin: ^(\s*)(:scss)$
        end: ^(?!\1\s+|$\n*)
        name: meta.embedded.scss
        captures:
          2: {name: entity.name.tag.haml}
        patterns:
          - include: source.scss
    repository:
      continuation:
        match: (\|)\s*\n
        captures:
          1: {name: punctuation.separator.continuation.haml}
      interpolated_ruby:
        patterns:
          - match: '#\{(\})'
            name: source.ruby.embedded.source
            captures:
              0: {name: punctuation.section.embedded.ruby}
              1: {name: source.ruby.embedded.source.empty}
          - begin: '#\{'
            end: (\})
            name: source.ruby.embedded.source
            captures:
              0: {name: punctuation.section.embedded.ruby}
            patterns:
              - include: "#nest_curly_and_self"
              - include: source.ruby
          - include: "#variables"
      interpolated_ruby_line:
        begin: "!?=="
        contentName: string.source.ruby.embedded.haml
        end: $
        name: meta.line.ruby.interpolated.haml
        patterns:
          - include: "#interpolated_ruby"
          - include: source.ruby#escaped_char
      nest_curly_and_self:
        patterns:
          - begin: \{
            end: \}
            captures:
              0: {name: punctuation.section.scope.ruby}
            patterns:
              - include: "#nest_curly_and_self"
              - include: source.ruby
      rubyline:
        begin: (&amp|!)?(=|-|~)
        contentName: source.ruby.embedded.haml
        end: ((do\{)( \|[.*]+\|)?)$|$|^(?!.*\|\s*)$\n?
        name: meta.line.ruby.haml
        endCaptures:
          1: {name: source.ruby.embedded.html}
          2: {name: keyword.control.ruby.start-block}
        patterns:
          - match: \s+((elseif|foreach|switch|declare|default|use))(?=\s|\()
            captures:
              1: {name: keyword.control.php}
          - match: \s+(require_once|include_once)(?=\s|\()
            captures:
              1: {name: keyword.control.import.include.php}
          - match: \s+(catch|try|retry|throw|exception|finally|die)(?=\s|\(|\n*)
            name: keyword.control.exception.php
          - match: \s+(function\s*)((?=\())
            captures:
              1: {name: storage.type.function.php}
          - match: \s+(use\s*)((?=\())
            captures:
              1: {name: keyword.control.php}
          - match: (\||,|<|do\{)\s*(\#.*)?$\n*
            name: source.ruby
            patterns:
              - include: "#rubyline"
          - match: "#.*$"
            name: comment.line.number-sign.ruby
          - include: source.ruby
          - include: "#continuation"
      variables:
        patterns:
          - match: (#@)[a-zA-Z_]\w*
            name: variable.other.readwrite.instance.ruby
            captures:
              1: {name: punctuation.definition.variable.ruby}
          - match: (#@@)[a-zA-Z_]\w*
            name: variable.other.readwrite.class.ruby
            captures:
              1: {name: punctuation.definition.variable.ruby}
          - match: (#\$)[a-zA-Z_]\w*
            name: variable.other.readwrite.global.ruby
            captures:
              1: {name: punctuation.definition.variable.ruby}

  embedded-stylus:
    patterns:
      - include: "#comment"
      - include: "#at_rule"
      - include: "#language_keywords"
      - include: "#language_constants"
      - include: "#variable_declaration"
      - include: "#function"
      - include: "#selector"
      - include: "#declaration"
      - match: (\{)(\})
        name: meta.brace.curly.css
        captures:
          1: {name: punctuation.section.property-list.begin.css}
          2: {name: punctuation.section.property-list.end.css}
      - match: \{|\}
        name: meta.brace.curly.css
      - include: "#numeric"
      - include: "#string"
      - include: "#operator"
    repository:
      at_rule:
        patterns:
          - begin: \s*(@)(import|require)\b\s*
            end: \s*((?=;|$|\n))
            name: meta.at-rule.import.css
            beginCaptures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.import.stylus}
            endCaptures:
              1: {name: punctuation.terminator.rule.css}
            patterns:
              - include: "#string"
          - begin: \s*(@)(extend[s]?)\b\s*
            end: \s*((?=;|$|\n))
            name: meta.at-rule.extend.css
            beginCaptures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.extend.stylus}
            endCaptures:
              1: {name: punctuation.terminator.rule.css}
            patterns:
              - include: "#selector"
          - match: ^\s*(@)(font-face)\b
            name: meta.at-rule.fontface.stylus
            captures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.fontface.stylus}
          - match: ^\s*(@)(css)\b
            name: meta.at-rule.css.stylus
            captures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.css.stylus}
          - begin: \s*(@)(charset)\b\s*
            end: \s*((?=;|$|\n))
            name: meta.at-rule.charset.stylus
            beginCaptures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.charset.stylus}
            patterns:
              - include: "#string"
          - begin: \s*(@)(keyframes)\b\s+([a-zA-Z_-][a-zA-Z0-9_-]*)
            end: \s*((?=\{|$|\n))
            name: meta.at-rule.keyframes.stylus
            beginCaptures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.keyframes.stylus}
              3: {name: entity.name.function.keyframe.stylus}
          - begin: (?=(\b(\d+%|from\b|to\b)))
            end: (?=(\{|\n))
            name: meta.at-rule.keyframes.stylus
            patterns:
              - match: (\b(\d+%|from\b|to\b))
                name: entity.other.attribute-name.stylus
          - match: ^\s*(@)(media)\b
            name: meta.at-rule.media.stylus
            captures:
              1: {name: punctuation.definition.keyword.stylus}
              2: {name: keyword.control.at-rule.media.stylus}
          - match: (?:(?=\w)(?<![\w-]))(width|scan|resolution|orientation|monochrome|min-width|min-resolution|min-monochrome|min-height|min-device-width|min-device-height|min-device-aspect-ratio|min-color-index|min-color|min-aspect-ratio|max-width|max-resolution|max-monochrome|max-height|max-device-width|max-device-height|max-device-aspect-ratio|max-color-index|max-color|max-aspect-ratio|height|grid|device-width|device-height|device-aspect-ratio|color-index|color|aspect-ratio)(?:(?<=\w)(?![\w-]))
            name: support.type.property-name.media-feature.media.css
          - match: (?:(?=\w)(?<![\w-]))(tv|tty|screen|projection|print|handheld|embossed|braille|aural|all)(?:(?<=\w)(?![\w-]))
            name: support.constant.media-type.media.css
          - match: (?:(?=\w)(?<![\w-]))(portrait|landscape)(?:(?<=\w)(?![\w-]))
            name: support.constant.property-value.media-property.media.css
      char_escape:
        match: \\(.)
        name: constant.character.escape.stylus
      color:
        patterns:
          - begin: \b(rgb|rgba|hsl|hsla)(\()
            end: (\))
            name: meta.function.color.css
            beginCaptures:
              1: {name: support.function.color.css}
              2: {name: punctuation.section.function.css}
            endCaptures:
              1: {name: punctuation.section.function.css}
            patterns:
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#numeric"
              - include: "#property_variable"
          - match: (#)([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b
            name: constant.other.color.rgb-value.css
            captures:
              1: {name: punctuation.definition.constant.css}
          - match: \b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
            name: support.constant.color.w3c-standard-color-name.css
          - match: \b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
            name: support.constant.color.w3c-extended-color-name.css
      comment_block:
        begin: /\*
        end: \*/
        name: comment.block.css
        beginCaptures:
          0: {name: punctuation.definition.comment.begin.css}
        endCaptures:
          0: {name: punctuation.definition.comment.end.css}
      comment_line:
        begin: (^[ \t]+)?(?=//)
        end: (?!\G)
        beginCaptures:
          1: {name: punctuation.whitespace.comment.leading.stylus}
        patterns:
          - begin: //
            end: (?=\n)
            name: comment.line.double-slash.stylus
            beginCaptures:
              0: {name: punctuation.definition.comment.stylus}
      declaration:
        begin: ((?<=^)[^\S\n]+)|((?<=;)[^\S\n]*)|((?<=\{)[^\S\n]*)
        end: (?=\n)|(;)|(?=\})|(\n)
        name: meta.property-list.css
        endCaptures:
          2: {name: punctuation.terminator.rule.css}
        patterns:
          - include: "#language_keywords"
          - include: "#language_constants"
          - match: (?:(?<=^)[^\S\n]+(\n))
          - match: \G\s*(counter-reset|counter-increment)(?:(:)|[^\S\n])[^\S\n]*([a-zA-Z_-][a-zA-Z0-9_-]*)
            name: meta.property.counter.css
            captures:
              1: {name: support.type.property-name.css}
              2: {name: punctuation.separator.key-value.css}
              3: {name: variable.section.css}
          - begin: \G\s*(filter)(?:(:)|[^\S\n])[^\S\n]*
            end: (?=\n|;|\}|$)
            name: meta.property.filter.css
            beginCaptures:
              1: {name: support.type.property-name.css}
              2: {name: punctuation.separator.key-value.css}
            patterns:
              - include: "#function"
              - include: "#property_values"
          - include: "#property"
          - include: "#interpolation"
          - include: $self
      font_name:
        match: (\b(?i:arial|century|comic|courier|cursive|fantasy|futura|garamond|georgia|helvetica|impact|lucida|monospace|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif)\b)
        name: support.constant.font-name.css
      function:
        begin: (?=[a-zA-Z_-][a-zA-Z0-9_-]*\()
        end: (\))
        endCaptures:
          1: {name: punctuation.section.function.css}
        patterns:
          - begin: (format|url|local)(\()
            end: (?=\))
            name: meta.function.misc.css
            beginCaptures:
              1: {name: support.function.misc.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: (?<=\()[^\)\s]*(?=\))
                name: string.css
              - include: "#string"
              - include: "#variable"
              - include: "#operator"
              - match: \s*
          - match: (counter)(\()([a-zA-Z_-][a-zA-Z0-9_-]*)(?=\))
            name: meta.function.misc.counter.css
            captures:
              1: {name: support.function.misc.counter.css}
              2: {name: punctuation.section.function.css}
              3: {name: variable.section.css}
          - begin: (counters)(\()
            end: (?=\))
            name: meta.function.misc.counters.css
            beginCaptures:
              1: {name: support.function.misc.counters.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \G[a-zA-Z_-][a-zA-Z0-9_-]*
                name: variable.section.css
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#string"
              - include: "#interpolation"
          - begin: (attr)(\()
            end: (?=\))
            name: meta.function.misc.attr.css
            beginCaptures:
              1: {name: support.function.misc.attr.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \G[a-zA-Z_-][a-zA-Z0-9_-]*
                name: entity.other.attribute-name.attribute.css
              - match: (?<=[a-zA-Z0-9_-])\s*\b(string|color|url|integer|number|length|em|ex|px|rem|vw|vh|vmin|vmax|mm|cm|in|pt|pc|angle|deg|grad|rad|time|s|ms|frequency|Hz|kHz|%)\b
                name: support.type.attr.css
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#string"
              - include: "#interpolation"
          - begin: (calc)(\()
            end: (?=\))
            name: meta.function.misc.calc.css
            beginCaptures:
              1: {name: support.function.misc.calc.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - include: "#property_values"
          - begin: (cubic-bezier)(\()
            end: (?=\))
            name: meta.function.timing.cubic-bezier.css
            beginCaptures:
              1: {name: support.function.timing.cubic-bezier.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#numeric"
              - include: "#interpolation"
          - begin: (steps)(\()
            end: (?=\))
            name: meta.function.timing.steps.css
            beginCaptures:
              1: {name: support.function.timing.steps.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#numeric"
              - match: \b(start|end)\b
                name: support.constant.timing.steps.direction.css
              - include: "#interpolation"
          - begin: (linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(\()
            end: (?=\))
            name: meta.function.gradient.css
            beginCaptures:
              1: {name: support.function.gradient.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#numeric"
              - include: "#color"
              - match: \b(to|bottom|right|left|top|circle|ellipse|center|closest-side|closest-corner|farthest-side|farthest-corner|at)\b
                name: support.constant.gradient.css
              - include: "#interpolation"
          - begin: (blur|brightness|contrast|grayscale|hue-rotate|invert|opacity|saturate|sepia)(\()
            end: (?=\))
            name: meta.function.filter.css
            beginCaptures:
              1: {name: support.function.filter.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - include: "#numeric"
              - include: "#property_variable"
              - include: "#interpolation"
          - begin: (drop-shadow)(\()
            end: (?=\))
            name: meta.function.filter.drop-shadow.css
            beginCaptures:
              1: {name: support.function.filter.drop-shadow.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - include: "#numeric"
              - include: "#color"
              - include: "#property_variable"
              - include: "#interpolation"
          - begin: (matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(\()
            end: (?=\))
            name: meta.function.transform.css
            beginCaptures:
              1: {name: support.function.transform.css}
              2: {name: punctuation.section.function.css}
            patterns:
              - include: "#numeric"
              - include: "#property_variable"
              - include: "#interpolation"
          - match: (url|local|format|counter|counters|attr|calc)(?=\()
            name: support.function.misc.css
          - match: (cubic-bezier|steps)(?=\()
            name: support.function.timing.css
          - match: (linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(?=\()
            name: support.function.gradient.css
          - match: (blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)(?=\()
            name: support.function.filter.css
          - match: (matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(?=\()
            name: support.function.transform.css
          - begin: ([a-zA-Z_-][a-zA-Z0-9_-]*)(\()
            end: (?=\))
            name: meta.function.stylus
            beginCaptures:
              1: {name: entity.name.function.stylus}
              2: {name: punctuation.section.function.css}
            patterns:
              - match: \s*(,)\s*
                name: punctuation.separator.parameter.css
              - include: "#interpolation"
              - include: "#property_values"
          - match: \(
            name: punctuation.section.function.css
      interpolation:
        begin: (?:(\{)[^\S\n]*)(?=[^;=]*[^\S\n]*\})
        end: (?:[^\S\n]*(\}))|\n|$
        name: meta.interpolation.stylus
        beginCaptures:
          1: {name: meta.brace.curly}
        endCaptures:
          1: {name: meta.brace.curly}
        patterns:
          - include: "#variable"
          - include: "#numeric"
          - include: "#string"
          - include: "#operator"
      language_constants:
        match: \b(true|false|null)\b
        name: constant.language.stylus
      language_keywords:
        patterns:
          - match: (\b|\s)(return|else|for|unless|if|else)\b
            name: keyword.control.stylus
          - match: (\b|\s)(!important|in|is defined|is a)\b
            name: keyword.other.stylus
          - match: \barguments\b
            name: variable.language.stylus
      numeric:
        patterns:
          - match: (?x) (?<!\w|-)(?:(?:-|\+)?(?:[0-9]+(?:\.[0-9]+)?)|(?:\.[0-9]+)) ((?:px|pt|ch|cm|mm|in|r?em|ex|pc|deg|g?rad|dpi|dpcm|dppx|fr|ms|s|turn|vh|vmax|vmin|vw)\b|%)?
            name: constant.numeric.css
            captures:
              1: {name: keyword.other.unit.css}
      operator:
        patterns:
          - match: ((?:\?|:|!|~|\+|(\s-\s)|(?:\*)?\*|\/|%|(\.)?\.\.|<|>|(?:=|:|\?|\+|-|\*|\/|%|<|>)?=|!=)|\b(?:in|is(?:nt)?|(?<!:)not|or|and)\b)
            name: keyword.operator.stylus
          - include: "#char_escape"
      property:
        begin: |-
          (?x:\G\s*(?:
            (-webkit-[-A-Za-z]+|-moz-[-A-Za-z]+|-o-[-A-Za-z]+|-ms-[-A-Za-z]+|-khtml-[-A-Za-z]+|zoom|z-index|y|x|wrap|word-wrap|word-spacing|word-break|word|width|widows|white-space-collapse|white-space|white|weight|volume|voice-volume|voice-stress|voice-rate|voice-pitch-range|voice-pitch|voice-family|voice-duration|voice-balance|voice|visibility|vertical-align|variant|user-select|up|unicode-bidi|unicode-range|unicode|trim|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform|touch-action|top-width|top-style|top-right-radius|top-left-radius|top-color|top|timing-function|text-wrap|text-transform|text-shadow|text-replace|text-rendering|text-overflow|text-outline|text-justify|text-indent|text-height|text-emphasis|text-decoration|text-align-last|text-align|text|target-position|target-new|target-name|target|table-layout|tab-size|style-type|style-position|style-image|style|string-set|stretch|stress|stacking-strategy|stacking-shift|stacking-ruby|stacking|src|speed|speech-rate|speech|speak-punctuation|speak-numeral|speak-header|speak|span|spacing|space-collapse|space|sizing|size-adjust|size|shadow|respond-to|rule-width|rule-style|rule-color|rule|ruby-span|ruby-position|ruby-overhang|ruby-align|ruby|rows|rotation-point|rotation|role|right-width|right-style|right-color|right|richness|rest-before|rest-after|rest|resource|resize|reset|replace|repeat|rendering-intent|rate|radius|quotes|punctuation-trim|punctuation|property|profile|presentation-level|presentation|position|pointer-events|point|play-state|play-during|play-count|pitch-range|pitch|phonemes|pause-before|pause-after|pause|page-policy|page-break-inside|page-break-before|page-break-after|page|padding-top|padding-right|padding-left|padding-bottom|padding|pack|overhang|overflow-y|overflow-x|overflow-style|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|origin|orientation|orient|ordinal-group|order|opacity|offset|numeral|new|nav-up|nav-right|nav-left|nav-index|nav-down|nav|name|move-to|model|mix-blend-mode|min-width|min-height|min|max-width|max-height|max|marquee-style|marquee-speed|marquee-play-count|marquee-direction|marquee|marks|mark-before|mark-after|mark|margin-top|margin-right|margin-left|margin-bottom|margin|mask-image|list-style-type|list-style-position|list-style-image|list-style|list|lines|line-stacking-strategy|line-stacking-shift|line-stacking-ruby|line-stacking|line-height|line-break|level|letter-spacing|length|left-width|left-style|left-color|left|label|justify-content|justify|iteration-count|inline-box-align|initial-value|initial-size|initial-before-align|initial-before-adjust|initial-after-align|initial-after-adjust|index|indent|increment|image-resolution|image-orientation|image|ihyphens|hyphenate-resource|hyphenate-lines|hyphenate-character|hyphenate-before|hyphenate-after|hyphenate|height|header|hanging-punctuation|gap|grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-start|grid-row|grid-row-end|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows|row-gap|gap|font-kerning|font-language-override|font-weight|font-variant-caps|font-variant|font-style|font-synthesis|font-stretch|font-size-adjust|font-size|font-family|font|float-offset|float|flex-wrap|flex-shrink|flex-grow|flex-group|flex-flow|flex-direction|flex-basis|flex|fit-position|fit|fill|filter|family|empty-cells|emphasis|elevation|duration|drop-initial-value|drop-initial-size|drop-initial-before-align|drop-initial-before-adjust|drop-initial-after-align|drop-initial-after-adjust|drop|down|dominant-baseline|display-role|display-model|display|direction|delay|decoration-break|decoration|cursor|cue-before|cue-after|cue|crop|counter-reset|counter-increment|counter|count|content|columns|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|column-break-before|column-break-after|column|color-profile|color|collapse|clip|clear|character|caption-side|break-inside|break-before|break-after|break|box-sizing|box-shadow|box-pack|box-orient|box-ordinal-group|box-lines|box-flex-group|box-flex|box-direction|box-decoration-break|box-align|box|bottom-width|bottom-style|bottom-right-radius|bottom-left-radius|bottom-color|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-length|border-left-width|border-left-style|border-left-color|border-left|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|bookmark-target|bookmark-level|bookmark-label|bookmark|binding|bidi|before|baseline-shift|baseline|balance|background-blend-mode|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-break|background-attachment|background|azimuth|attachment|appearance|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-duration|animation-direction|animation-delay|animation-fill-mode|animation|alignment-baseline|alignment-adjust|alignment|align-self|align-last|align-items|align-content|align|after|adjust|will-change)|
            (writing-mode|text-anchor|stroke-width|stroke-opacity|stroke-miterlimit|stroke-linejoin|stroke-linecap|stroke-dashoffset|stroke-dasharray|stroke|stop-opacity|stop-color|shape-rendering|marker-start|marker-mid|marker-end|lighting-color|kerning|image-rendering|glyph-orientation-vertical|glyph-orientation-horizontal|flood-opacity|flood-color|fill-rule|fill-opacity|fill|enable-background|color-rendering|color-interpolation-filters|color-interpolation|clip-rule|clip-path)|
            ([a-zA-Z_-][a-zA-Z0-9_-]*)
          )(?!([^\S\n]*&)|([^\S\n]*\{))(?=:|([^\S\n]+[^\s])))
        end: (;)|(?=\n|\}|$)
        beginCaptures:
          1: {name: support.type.property-name.css}
          2: {name: support.type.property-name.svg.css}
          3: {name: support.function.mixin.stylus}
        endCaptures:
          1: {name: punctuation.terminator.rule.css}
        patterns:
          - include: "#property_value"
      property_value:
        begin: \G(?:(:)|(\s))(\s*)(?!&)
        end: (?=\n|;|\})
        name: meta.property-value.css
        beginCaptures:
          1: {name: punctuation.separator.key-value.css}
          2: {name: punctuation.separator.key-value.css}
        endCaptures:
          1: {name: punctuation.terminator.rule.css}
        patterns:
          - include: "#property_values"
          - match: '[^\n]+?'
      property_values:
        patterns:
          - include: "#function"
          - include: "#comment"
          - include: "#language_keywords"
          - include: "#language_constants"
          - match: (?:(?=\w)(?<![\w-]))(wrap-reverse|wrap|whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|unicase|underline|ultra-expanded|ultra-condensed|transparent|transform|top|titling-caps|thin|thick|text-top|text-bottom|text|tb-rl|table-row-group|table-row|table-header-group|table-footer-group|table-column-group|table-column|table-cell|table|sw-resize|super|strict|stretch|step-start|step-end|static|square|space-between|space-around|space|solid|soft-light|small-caps|separate|semi-expanded|semi-condensed|se-resize|scroll|screen|saturation|s-resize|running|rtl|row-reverse|row-resize|row|round|right|ridge|reverse|repeat-y|repeat-x|repeat|relative|progressive|progress|pre-wrap|pre-line|pre|pointer|petite-caps|paused|pan-x|pan-left|pan-right|pan-y|pan-up|pan-down|padding-box|overline|overlay|outside|outset|optimizeSpeed|optimizeLegibility|opacity|oblique|nw-resize|nowrap|not-allowed|normal|none|no-repeat|no-drop|newspaper|ne-resize|n-resize|multiply|move|middle|medium|max-height|manipulation|main-size|luminosity|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|local|list-item|linear(?!-)|line-through|line-edge|line|lighter|lighten|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline-block|inline|inherit|infinite|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|hue|horizontal|hidden|help|hard-light|hand|groove|geometricPrecision|forwards|flex-start|flex-end|flex|fixed|extra-expanded|extra-condensed|expanded|exclusion|ellipsis|ease-out|ease-in-out|ease-in|ease|e-resize|double|dotted|distribute-space|distribute-letter|distribute-all-lines|distribute|disc|disabled|difference|default|decimal|dashed|darken|currentColor|crosshair|cover|content-box|contain|condensed|column-reverse|column|color-dodge|color-burn|color|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|border-box|bolder|bold|block|bidi-override|below|baseline|balance|backwards|auto|antialiased|always|alternate-reverse|alternate|all-small-caps|all-scroll|all-petite-caps|all|absolute)(?:(?<=\w)(?![\w-]))
            name: support.constant.property-value.css
          - match: (?:(?=\w)(?<![\w-]))(start|sRGB|square|round|optimizeSpeed|optimizeQuality|nonzero|miter|middle|linearRGB|geometricPrecision |evenodd |end |crispEdges|butt|bevel)(?:(?<=\w)(?![\w-]))
            name: support.constant.property-value.svg.css
          - include: "#font_name"
          - include: "#numeric"
          - include: "#color"
          - include: "#string"
          - match: \!\s*important
            name: keyword.other.important.css
          - include: "#operator"
          - include: "#stylus_keywords"
          - include: "#property_variable"
      property_variable:
        patterns:
          - include: "#variable"
          - match: (?<!^)(\@[a-zA-Z_-][a-zA-Z0-9_-]*)
            name: variable.property.stylus
      selector:
        patterns:
          - match: (?:(?=\w)(?<![\w-]))(a|abbr|acronym|address|area|article|aside|audio|b|base|bdi|bdo|redo|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|main|map|mark|math|menu|menuitem|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rb|rp|rt|rtc|ruby|s|samp|script|section|select|small|source|span|strike|strong|style|sub|summary|sup|svg|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr)(?:(?<=\w)(?![\w-]))
            name: entity.name.tag.css
          - match: (?:(?=\w)(?<![\w-]))(vkern|view|use|tspan|tref|title|textPath|text|symbol|switch|svg|style|stop|set|script|rect|radialGradient|polyline|polygon|pattern|path|mpath|missing-glyph|metadata|mask|marker|linearGradient|line|image|hkern|glyphRef|glyph|g|foreignObject|font-face-uri|font-face-src|font-face-name|font-face-format|font-face|font|filter|feTurbulence|feTile|feSpotLight|feSpecularLighting|fePointLight|feOffset|feMorphology|feMergeNode|feMerge|feImage|feGaussianBlur|feFuncR|feFuncG|feFuncB|feFuncA|feFlood|feDistantLight|feDisplacementMap|feDiffuseLighting|feConvolveMatrix|feComposite|feComponentTransfer|feColorMatrix|feBlend|ellipse|desc|defs|cursor|color-profile|clipPath|circle|animateTransform|animateMotion|animateColor|animate|altGlyphItem|altGlyphDef|altGlyph|a)(?:(?<=\w)(?![\w-]))
            name: entity.name.tag.svg.css
          - match: \s*(\,)\s*
            name: meta.selector.stylus
          - match: \*
            name: meta.selector.stylus
          - match: \s*(\&)([a-zA-Z0-9_-]+)\s*
            name: meta.selector.stylus
            captures:
              2:
                {
                  name: entity.other.attribute-name.parent-selector-suffix.stylus,
                }
          - match: \s*(\&)\s*
            name: meta.selector.stylus
          - match: (\.)[a-zA-Z0-9_-]+
            name: entity.other.attribute-name.class.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (#)[a-zA-Z][a-zA-Z0-9_-]*
            name: entity.other.attribute-name.id.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (:+)(after|before|content|first-letter|first-line|host|(-(moz|webkit|ms)-)?selection)\b
            name: entity.other.attribute-name.pseudo-element.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (:)((first|last)-child|(first|last|only)-of-type|empty|root|target|first|left|right)\b
            name: entity.other.attribute-name.pseudo-class.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (:)(checked|enabled|default|disabled|indeterminate|invalid|optional|required|valid)\b
            name: entity.other.attribute-name.pseudo-class.ui-state.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - begin: ((:)not)(\()
            end: \)
            beginCaptures:
              1: {name: entity.other.attribute-name.pseudo-class.css}
              2: {name: punctuation.definition.entity.css}
              3: {name: punctuation.section.function.css}
            endCaptures:
              0: {name: punctuation.section.function.css}
            patterns:
              - include: "#selector"
          - match: ((:)nth-(?:(?:last-)?child|(?:last-)?of-type))(\()(\-?(?:\d+n?|n)(?:\+\d+)?|even|odd)(\))
            captures:
              1: {name: entity.other.attribute-name.pseudo-class.css}
              2: {name: punctuation.definition.entity.css}
              3: {name: punctuation.section.function.css}
              4: {name: constant.numeric.css}
              5: {name: punctuation.section.function.css}
          - match: ((:)dir)\s*(?:(\()(ltr|rtl)?(\)))?
            captures:
              1: {name: entity.other.attribute-name.pseudo-class.css}
              2: {name: puncutation.definition.entity.css}
              3: {name: punctuation.section.function.css}
              4: {name: constant.language.css}
              5: {name: punctuation.section.function.css}
          - match: ((:)lang)\s*(?:(\()(\w+(-\w+)?)?(\)))?
            captures:
              1: {name: entity.other.attribute-name.pseudo-class.css}
              2: {name: puncutation.definition.entity.css}
              3: {name: punctuation.section.function.css}
              4: {name: constant.language.css}
              6: {name: punctuation.section.function.css}
          - match: (:)(active|hover|link|visited|focus)\b
            name: entity.other.attribute-name.pseudo-class.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (::)(shadow)\b
            name: entity.other.attribute-name.pseudo-class.css
            captures:
              1: {name: punctuation.definition.entity.css}
          - match: (?i)(\[)\s*(-?[_a-z\\[[:^ascii:]]][_a-z0-9\-\\[[:^ascii:]]]*)(?:\s*([~|^$*]?=)\s*(?:(-?[_a-z\\[[:^ascii:]]][_a-z0-9\-\\[[:^ascii:]]]*)|((?>(['"])(?:[^\\]|\\.)*?(\6)))))?\s*(\])
            name: meta.attribute-selector.css
            captures:
              1: {name: punctuation.definition.entity.css}
              2: {name: entity.other.attribute-name.attribute.css}
              3: {name: punctuation.separator.operator.css}
              4: {name: string.unquoted.attribute-value.css}
              5: {name: string.quoted.double.attribute-value.css}
              6: {name: punctuation.definition.string.begin.css}
              7: {name: punctuation.definition.string.end.css}
              8: {name: punctuation.definition.entity.css}
          - include: "#interpolation"
          - include: "#variable"
      string:
        patterns:
          - begin: '"'
            end: '"'
            name: string.quoted.double.css
            beginCaptures:
              0: {name: punctuation.definition.string.begin.css}
            endCaptures:
              0: {name: punctuation.definition.string.end.css}
            patterns:
              - match: \\([a-fA-F0-9]{1,6}|.)
                name: constant.character.escape.css
          - begin: "'"
            end: "'"
            name: string.quoted.single.css
            beginCaptures:
              0: {name: punctuation.definition.string.begin.css}
            endCaptures:
              0: {name: punctuation.definition.string.end.css}
            patterns:
              - match: \\([a-fA-F0-9]{1,6}|.)
                name: constant.character.escape.css
      variable:
        match: (\$[a-zA-Z_-][a-zA-Z0-9_-]*)
        name: variable.stylus
      variable_declaration:
        begin: ^[^\S\n]*(\$?[a-zA-Z_-][a-zA-Z0-9_-]*)[^\S\n]*(\=|\?\=|\:\=)
        end: (\n)|(;)|(?=\})
        beginCaptures:
          1: {name: variable.stylus}
          2: {name: keyword.operator.stylus}
        endCaptures:
          2: {name: punctuation.terminator.rule.css}
        patterns:
          - include: "#property_values"


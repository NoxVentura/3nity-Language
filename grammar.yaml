name: Isogram
scopeName: source.coffee
fileTypes: [ig, coffee]
patterns: [{include: "#core"}]

information_for_contributors: |
  Isogram is a modern functional, imperative and object-oriented programming language
  with a syntax inspired by Python, and compile(s) to JavaScript and WebAssembly.

  Isogram is additionally inspired by Ruby, Elixir, Clojure, LiveScript, Haskell, OCaml, Go,
  Scala, Flix, Nim, Bash and YAML.

  Should you want to provide a fix or improvement, or even a new feature,
  please create a pull request against this repo: https://github.com/nxltm/isogram
  and I will be very happy to receive them.

  Once accepted, I am happy to receive your request and feedback.

  This document is always under construction, and there's still a couple of things that
  need to be fixed. All this info would be on my Trello which I will be posting very soon.
  I will come back to fix them if I have the time.

comment: |
  To-Do:

  - Add function labels
  - Add keywords for types from SQL
  - Add JSX syntax and more
  - Add grammars for Unicode character entities
    - HTML5, AGL and LaTeX
    - Locale and Unicode script codes
    - Transformation rules

  - Add standard library functions, types, classes, in this order
    - PHP (naming conventions use camelCase only)
    - JavaScript/TypeScript
    - Java/Scala/Flix/Kotlin
    - Swift/C(++) + Objective-C(++)
    - C#/F#/.NET
    - Elixir
    - Perl, Rust, Crystal, Ruby
    - Python
    - Haskell, Elm, PureScript etc

  Done:
  - Standardized modifier and declaration keywords
  - Syntax changed

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.ig}
    2: {name: punctuation.separator.decimal.period.ig}
    3: {name: constant.numeric.other.separator.ig}
    4: {name: constant.numeric.other.exponent.ig}
    5: {name: constant.numeric.other.density.ig}
    6: {name: storage.type.numeric.ig}

  entity-name: &entity-name |
    (?x)\s*\b

    (?!
    \b(?:# don't match keywords
    in|of|as|is|new|infer|unset
    |typeof|nameof|sizeof|pairof|keyof|valueof
    |length|delete|to|til|thru|at|by
    |n?and|x?n?or|not|parallel|series|spawn|discard
    |func?|function|proc|process|macro
    |let|var|val|const|declare
    |class|given|constraint|enum|relation|lattice
    |project|attribute|protocol|member|extend|fragment|interface|struct
    |module|package|namespace|object|record|label
    |raw|data|query|schema|style|trait|friend|alias|type
    |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
    |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
    |switch|case|fail|default|match|when|pass|fallthru
    |try|retry|throw|raise|catch|rescue|finally
    |with|ref|defer|refer|show|hide|enter|exit
    |then|begin|end|debug|check|assert
    |break|continue|halt|skip|fixed|lock
    |(?:return|give|await|yield|throw|raise)s?
    |import|export|show|hide|open|close
    |from|where|join|equals?|[io]nto|order
    |take|drop|fold|scan|select|group|use|using
    )\b
    )

    ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
    \b

  posix-class: &posix-class |
    (?xi)
    \\o|
    \\p(?:
    # POSIX
    alpha|alnum|ascii|blank|cntrl|x?digit
    |graph|lower|print|punct|space|upper|word
    # Extended-POSIX
    |symbol|open|close|dash|link|start|final|math|money
    |number|letter|title|mark|modify
    |bin|qua|sen|oct|dec|doz|hex
    )

repository:
  core:
    patterns:
      - comment: The following are placeholders.
          Will redo embedded HTML and CSS syntax later.
      - include: "#jsx"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#operators"
      - include: "#literals"
      - include: "#support"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  illegal:
    patterns:
      - match: '\p{N}[\p{L}\p{M}\p{N}_.+-/\\]*?'
        name: invalid.illegal.numeric.other.ig
      - match: '[_\p{L}\p{M}\p{N}]+?'
        name: invalid.illegal.variable.other.ig
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.ig
      - match: '\S+?'
        name: invalid.illegal.syntax.ig

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  class-names:
    comment: Names for built-in classes
    patterns:
      - comment:

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive data types
        match: |
          (?x)\s*\b(
          bool|u?int|float|natural|ratio|real|imag|complex|number
          |char|rune|string|symbol|regexp?|function|buffer|binary
          |# numeric types
          ([cifsun]|natural|ratio|u?int|real|imag|complex)
          (8|16|32|64|128)
          |[ci](half|float|double|decimal|octuple)
          )\b
        name: support.type.builtin.primitive.ig
      - comment: Constant/algebraic types
        match: |
          (?x)\s*\b(
          true|false|null|void|nan|infin
          |any|empty|object|record|unit|mixed
          |just|some|none|never|(im)?pure|channel
          )\b
        name: support.type.builtin.ig
      - comment: Data structures
        match: |
          (?x)\s*\b(
          array|tuple|(?:mut)?(?:list|set|map)|dict|function
          |process|sequence|generator|range|stack|heap|queue|tree|trie
          )\b
        name: support.type.primitive.ig
      - comment: Primitive classes
        match: |
          (?x)\s*\b(
          Bool|U?Int|Float|Natural|Ratio|Real|Imag|Complex|Number
          |Char|Rune|String|Symbol|RegExp?|Function|Buffer|Binary
          |# Numeric Types
          ([CIFSUN]|Natural|Ratio|U?Int|Real|Imag|Complex)
          (8|16|32|64|128)
          |[CI](Half|Float|Double|Decimal|Octuple)
          )\b
        name: support.class.builtin.primitive.ig
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*\b(
          True|False|Null|Void|NaN|Infin
          |Any|Empty|Object|Record|Unit|Mixed
          |Just|Some|None|Never|(Im)?pure|Channel
          )\b
        name: support.class.builtin.ig
      - comment: Data structure classes
        match: |
          (?x)\s*\b(
          Array|Tuple|(Mut)?(List|Set|Map)|Dict|Function
          |Process|Sequence|Generator|Range|Stack|Heap|Queue|Tree|Trie
          )\b
        name: support.class.primitive.ig

      - comment: Interface classes | IEnumerable, etc
        match: (?x)\s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.ig
      - comment: Namespace classes | NSString, etc
        match: (?x)\s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.ig
      - comment: Error classes | BaseError, etc
        match: (?x)\s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.ig
      - comment: Trait classes | Serializable, Loggable etc
        match: (?x)\s*\b((\p{Lu}[\w&&\P{Lu}]*)+)(able)\b
        name: support.class.trait.ig

  function-names:
    comment: Names for built-in functions (initial dump)
    patterns: []

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns: []

  variable-names:
    comment: Standard Library variable names
    patterns: []

  property-names:
    comment: Standard Library property names
    patterns: []

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )\b\s*
        captures:
          1: {name: constant.language.boolean.true.ig}
          2: {name: constant.language.boolean.false.ig}
          3: {name: constant.language.null.ig}
          4: {name: constant.language.undefined.ig}
          5: {name: constant.language.nan.ig}
          6: {name: constant.language.infinity.ig}
      - match: |
          (?x)\s*\b(?:
          (_|params)|(super|this|self|proto|prototype|constructor|target)
          )\b\s*
        captures:
          1: {name: variable.language.arguments.ig}
          2: {name: variable.language.$2.ig}

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.ig
      - match: (?<=(?:^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.ig
      - match: |-
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)
          (?:(\.)(?:\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)?)?
          (?:(\*)\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)?
          (?:(\.)(?:\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)?)
          (?:(\*)\p{Alnum}+(?:(?:,|_+)?*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0b)
          (?:[01]+(?:(?:,|_+)?*[01]+)*)
          (?:(\.)(?:[01]+(?:(?:,|_+)?*[01]+)*)?)?
          (?:(\*)[01]+(?:(?:,|_+)?*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0b)
          (?:[01]+(?:(?:,|_+)?*[01]+)*)?
          (?:(\.)(?:[01]+(?:(?:,|_+)?*[01]+)*)?)
          (?:(\*)[01]+(?:(?:,|_+)?*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)
          (?:(\.)(?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?)?
          (?:(\*)[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (?:(\.)(?:[0-3]+(?:(?:,|_+)?*[0-3]+)*)?)
          (?:(\*)[0-3]+(?:(?:,|_+)?*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)
          (?:(\.)(?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?)?
          (?:(\*)[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (?:(\.)(?:[0-5]+(?:(?:,|_+)?*[0-5]+)*)?)
          (?:(\*)[0-5]+(?:(?:,|_+)?*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)
          (?:(\.)(?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?)?
          (?:(\*)[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (?:(\.)(?:[0-7]+(?:(?:,|_+)?*[0-7]+)*)?)
          (?:(\*)[0-7]+(?:(?:,|_+)?*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)
          (?:(\.)(?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?)?
          (?:(\*)[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (?:(\.)(?:[\dab]+(?:(?:,|_+)?*[\dab]+)*)?)
          (?:(\*)[\dab]+(?:(?:,|_+)?*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0x)
          (?:\h+(?:(?:,|_+)?*\h+)*)
          (?:(\.)(?:\h+(?:(?:,|_+)?*\h+)*)?)?
          (?:(\*)\h+(?:(?:,|_+)?*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (0x)
          (?:\h+(?:(?:,|_+)?*\h+)*)?
          (?:(\.)(?:\h+(?:(?:,|_+)?*\h+)*)?)
          (?:(\*)\h+(?:(?:,|_+)?*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          ()
          (?:\d+(?:(?:,|_+)?*\d+)*)
          (?:(\.)(?:\d+(?:(?:,|_+)?*\d+)*)?)?
          (?:(\*)\d+(?:(?:,|_+)?*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          ()
          (?:\d+(?:(?:,|_+)?*\d+)*)?
          (?:(\.)(?:\d+(?:(?:,|_+)?*\d+)*)?)
          (?:(\*)\d+(?:(?:,|_+)?*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:(?:,|_+)?*\w+)*)
          (?:(\.)(?:\w+(?:(?:,|_+)?*\w+)*)?)?
          (?:(\*)\w+(?:(?:,|_+)?*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}
      - match: |-
          (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:(?:,|_+)?*\w+)*)?
          (?:(\.)(?:\w+(?:(?:,|_+)?*\w+)*)?)
          (?:(\*)\w+(?:(?:,|_+)?*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)?
          \b\s*
        captures:
          0: {name: constant.numeric.illegal.ig}
          1: {name: storage.type.numeric.ig}
          2: {name: punctuation.separator.decimal.period.ig}
          3: {name: constant.numeric.other.separator.ig}
          4: {name: constant.numeric.other.exponent.ig}
          5: {name: constant.numeric.other.density.ig}
          6: {name: storage.type.numeric.ig}

  strings-quoted:
    patterns:
      - comment: single quoted raw string
        begin: \s*('{3,})
        contentName: string.quoted.single.ig
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.ig}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: \s*(')
        contentName: string.quoted.single.ig
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.ig}
        patterns:
          - match: "''"
            name: constant.character.escape.ig
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: \s*("{3,}|")
        contentName: string.quoted.double.ig
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.ig}
        patterns:
          - include: "#string-escapes"

  strings-unquoted:
    patterns:
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.ig}
          2: {name: storage.modifier.chomping-indicator.ig}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.ig}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.ig
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.ig
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*/<=>])?\s*
          (?:(\d\w*)|
          (
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.ig}
          2: {name: storage.modifier.chomping-indicator.ig}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.ig}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.syntax.ig
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.ig
            patterns:
              - include: "#string-escapes"
              - include: text.html.markdown#inline
          - include: $self
      - match: |
          (?x)
          \s*(\\)
          ((?:\\.|[^\s,:;])+?)
          (?=[({\[)}\]\s,:;]|$)\s*
        name: string.unquoted.ig
        captures:
          1: {name: punctuation.definition.string.ig}
          2: {patterns: [{include: "#string-escapes"}]}

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.ig
      - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
        name: constant.character.escape.binary.ig
      - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
        name: constant.character.escape.quaternary.ig
      - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
        name: constant.character.escape.senary.ig
      - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
        name: constant.character.escape.octal.ig
      - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
        name: constant.character.escape.decimal.ig
      - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
        name: constant.character.escape.duodecimal.ig
      - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.hexadecimal.ig
      - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.unicode.ig
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.ig
        patterns:
          - include: "#regexp-patterns"
      - match: (?i)\\[abceflnprtvz]
        name: constant.character.escape.ig
      - match: \\[\p{S}\p{P}]
        name: constant.character.escape.symbol.ig
      - match: \\[\p{L}\p{N}\p{Z}\p{c}]
        name: constant.character.escape.illegal.ig
      - include: "#embedded"

  embedded:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.ig}
          2: {name: constant.numeric.decimal.ig}
      - match: (%)((['"`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.ig}
          2: {name: storage.type.format.ig}
      - match: |
          (?xi)
          (?#?<!\\)# discard escape prefix
          (\$)# prefix
          (
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.ig}
          2: {patterns: [{include: "#core"}]}
      - begin: (?#?<!\\)(\${)\s*
        end: (})
        name: entity.quasi.element.ig
        captures:
          1: {name: punctuation.quasi.element.ig}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.ig}
          2: {name: constant.numeric.decimal.ig}
      - match: ([$%]){2}
        name: constant.character.escape.ig
      - match: (%)((['"`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.ig}
          2: {name: storage.type.format.ig}
      - match: |
          (?xi)
          (?<!\$)# discard escape prefix
          (\$)# prefix
          (
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.ig}
          2: {patterns: [{include: "#core"}]}
      - begin: (?<!\$)(\${)\s*
        end: (})
        name: entity.quasi.element.ig
        captures:
          1: {name: punctuation.quasi.element.ig}
        patterns:
          - include: $self

  symbols:
    match: |
      (?x)
      \s*
      (:)((?:\w|\\.)(?:\\.|[^\s,:;])*?)
      \b\s*
    name: meta.symbol.ig
    captures:
      1: {name: punctuation.definition.symbol.ig}
      2: {name: constant.other.symbol.ig}

  labels:
    match: |
      (?x)
      (?<=^|[({\[\s,;*+-])\s*

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|pairof|keyof|valueof
      |length|delete|to|til|thru|at|by
      |n?and|x?n?or|not|parallel|series|spawn|discard
      |func?|function|proc|process|macro
      |let|var|val|const|declare
      |class|given|constraint|enum|relation|lattice
      |project|attribute|protocol|member|extend|fragment|interface|struct
      |module|package|namespace|object|record|label
      |raw|data|query|schema|style|trait|friend|alias|type
      |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
      |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |import|export|show|hide|open|close
      |from|where|join|equals?|[io]nto|order
      |take|drop|fold|scan|select|group|use|using
      )\b
      )

      ((?:\w|\\.)(?:\\.|[^\s,:;])*?)
      (?=:\s+)
    name: meta.object-literal.key.ig
    captures:
      1: {name: constant.other.object.key.ig}
      2: {name: punctuation.separator.key-value.ig}

  regexps:
    patterns:
      - begin: (\p{Alnum}*)(`)\s*
        end: \s*(?!\\)(`(?!`))(\p{Alnum}*)
        contentName: string.pattern.regexp.ig
        beginCaptures:
          1: {name: keyword.modifier.ig}
          2: {name: punctuation.section.regexp.begin.ig}
        endCaptures:
          1: {name: punctuation.section.regexp.end.ig}
          2: {name: keyword.other.flag.ig}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - begin: (`)(`)\s*\n?
            end: \s*(?=(?!\\)`)
            contentName: string.replace.regexp.ig
            beginCaptures:
              1: {name: punctuation.section.regexp.end.ig}
              2: {name: punctuation.section.regexp.begin.ig}
            patterns:
              - include: "#back-references"
      - begin: |
          (?x)\s*
          (\\\<)\s*
          ([-+*/<=>])?\s*
          (?:(\w+)?\b\s*\b
          (
          \w+\s*
          (?:[+-]\s*
          (?:(?:\w+)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.ig}
          2: {name: storage.modifier.chomping-indicator.ig}
          3: {name: keyword.modifier.ig}
          4: {name: keyword.other.flag.ig}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.ig
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\p{Zs})+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.out.ig
            patterns:
              - include: "#regexp-patterns"
          - include: $self

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.ig
      - match: \${2}
        name: constant.character.escape.ig
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.ig
        beginCaptures:
          1: {name: keyword.other.back-reference.ig}
        endCaptures:
          1: {name: keyword.other.back-reference.ig}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-escapes"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.ig
      - match: \&
        name: keyword.operator.match.ig
      - match: \!
        name: keyword.operator.disjunction.ig
      - match: \.
        name: constant.character.all.ig
      - match: (?i)\\[by]({\p{Alpha}+})?
        name: keyword.control.anchor.ig
      - match: (?i)(\^|\\<|\\a(?:{\p{Alpha}+})?)|(\$|\\>|\\z(?:{\p{Alpha}+})?)
        captures:
          1: {name: keyword.control.begin.ig}
          2: {name: keyword.control.end.ig}
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.ig}
          2: {name: keyword.operator.quantifier.lazy.ig}
          3: {name: keyword.operator.quantifier.eager.ig}
          4: {name: keyword.operator.quantifier.greedy.ig}
      - match: \\\d+
        name: keyword.other.back-reference.ig
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.ig
      - begin: (\\Q)
        contentName: string.quoted.single.ig
        end: (\\E)
        name: string.quoted.raw.ig
        captures:
          1: {name: punctuation.definition.string.ig}
        patterns:
          - include: "#string-escapes"
      - begin: (\\q)
        contentName: string.quoted.double.ig
        end: (\\e)
        name: string.quoted.ig
        captures:
          1: {name: punctuation.definition.string.ig}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.ig
        beginCaptures:
          1: {name: keyword.other.back-reference.ig}
        endCaptures:
          1: {name: keyword.other.back-reference.ig}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.ig
        beginCaptures:
          1: {name: keyword.other.subroutine.ig}
        endCaptures:
          1: {name: keyword.other.subroutine.ig}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.ig}
          2: {name: keyword.control.keepout.ig}
          3: {name: keyword.control.search.ig}
          4: {name: constant.character.unicode.ig}
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.ig}
          2: {name: keyword.operator.modifier.eager.ig}
          3: {name: keyword.operator.modifier.greedy.ig}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.ig}
          2: {name: keyword.operator.quantifier.eager.ig}
          3: {name: keyword.operator.quantifier.greedy.ig}
      - match: \\.
        name: constant.character.escape.other.ig

    repository:
      regexp-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.ig
            captures:
              0: {name: punctuation.section.expression.ig}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.ig
            end: \s*(\))
            name: comment.block.regexp.ig
            captures:
              1: {name: punctuation.definition.comment.ig}
            patterns:
              - match: \\.
                name: comment.block.regexp.ig
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.look-ahead.ig
            captures:
              1: {name: punctuation.definition.group.look-ahead.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.look-behind.ig
            captures:
              1: {name: punctuation.definition.group.look-behind.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.negative-look-ahead.ig
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.negative-look-behind.ig
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{Lower}+(?:[+-]\p{Lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.flag.ig
            captures:
              0: {name: punctuation.definition.group.flag.ig}
              1: {name: punctuation.definition.group.flag.ig}
              2: {name: entity.name.function.method.ig}
              3: {name: keyword.control.recursion.ig}
              4: {name: keyword.other.flag.ig}
              5: {name: punctuation.separator.colon.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.call-out.ig
            captures:
              1: {name: punctuation.definition.group.call-out.ig}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.ig
                captures:
                  1: {name: punctuation.definition.group.call-out.ig}
                  2: {name: keyword.operator.range.ig}
                  3: {name: punctuation.definition.tag.ig}
                  4: {patterns: [{include: "#function-entities"}]}
                  5: {name: punctuation.definition.tag.ig}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.atomic.ig
            captures:
              1: {name: punctuation.definition.group.atomic.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.non-capturing.ig
            captures:
              1: {name: punctuation.definition.group.non-capturing.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.branch.ig
            captures:
              1: {name: punctuation.definition.group.branch.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.absent.ig
            captures:
              1: {name: punctuation.definition.group.absent.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([_\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.back-reference.ig
            captures:
              0: {name: punctuation.definition.group.back-reference.ig}
              1: {name: punctuation.definition.group.back-reference.ig}
              2: {name: entity.name.function.method.ig}
              3: {name: variable.other.ig}
              4: {name: punctuation.separator.colon.ig}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.named.ig
            beginCaptures:
              0: {name: punctuation.definition.group.named.ig}
              1: {patterns: [{include: "#variables"}]}
            endCaptures:
              0: {name: punctuation.definition.group.named.ig}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.ig
                beginCaptures:
                  1: {name: punctuation.definition.group.named.ig}
                endCaptures:
                  1: {name: punctuation.definition.group.named.ig}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            name: meta.group.ig
            captures:
              0: {name: punctuation.definition.group.ig}
            patterns:
              - include: "#regexp-patterns"

      regexp-char-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.ig
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.ig
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.ig
            patterns:
              - include: "#regexp-patterns"
          - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
            name: constant.character.escape.binary.ig
          - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
            name: constant.character.escape.quaternary.ig
          - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
            name: constant.character.escape.senary.ig
          - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
            name: constant.character.escape.octal.ig
          - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
            name: constant.character.escape.decimal.ig
          - match: (?i)\\z(?:[\dab]{1,6}|{[\s\dab]+?})
            name: constant.character.escape.duodecimal.ig
          - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.hexadecimal.ig
          - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.unicode.ig
          - match: (?i:\\[cm][a-z])|\\R
            name: constant.character.control.ig
          - match: *posix-class
            name: constant.other.character-class.posix.ig
          - match: (?i:\\p(c[cfos]?|l[lmotu]?|m[cen]?|n[dlo]?|p[c-fios]?|s[ckmo]?|z[lps]))
            name: constant.other.character-class.unicode.ig
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.ig
          - match: \.|\\[dhlns-w]
            name: constant.other.character-class.ig
          - match: \\[DHLNS-W]
            name: constant.other.character-class.negated.ig
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.ig
          - match: (?i)\\[abceflnprtvz]
            name: constant.character.escape.ig
          - match: \\[\p{S}\p{P}]
            name: constant.character.escape.symbol.ig
          - match: \\\p{Z}
            name: constant.character.escape.symbol.ig
          - match: \\[\p{L}\p{N}\p{Z}\p{c}]
            name: constant.character.escape.illegal.ig
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: \--
            name: keyword.operator.optional.ig
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.ig
          - match: \|\|
            name: keyword.operator.union.ig
          - match: \&&
            name: keyword.operator.intersection.ig
          - match: \^\^
            name: keyword.operator.only.ig
          - match: ~~
            name: keyword.operator.maybe.ig
          - match: \.
            name: constant.other.character-class.range.ig
          - match: \\.
            name: constant.character.escape.other.ig

      regexp-char-set:
        patterns:
          - begin: (\[=)
            end: \s*(\])
            name: constant.other.character-class.posix.ig
            captures:
              1: {name: punctuation.definition.character-class.posix.ig}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\.)
            end: \s*(\])
            name: constant.other.character-class.posix.ig
            captures:
              1: {name: punctuation.definition.character-class.posix.ig}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[:)
            end: \s*(\])
            name: constant.other.character-class.posix.ig
            captures:
              1: {name: punctuation.definition.character-class.posix.ig}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.negated.ig
            captures:
              1: {name: punctuation.definition.character-class.negated.ig}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.ig
            captures:
              1: {name: punctuation.definition.character-class.ig}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"

  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    patterns:
      - begin: (?=<[_\p{L}\p{Nl}])
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#tag-element-name"
    repository:
      tag-element-name:
        patterns:
          - comment: JSX Fragment
            name: meta.tag.ig
            contentName: JSXAttrs
            begin: \s*+(<)\s*(?=>)
            end: (?<=</)(>)
            beginCaptures:
              1: {name: punctuation.definition.tag.ig}
            endCaptures:
              1: {name: punctuation.definition.tag.ig}
            patterns:
              - include: "#tag-termination"
          - comment: "Tags that end > are trapped in #tag-termination"
            name: meta.tag.ig
            contentName: JSXAttrs
            begin: |
              (?x)\s*+(<)([_\p{L}\p{Nl}][^\s,;'"`\\</>]*)(?=[\/>\s])(?![:])(?<!\.|:)
            end: \s*(?<=</)(\2)(>)|(/>)|((?<=</)\O*?)>
            beginCaptures:
              1: {name: punctuation.definition.tag.ig}
              2:
                patterns: &tag-names
                  - include: "#type-names"
                  - include: "#custom-types"
                  - include: "#function-entities"
                  - include: "#operators"
            endCaptures:
              1: {patterns: *tag-names}
              2: {name: punctuation.definition.tag.ig}
              3: {name: punctuation.definition.tag.ig}
              4: {name: invalid.illegal.termination.ig}
            patterns:
              - include: "#tag-termination"
              - include: "#tag-attributes"
      tag-termination:
        comment: uses non consuming search for </ in </tag>
        contentName: JSXNested
        begin: (>)
        end: (</)
        beginCaptures:
          0: {name: punctuation.definition.tag.ig}
          1: {name: JSXStartTagEnd}
        endCaptures:
          0: {name: punctuation.definition.tag.ig}
          1: {name: JSXEndTagStart}
        patterns:
          - include: "#evaluated-code"
          - include: "#entities"
          - include: "#tag-element-name"
          - include: "#string-escapes"
          - include: markdown.math.block
          - include: text.html.markdown#inline
      attribute-expression:
        name: meta.embedded.expression.js
        contentName: source.js
        begin: \(
        end: \)
        captures:
          0: {name: punctuation.section.embedded.ig}
        patterns:
          - include: $self
          - include: source.yaml#flow-collection
      tag-attributes:
        patterns:
          - include: "#comments"
          - include: "#attribute-name"
          - include: "#spread-attribute"
          - include: "#attribute-expression"
          - include: "#literals"
          - include: "#evaluated-code"
          - include: "#tag-element-name"
      spread-attribute:
        comment: Spread attribute { ... AssignmentExpression }
        match: (?<!\*)\*(?!\*)
        name: keyword.operator.spread.ig
      attribute-name:
        patterns:
          - comment: Style attribute
            begin: (?<!\S)(style)(=)?({)
            end: \s*(})\s*
            beginCaptures:
              1: {name: entity.other.attribute-name.ig}
              2: {name: punctuation.separator.key-value.ig}
              3: {name: punctuation.section.embedded.ig}
            endCaptures:
              1: {name: punctuation.section.embedded.ig}
            patterns:
              - include: source.css.scss#flow_control
              - include: source.css.scss#rules
              - include: source.css.scss#properties
              - include: source.css.scss
          - comment: Attribute names
            match: (?<=[)\]}])(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
            captures:
              1: {name: punctuation.separator.key-value.ig}
              2:
                name: string.unquoted.html.ig
                patterns:
                  - include: "#string-escapes"
                  - include: source.yaml#flow-scalar
          - comment: Attribute names
            match: (?<!\S)([_\p{L}\p{Nl}][^\s,;'"`\\/<=>]*)(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
            captures:
              1: {name: entity.other.attribute-name.ig}
              2: {name: punctuation.separator.key-value.ig}
              3:
                name: string.unquoted.html.ig
                patterns:
                  - include: "#string-escapes"
                  - include: source.yaml#flow-scalar
      evaluated-code:
        name: meta.embedded.expression.js
        contentName: source.js
        begin: "{"
        end: "}"
        captures:
          0: {name: punctuation.section.embedded.ig}
        patterns:
          - include: "#spread-attribute"
          - include: $self
      entities:
        patterns:
          - include: text.xml#entity
          - comment: Entity with & and invalid name
            match: "&\\s*+;"
            name: invalid.illegal.bad-ampersand.ig

  document:
    patterns:
      - include: "#document-inline-tags"
      - include: "#document-access"
      - include: "#document-as-name-path"
      - include: "#document-simple-name-path"
      - include: "#document-module"
      - include: "#document-type-name"
      - include: "#document-type-no-name"
      - match: (?<=^|[''"`\\\s({\[])@([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\b
        name: storage.type.class.ig

    repository:
      document-access:
        match: |
          (?x)
          (@acc)\b\s*\b
          (?:
          (?:
          public|private|protected|read|a?sync|inline|lazy|eager|trans|part
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          # Function or method modifiers
          |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |# Function or method modifiers
          (?:pre|in|post|suf|af|trans|interface)fix|
          (?:u|bi|ter|)nary|oper
          |# Decorators
          @(?:
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )
          )\s*\b
          )*
          (?=\s|$)
        captures:
          1: {name: storage.type.class.ig}
          0: {name: storage.modifier.ig}
      document-as-name-path:
        begin: (@(borrows|lends)\b)\s*(?=(?![}\]]\#)\S+(?:(?:\s*\bas\b\s*(?![}\]]\#)\S+)?)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#document-name-path-scopes"
      document-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.ig
        beginCaptures:
          1: {name: string.linktext.ig}
          2: {name: meta.brace.curly.ig}
        endCaptures:
          1: {name: meta.brace.curly.ig}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.ig}
              3: {name: string.ig}
      document-module:
        begin: |
          (?x)(@(
          (?:(?:im|ex)port|listen|require|use)s?
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#document-typedef-scopes"
          - match: (?:(module|package)(:))?(((?![}\]]\#)\S)+)
            captures:
              1: {name: keyword.module.ig}
              2: {name: punctuation.ig}
              3: {name: string.module-name.ig}
      document-name-scopes:
        patterns:
          - match: ((?![}\]]\#)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.ig}
          - begin: \[
            end: \]|^
            name: variable.other.ig
            patterns:
              - include: "#document-string"
              - include: "#document-name-scopes"
      document-simple-name-path:
        begin: |
          (?x)(@(
          (?:use|call|emit|event|fire)s?|alias|name|mixes|prop
          |this|that|it|self|super
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#types"
      document-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.ig
      document-type-name:
        begin: |
          (?x)(@(
          func?|function|proc|process|macro|class|given|constraint|const|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct|module|package|namespace|object|record|raw
          |data|query|schema|style|trait|friend|alias|type|declare|let|va[rl]
          |arg|ctor|member|method|mixin|param
          )\b)\s*
          (?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#document-name-scopes"
      document-type-no-name:
        begin: |
          (?x)
          (@(
          public|private|protected|read|a?sync|inline|lazy|eager|trans|part
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          # Function or method modifiers
          |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |# Function or method modifiers
          (?:pre|in|post|suf|af|trans|interface)fix|
          (?:u|bi|ter|)nary|oper
          |# Decorators
          @(?:
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
          )
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#document-typedef-scopes"
      document-typedef-obj:
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.ig}
        patterns:
          - include: "#types"
      document-typedef-scopes:
        begin: "{"
        end: "}|^"
        name: entity.name.type.instance.ig
        captures:
          0: {name: meta.brace.curly.ig}
        patterns:
          - include: "#types"

  comments:
    patterns:
      - begin: \s*((/\+))
        end: (\s*(\+/))
        name: comment.block.inline.ig
        captures:
          1: {name: comment.block.inline.ig}
          2: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      - begin: \s*((/\*\*))
        end: (\s*(\*\*/))
        name: comment.block.documentation.ig
        captures:
          1: {name: comment.block.documentation.ig}
          2: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      - begin: \s*((/\*))
        end: (\s*(\*/))
        name: comment.block.ig
        captures:
          1: {name: comment.block.ig}
          2: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-block"
      - begin: ((^\s*)|\s*)((//=))
        end: \s*$
        name: comment.line.special.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.special.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          1: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#comment-special"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((//\+))
        end: \s*$
        name: comment.line.playground.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.playground.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          0: {name: comment.line.playground.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((///))
        end: \s*$
        name: comment.line.documentation.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.documentation.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          0: {name: comment.line.documentation.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((//!|#!))
        end: \s*$
        name: comment.line.shebang.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.shebang.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          0: {name: comment.line.shebang.ig}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((//:))
        end: \s*$
        name: comment.line.doctype.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.doctype.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          0: {name: comment.line.doctype.ig}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((//))
        end: \s*$
        name: comment.line.number-sign.ig
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.ig}
          3: {name: comment.line.double-slash.ig}
          4: {name: punctuation.definition.comment.ig}
        endCaptures:
          0: {name: comment.line.number-sign.ig}
        patterns:
          - include: "#markdown-inline"

    repository:
      markdown-inline:
        patterns:
          - include: text.html.markdown#inline
      nested-block:
        begin: (#\[)\s*
        end: \s*(\]#)
        captures:
          1: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-block"
      nested-document-block:
        begin: (#{)\s*
        end: \s*(}#)
        captures:
          1: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      nested-inline:
        begin: (\()\s*
        end: \s*(\))
        name: comment.block.inline.ig
        captures:
          1: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      nested-special:
        begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.comment.ig}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-special"

  calls:
    patterns:
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          )
          \b\s+
          (?=
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [_\p{L}\p{M}\p{N}]+|\[(?!<)|<\|(?!>)(?=\|*)|<\+(?!>)(?=\+*))
        captures:
          1: {patterns: [{include: "#function-entities"}]}
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )
          [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
          )
          \b
          (?=
          !(?:\.=?)?\s*|
          \s+[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*

          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|pairof|keyof|valueof
          |length|delete|to|til|thru|at|by
          |n?and|x?n?or|not|parallel|series|spawn|discard
          |func?|function|proc|process|macro
          |let|var|val|const|declare
          |class|given|constraint|enum|relation|lattice
          |project|attribute|protocol|member|extend|fragment|interface|struct
          |module|package|namespace|object|record|label
          |raw|data|query|schema|style|trait|friend|alias|type
          |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
          |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
          |switch|case|fail|default|match|when|pass|fallthru
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|fixed|lock
          |(?:return|give|await|yield|throw|raise)s?
          |import|export|show|hide|open|close
          |from|where|join|equals?|[io]nto|order
          |take|drop|fold|scan|select|group|use|using
          )\b
          )

          [_\p{L}\p{M}\p{N}]+|\[<|
          (?:[!?~]?\.=?|[?!:]:=?|->)?\s*['"`\\({\[&&[^\[{]]
          )
        captures:
          1: {patterns: [{include: "#function-entities"}]}

  function-entities:
    patterns:
      - match: |
          (?x)\b(?:
          (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
          ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
          ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
          ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
          )

          |
          (?:# Objects and maps
          (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
          ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
          ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
          ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
          )
          (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

          |
          (?:# Regular variables
          (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
          ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
          ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
          ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.ig}
          2: {name: entity.name.tag.ig support.class.component.ig}
          3: {name: entity.name.class.builtin.ig}
          4: {name: entity.name.function.method.ig}
          5: {name: variable.other.global.ig}
          6: {name: variable.other.constant.object.ig}
          7: {name: variable.other.conditional.ig}
          8: {name: variable.other.object.ig}
          9: {name: entity.name.function.tagged-template.ig}
          10: {name: entity.name.type.ig}
          11: {name: entity.name.class.ig}
          12: {name: entity.name.function.ig}
      - include: $self

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|pairof|keyof|valueof
      |length|delete|to|til|thru|at|by
      |n?and|x?n?or|not|parallel|series|spawn|discard
      |func?|function|proc|process|macro
      |let|var|val|const|declare
      |class|given|constraint|enum|relation|lattice
      |project|attribute|protocol|member|extend|fragment|interface|struct
      |module|package|namespace|object|record|label
      |raw|data|query|schema|style|trait|friend|alias|type
      |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
      |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |import|export|show|hide|open|close
      |from|where|join|equals?|[io]nto|order
      |take|drop|fold|scan|select|group|use|using
      )\b
      )

      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )

      |
      (?:# Objects and maps
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?:# Regular variables
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.ig}
      2: {name: variable.other.constant.property.ig}
      3: {name: variable.other.property.static.ig}
      4: {name: variable.other.property.ig}
      5: {name: variable.other.global.ig}
      6: {name: variable.other.constant.object.ig}
      7: {name: variable.other.conditional.ig}
      8: {name: variable.other.object.ig}
      9: {name: variable.other.dollar.ig}
      10: {name: variable.other.constant.ig}
      11: {name: variable.other.class.ig}
      12: {name: variable.other.readwrite.ig}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops-builtin:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|['"`\\({\[\s])([\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+(?<![!:~.<=>])=)(?=$|['"`\\\s)}\]])
            name: keyword.operator.assignment.augmented.ig
          - comment: "assignment : :="
            match: (?<=^|['"`\\({\[\s])(:?=)(?=$|['"`\\\s)}\]])
            name: keyword.operator.assignment.ig
          - comment: arithmetic + - * ** *** / // /// % %% *> <*
            match: (?<=^|['"`\\({\[\s])((?<!<)\+(?!>|\++)|(?<!<)-(?!>|-+)|\*{1,3}|/{1,3}|%%?|\*+>|<\*+|<\*>)(?=$|['"`\\\s)}\]])
            name: keyword.operator.arithmetic.ig
          - comment: increment/decrement ++ --
            match: (?<=^|['"`\\({\[\s])((?:[+-])+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.successor.ig
          - comment: logical && || ^^ /\ / \ \\ etc.
            match: (?<=^|['"`\\({\[\s])((?:[&^]){2,}|\|\|+(?!>))(?=$|['"`\\\s)}\]])
            name: keyword.operator.logical.ig
          - comment: bitwise & | ^ ~
            match: (?<=^|['"`\\({\[\s])([&^]|\|(?!>)|~(?![!=<>]))(?=$|['"`\\\s)}\]])
            name: keyword.operator.bitwise.ig
          - comment: shift << >> <<< >>>>
            match: (?<=^|['"`\\({\[\s])(<{2,}(?![!:=+|*])|(?<![!:=+|*])>{2,})(?=$|['"`\\\s)}\]])
            name: keyword.operator.bitwise.shift.ig
          - comment: function composition +> <+
            match: (?<=^|['"`\\({\[\s])(<\++|\++>)(?=$|['"`\\\s)}\]])
            name: keyword.operator.compose.ig
          - comment: pipeline |> <|
            match: (?<=^|['"`\\({\[\s])(<\|+|\|+>)(?=$|['"`\\\s)}\]])
            name: keyword.operator.pipeline.ig
          - comment: "class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<"
            match: (?<=^|['"`\\({\[\s])([<>][!:][<>]?|[!:][<>])(?=$|['"`\\\s)}\]])
            name: keyword.operator.class.ig
          - comment: relational < > <= >=
            match: (?<=^|['"`\\({\[\s])([<>]=?)(?=$|['"`\\\s)}\]])
            name: keyword.operator.relational.ig
          - comment: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
            match: (?<=^|['"`\\({\[\s])(<>|=<|<(?:[/*+$])+>?|(?:[/*+$])+>)(?=$|['"`\\\s)}\]])
            name: keyword.operator.regexp.ig
          - comment: equality == != === !==
            match: (?<=^|['"`\\({\[\s])([!=]=+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.comparison.ig
          - comment: similarity operators
            match: (?<=^|['"`\\({\[\s])([!=~]+~|~[!=~]+|[<~>]+~[<~>]*|~[<~>]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.similarity.ig
          - comment: fat arrow-like => ==> <==
            match: (?<=^|['"`\\({\[\s])([=>]+|[<=]+|[=>]+[<=]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.arrow.fat.ig
          - comment: skinny arrow-like -> <- --> <--
            match: (?<=^|['"`\\({\[\s])([->]+|[<-]+|[->]+[<-]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.arrow.skinny.ig
          - comment: wavy arrow-like ~> <~ ~~> <~~
            match: (?<=^|['"`\\({\[\s])([~>]+|[<~]+|[~>]+[<~]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.arrow.wavy.ig
          - comment: null-coalescing ??
            match: (?<=^|['"`\\({\[\s])(\?{2,})(?=$|['"`\\\s)}\]])
            name: keyword.operator.null-coalescing.ig
          - comment: non-null coalescing !!
            match: (?<=^|['"`\\({\[\s])(!{2,})(?=$|['"`\\\s)}\]])
            name: keyword.operator.coalescing.ig
          - comment: "false coalescing ?:"
            match: (?<=^|['"`\\({\[\s])(\?+:+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.conditional.ig
          - comment: "true coalescing !:"
            match: (?<=^|['"`\\({\[\s])(!+:+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.ternary.ig
          - comment: "infix function $:"
            match: (?<=^|['"`\\({\[\s])(\$+:+|\${2,})(?=$|['"`\\\s)}\]])
            name: keyword.operator.macro.dollar.ig
          - comment: custom bitwise (leading &|^ ~)
            match: (?<=^|['"`\\({\[\s])([&|^~][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.bitwise.ig
          - comment: custom arithmetic (leading + - * / %)
            match: (?<=^|['"`\\({\[\s])([+\-*/%][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.arithmetic.ig
          - comment: "custom accessor (leading : .)"
            match: (?<=^|['"`\\({\[\s])([:.][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.prototype.ig
          - comment: custom equality (leading = !)
            match: (?<=^|['"`\\({\[\s])([!=][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.comparison.ig
          - comment: custom comparison (leading < >)
            match: (?<=^|['"`\\({\[\s])([<>][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.relational.ig
          - comment: custom optional (leading ?)
            match: (?<=^|['"`\\({\[\s])(\?[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.private.ig
          - comment: custom mathematical (leading Unicode category Sm)
            match: (?<=^|['"`\\({\[\s])([\p{Sm}&&[\x{80}-\x{10ffff}]][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*)(?=$|['"`\\\s)}\]])
            name: keyword.operator.math.ig
          - comment: custom currency-based (leading Unicode category Sc)
            match: (?<=^|['"`\\({\[\s])([\p{Sc}&&[^$]][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*)(?=$|['"`\\\s)}\]])
            name: keyword.operator.currency.ig
          - comment: custom ASCII (leading Unicode 0x80 to 0xFF)
            match: (?<=^|['"`\\({\[\s])([\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[\x{80}-\x{ff}]][\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*)(?=$|['"`\\\s)}\]])
            name: keyword.operator.ascii.ig
          - comment: other custom (leading anything not covered above)
            match: (?<=^|['"`\\({\[\s])([\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
            name: keyword.operator.infix.ig

      binary-ops:
        match: (?<=^|['"`\\\s({\[])([\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]+)(?=$|['"`\\\s)}\]])
        captures:
          0: {patterns: [{include: "#binary-ops-builtin"}]}

      unary-ops:
        patterns:
          - &transfix-operators
            comment: transfix binary operators
            match: |
              (?x)(?<=\b|^|[)}\]'"`\\\s])
              (?:([>.]\.[.<])|(\?\.=?)|(~\.=?)|(!\.=?)|((?:::|\.)=?)|(->))
              (?=\b|$|[({\['"`\\\s])
            captures:
              1: {name: keyword.operator.range.ig}
              2: {name: punctuation.accessor.optional.ig}
              3: {name: punctuation.accessor.cascade.ig}
              4: {name: punctuation.accessor.call.ig}
              5: {name: punctuation.accessor.ig}
              6: {name: punctuation.accessor.module.ig}

          - &prefix-operators
            comment: prefix operators
            match: |
              (?x)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]])#15
              (?=[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*
              [\p{L}\p{M}\p{N}({\[_,;'"`])
            name: keyword.operator.prefix.ig
            captures:
              1: {name: keyword.operator.module.all.ig}
              2: {name: keyword.operator.increment.ig}
              3: {name: keyword.operator.decrement.ig}
              4: {name: keyword.operator.intersection.ig}
              5: {name: keyword.operator.union.ig}
              6: {name: keyword.operator.sym-diff.ig}
              7: {name: keyword.operator.logical.ig}
              8: {name: keyword.operator.private.ig}
              9: {name: keyword.operator.decorator.ig}
              10: {name: keyword.operator.bitwise.not.ig}
              11: {name: keyword.operator.existential.ig}
              12: {name: keyword.operator.assignment.ig}
              13: {name: keyword.operator.pipeline.ig}
              14: {name: keyword.operator.private.ig}
              15: {name: keyword.operator.prefix.ig}

          - &suffix-operators
            comment: suffix operators
            match: |
              (?x)
              (?<=[\p{L}\p{M}\p{N})}\]_,;'"`]
              [\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]])#15
            name: keyword.operator.suffix.ig
            captures:
              1: {name: keyword.operator.module.all.ig}
              2: {name: keyword.operator.increment.ig}
              3: {name: keyword.operator.decrement.ig}
              4: {name: keyword.operator.intersection.ig}
              5: {name: keyword.operator.union.ig}
              6: {name: keyword.operator.sym-diff.ig}
              7: {name: punctuation.accessor.call.ig}
              8: {name: keyword.operator.private.ig}
              9: {name: keyword.operator.decorator.ig}
              10: {name: keyword.operator.bitwise.ig}
              11: {name: punctuation.accessor.optional.ig}
              12: {name: keyword.operator.assignment.ig}
              13: {name: keyword.operator.pipeline.ig}
              14: {name: keyword.operator.private.ig}
              15: {name: keyword.operator.suffix.ig}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*# prefix

              (?!
              \b(?:# don't match keywords
              in|of|as|is|new|infer|unset
              |typeof|nameof|sizeof|pairof|keyof|valueof
              |length|delete|to|til|thru|at|by
              |n?and|x?n?or|not|parallel|series|spawn|discard
              |func?|function|proc|process|macro
              |let|var|val|const|declare
              |class|given|constraint|enum|relation|lattice
              |project|attribute|protocol|member|extend|fragment|interface|struct
              |module|package|namespace|object|record|label
              |raw|data|query|schema|style|trait|friend|alias|type
              |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
              |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
              |switch|case|fail|default|match|when|pass|fallthru
              |try|retry|throw|raise|catch|rescue|finally
              |with|ref|defer|refer|show|hide|enter|exit
              |then|begin|end|debug|check|assert
              |break|continue|halt|skip|fixed|lock
              |(?:return|give|await|yield|throw|raise)s?
              |import|export|show|hide|open|close
              |from|where|join|equals?|[io]nto|order
              |take|drop|fold|scan|select|group|use|using
              )\b
              )

              [_\p{L}\p{M}\p{N}]+
              (?:[\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*# transfix
              [_\p{L}\p{M}\p{N}]+)*
              [\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]*# suffix
              )\s*([^(]|$|;))
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.compose.ig}
              2: {name: keyword.operator.pipeline.ig}
            patterns:
              - match: |
                  (?x)\s*\b

                  (?!
                  \s*\b
                  (?:# don't match keywords
                  new|unset|length|delete|to|til|thru|at|by
                  |n?and|x?n?or|not|parallel|series|spawn|discard
                  |func?|function|proc|process|macro
                  |let|var|val|const|declare
                  |class|given|constraint|enum|relation|lattice
                  |project|attribute|protocol|member|extend|fragment|interface|struct
                  |module|package|namespace|object|record|label
                  |raw|data|query|schema|style|trait|friend|alias|type
                  |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
                  |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
                  |switch|case|fail|default|match|when|pass|fallthru
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|fixed|lock
                  |(?:return|give|await|yield|throw|raise)s?
                  |import|export|show|hide|open|close
                  |from|where|join|equals?|[io]nto|order
                  |take|drop|fold|scan|select|group|use|using
                  )\b
                  )

                  (?:
                  (?:# Objects and maps
                  (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
                  ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
                  ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
                  ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
                  )
                  (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

                  |
                  (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
                  (?:# Properties (note all properties are by default, symbols)
                  (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
                  ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
                  ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
                  ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
                  )

                  |
                  (?:# Regular variables
                  (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
                  ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
                  ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
                  ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
                  )
                  )\b
                captures:
                  1: {name: variable.other.global.ig}
                  2: {name: variable.other.constant.object.ig}
                  3: {name: variable.other.conditional.ig}
                  4: {name: variable.other.object.ig}
                  5: {name: entity.name.tag.ig}
                  6: {name: entity.name.tag.ig support.class.component.ig}
                  7: {name: entity.name.class.builtin.ig}
                  8: {name: entity.name.function.method.ig}
                  9: {name: entity.name.function.tagged-template.ig}
                  10: {name: entity.name.type.ig}
                  11: {name: entity.name.class.ig}
                  12: {name: entity.name.function.ig}
              - *transfix-operators

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.ig}
            patterns:
              - begin: \s*(?=([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.ig}
            patterns:
              - begin: \s*(?=([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.ig}
            patterns:
              - begin: \s*(?=([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.ig
              - include: $self

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \s*\b
      (?:# don't match keywords
      new|unset|length|delete|to|til|thru|at|by
      |n?and|x?n?or|not|parallel|series|spawn|discard
      |func?|function|proc|process|macro
      |let|var|val|const|declare
      |class|given|constraint|enum|relation|lattice
      |project|attribute|protocol|member|extend|fragment|interface|struct
      |module|package|namespace|object|record|label
      |raw|data|query|schema|style|trait|friend|alias|type
      |if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard
      |for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat|do|redo
      |switch|case|fail|default|match|when|pass|fallthru
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|fixed|lock
      |(?:return|give|await|yield|throw|raise)s?
      |import|export|show|hide|open|close
      |from|where|join|equals?|[io]nto|order
      |take|drop|fold|scan|select|group|use|using
      )\b
      )

      (?:
      (?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )

      |
      (?:# Objects and maps
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?:# Regular variables
      (_+[\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*(?!_+)|[\p{L}\p{Nl}][\p{L}\p{M}\p{N}]*_+)|
      ([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)|
      ((?:[_\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\p{Ll}\p{M}\p{N}]*)+)|
      ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.ig}
      2: {name: entity.name.tag.ig}
      3: {name: entity.name.namespace.ig}
      4: {name: entity.name.interface.ig}
      5: {name: entity.name.tag.block.ig}
      6: {name: entity.name.tag.script.ig}
      7: {name: entity.name.tag.style.ig}
      8: {name: entity.name.tag.inline.ig}
      9: {name: entity.name.label.ig}
      10: {name: entity.name.project.ig}
      11: {name: entity.name.class.ig}
      12: {name: entity.name.type.ig}

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.ig
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.ig
              - match: (?<=^|[({\[])\s*([*+-](?:\s+[*+-])*)
                name: punctuation.definition.block.sequence.item.saga

        patterns:
          - begin: \s*(\{\|)
            end: \s*(\|\})
            captures:
              1: {name: punctuation.definition.mapping.ig}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\{)
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.ig}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.ig
        patterns:
          - begin: \s*(\(\|)
            end: \s*(\|\))
            captures:
              1: {name: punctuation.definition.parameters.ig}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.ig}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<=\b|^|[)}\]'"`\\\s])(:)(?=\b|$|[({\['"`\\\s])
                captures:
                  1: {name: punctuation.separator.slice.ig}
              - match: ","
                name: punctuation.separator.sequence.ig
        patterns:
          - begin: \s*(\[<)
            end: \s*(>\])
            captures:
              1: {name: punctuation.definition.typeparameters.ig}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[\|)
            end: \s*(\|\])
            captures:
              1: {name: punctuation.definition.sequence.ig}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.ig}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: |
          (?x)\s*\b
          (extends)\b\s*
        name: storage.type.extends.ig
      - match: |
          (?x)\s*\b
          (implements)\b\s*
        name: storage.type.implements.ig
      - match: |
          (?x)\s*\b
          ((?:type|name|size|key)of|only|infer|in|of|as|is)\b\s*
        name: keyword.operator.expression.$1.ig
      - match: |
          (?x)\s*\b
          (valueof)\b\s*
        name: keyword.operator.expression.valueof.ig

  type-operators:
    patterns:
      - comment: transfix binary operators
        match: |
          (?x)(?<=^|[)}\]_\p{L}\p{M}\p{N}'"`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[({\[_\p{L}\p{M}\p{N}'"`])
        captures:
          1: {name: punctuation.accessor.optional.ig}
          2: {name: punctuation.accessor.cascade.ig}
          3: {name: punctuation.accessor.call.ig}
          4: {name: punctuation.accessor.ig}
          5: {name: punctuation.accessor.module.ig}

      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          (\*)|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[_\p{L}\p{M}\p{N}'"\s])
        captures:
          1: {name: keyword.operator.sum.ig}
          2: {name: keyword.operator.difference.ig}
          3: {name: keyword.operator.product.ig}
          4: {name: keyword.operator.quotient.ig}
          5: {name: keyword.operator.remainder.ig}
          6: {name: keyword.operator.only.ig}
          7: {name: keyword.operator.maybe.ig}
          8: {name: keyword.operator.intersection.ig}
          9: {name: keyword.operator.union.ig}
          10: {name: keyword.operator.sym-diff.ig}
          11: {name: keyword.operator.negation.ig}
          12: {name: keyword.operator.macro.dollar.ig}
          13: {name: keyword.operator.private.ig}
          14: {name: keyword.operator.class.ig}

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=\O)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.ig}
    patterns:
      - include: "#types"

  types:
    patterns:
      - match: \s*(=>|==>|->|-->|~>|~~>)
        name: keyword.operator.type.function.ig
      - match: \s*(<=|<==|<-|<--|<~|<~~)
        name: keyword.operator.type.channel.ig
      - include: "#type-keywords"
      - include: "#modifier-keywords"
      - include: "#literals"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-brackets"
      - include: "#type-operators"

  modifier-keywords:
    match: |
      (?x)
      ((?:
      \s*(?:
      (?:# Access modifiers
      public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
      |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
      # Function or method modifiers
      |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
      |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
      |# Function or method modifiers
      (?:pre|in|post|suf|af|trans|interface)fix|
      (?:u|bi|ter|)nary|oper
      |# Decorators
      @(?:
      [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
      (?:(?:[?!~]?\.|[?!:]:|->)
      (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
      )
      )
      )
      \s*)*)
      (?=\s*\b
      (?:
      func?|function|proc|process|macro
      |let|va[rl]|const
      |class|extend
      |given|constraint
      |enum|relation|lattice
      |project
      |fragment|struct
      |interface|schema
      |module|package|lattice
      |namespace
      |object|record
      |raw
      |data|query
      |style
      |trait
      |type|alias
      |declare
      |do|redo
      )\b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - match: |
              (?x)\s*@(?:
              [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
              )\s*
            name: entity.name.class.decorator.ig
          - match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              )|
              (# Function or method modifiers
              [gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              )|
              (# Property modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              )
              )\b\s*
            captures:
              1: {name: storage.modifier.ig}
              2: {name: storage.type.accessor.ig}
              3: {name: storage.type.property.ig}

  support:
    patterns:
      - comment: Python
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
      - include: source.python#magic-variable-names

      - comment: PHP
      - include: source.php#support
      - include: source.php#class-builtin
      - include: "#support-php"

      - comment: JavaScript
      - include: source.js#support-objects
      - include: "#support-js"

      - comment: Swift
      - include: source.swift#builtin-properties
      - include: source.swift#builtin-types
      - include: source.swift#builtin-functions

      - comment: Other

  declaration-keywords:
    comment: clause keywords
    match: |
      (?x)\s*\b(?:
      (func?|function|proc|process|macro)# function
      |(let|va[rl]|const)# variable
      |(class|extend)# class
      |(given|constraint)# constraint
      |(enum|relation)# enumeration
      |(project|attribute)# project
      |(fragment|struct)# fragment
      |(interface|schema)# interface
      |(module|package)# module
      |(namespace|lattice)# function
      |(object|record)# object
      |(raw)# markup
      |(data|query)# indented GraphQL
      |(style)# inline CSS
      |(trait|friend)# trait
      |(type|alias)# type alias
      |(declare)# declaration
      )\b\s*
    captures:
      1: {name: storage.type.function.ig}
      2: {name: storage.type.ig}
      3: {name: storage.type.class.ig}
      4: {name: storage.type.constraint.ig}
      5: {name: storage.type.enum.ig}
      6: {name: storage.type.project.ig}
      7: {name: storage.type.fragment.ig}
      8: {name: storage.type.interface.ig}
      9: {name: storage.type.module.ig}
      10: {name: storage.type.namespace.ig}
      11: {name: storage.type.object.ig}
      12: {name: storage.type.raw.ig}
      13: {name: storage.type.schema.ig}
      14: {name: storage.type.style.ig}
      15: {name: storage.type.trait.ig}
      16: {name: keyword.other.typedef.ig}
      17: {name: keyword.other.declare.ig}

  general-keywords:
    comment: general keywords
    match: |
      (?x)\s*\b(?:
      (if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard)#1
      |(for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat)#2
      |(switch|case|fail|default|fallthru)#3
      |(match|when|pass)#4
      |(try|retry|throw|raise|catch|rescue|finally)#5
      |(with)#6
      |(ref|[dr]efer|show|hide|enter|exit)#7
      |(then)#8
      |(debug|check|assert)#9
      |(break|continue|halt|skip|return|give|label|await|yield|throw|raise|yield\b\s+\bfrom)# 10
      |((?:im|ex)port|show|hide)# 11
      |(parallel|series|spawn|discard)#12
      |(do|redo)#13
      |(begin|end)#14
      )\b\s*
    captures:
      1: {name: keyword.control.conditional.ig}
      2: {name: keyword.control.loop.ig}
      3: {name: keyword.control.switch.ig}
      4: {name: keyword.control.match.ig}
      5: {name: keyword.control.error.ig}
      6: {name: keyword.control.with.ig}
      7: {name: keyword.control.ig}
      8: {name: keyword.control.then.ig}
      9: {name: keyword.other.$10.ig}
      10: {name: keyword.control.flow.ig}
      11: {name: keyword.control.module.ig}
      12: {name: keyword.control.thread.ig}
      13: {name: keyword.control.do.ig}
      14: {name: keyword.control.$14.ig}

  expression-keywords:
    comment: expression keywords
    match: |
      (?x)\s*\b(?:
      (in|of|as|is|new|infer
      |typeof|nameof|sizeof|keyof|pairof|valueof)
      |(length)|(delete)|(to|til|thru|at|by)|(unset)
      |(n?and|x?n?or|not)
      )\b\s*
    captures:
      1: {name: keyword.operator.expression.$1.ig}
      2: {name: keyword.operator.expression.length.ig}
      3: {name: keyword.operator.expression.delete.ig}
      4: {name: keyword.operator.expression.range.ig}
      5: {name: keyword.operator.expression.void.ig}
      6: {name: keyword.operator.expression.logical.ig}

  keywords:
    patterns:
      - match: \s*\b(let|va[rl]|const)\b\s*
        name: storage.type.ig
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"
      - include: "#query-expression"
      - include: "#module-expression"
      - include: "#control-expression"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: \s*\b(halt|skip|break|continue|goto|label)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.flow.ig}
        patterns:
          - match: \s*([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s*
            captures:
              1: {name: constant.other.label.ig}

      module-expression:
        applyEndPatternLast: 1
        begin: \s*\b(import|export|open|close|use|using)\b\s*
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.module.ig}
        patterns:
          - include: "#modifier-keywords"
          - include: "#type-keywords"
          - match: \s*\b(from|to|as|all|any|show|hide|to|n?and|x?n?or|not)\b\s*
            name: keyword.control.module.ig
          - match: \s*\*
            name: keyword.operator.module.all.ig
          - include: "#module-string"
          - include: "#type-names"
          - include: "#custom-types"
          - include: "#types"
          - include: "#operators"
          - include: "#punctuation"
        repository:
          module-string:
            patterns:
              - comment: single quoted raw string
                begin: \s*('{3,})
                contentName: string.quoted.template.ig
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.ig}
                patterns:
                  - include: "#embedded-raw"
              - comment: simple single quoted raw string
                begin: \s*(')
                contentName: string.quoted.template.ig
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.ig}
                patterns:
                  - match: "''"
                    name: constant.character.escape.ig
                  - include: "#embedded-raw"
              - comment: double quoted standard string
                begin: \s*("{3,}|")
                contentName: string.quoted.module.ig
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.ig}
                patterns:
                  - include: "#string-escapes"

      query-expression:
        patterns:
          - begin: \s*\b(from)\b\s*
            end: \s*\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.ig}
            patterns:
              - include: $self
          - match: \s*\b((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.ig
          - begin: \s*\b(group)\b\s*
            end: \s*\b(by)\b\s*
            captures:
              1: {name: keyword.query.ig}
            patterns:
              - include: $self
          - begin: \s*\b(join)\b\s*
            end: \s*\b(in|of)\b\s*
            captures:
              1: {name: keyword.query.ig}
            patterns:
              - include: $self
          - match: \s*\b(equals?|[io]nto)\b\s*
            name: keyword.query.ig
          - match: \s*\b((\b(order)\b)\s*(\b((a|de)sc)\b)?\s*(\b(by)\b)?)\b\s*
            name: keyword.query.ig
          - match: \s*\b(select)\b\s*
            name: keyword.query.ig
          - match: \s*\b((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.ig
          - match: \s*\b(where)\b\s*
            name: keyword.query.ig

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.ig}
    patterns: &function-params
      - include: "#clauses"
      - include: "#keywords"
      - match: (?i)\s*\?[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.optional.ig
      - match: (?i)\s*\*[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.spread.ig
      - match: (?i)\s*[&~][_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.name.ig
      - match: (?i)\s*\%[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.reference.ig
      - match: (?i)\s*\$[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.other.ig
      - match: (?i)\s*\b[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*\b\s*
        name: variable.parameter.ig
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#definition-keywords"
      - include: "#code-block"
      - include: "#type-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.ig
      - include: "#operators"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{Po}\p{Pd}\p{Pi}\p{Pf}\p{Pc}&&[^_,;'"`\\]]))
        end: (?=\O)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.ig}
        patterns:
          - include: "#types"

  declarations:
    patterns:
      - include: "#function"
      - include: "#raw"
      - include: "#schema"
      - include: "#style"
      - include: "#class"
      - include: "#enum"
      - include: "#interface"
      - include: "#trait"
      - include: "#fragment"
      - include: "#module"
      - include: "#namespace"
      - include: "#object"
      - include: "#constraint"
      - include: "#project"
      - include: "#protocol"

    repository:
      class:
        applyEndPatternLast: 1
        begin: \s*\b(class|extend)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.class.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.ig
      constraint:
        applyEndPatternLast: 1
        begin: \s*\b(given|constraint)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.constraint.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.constraint.ig
      enum:
        applyEndPatternLast: 1
        begin: \s*\b(enum|relation)\b\s*
        end: (?<=})|(?=;)|$|^
        name: meta.enum.declaration.ig
        beginCaptures:
          1: {name: storage.type.enum.ig}
          2: {name: entity.name.enum.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.ig
      fragment:
        applyEndPatternLast: 1
        begin: \s*\b(fragment|struct)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.fragment.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.fragment.ig
      function:
        applyEndPatternLast: 1
        begin: \s*\b(func?|function|proc|process|macro)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.function.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.ig
      interface:
        applyEndPatternLast: 1
        begin: \s*\b(interface|schema)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.interface.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.interface.ig
      module:
        applyEndPatternLast: 1
        begin: \s*\b(module|package)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.module.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.ig
      namespace:
        applyEndPatternLast: 1
        begin: \s*\b(namespace|lattice)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.namespace.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.namespace.ig
      object:
        applyEndPatternLast: 1
        begin: \s*\b(object|record)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.object.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.ig
      protocol:
        applyEndPatternLast: 1
        begin: \s*\b(protocol|member)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.protocol.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.protocol.ig
      project:
        applyEndPatternLast: 1
        begin: \s*\b(project|attribute)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.protocol.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.project.ig
      raw:
        applyEndPatternLast: 1
        begin: \s*\b(raw)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.raw.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.raw.ig
      schema:
        applyEndPatternLast: 1
        begin: \s*\b(data|query)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.schema.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.schema.ig
      style:
        applyEndPatternLast: 1
        begin: \s*\b(style)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.style.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.ig
      trait:
        applyEndPatternLast: 1
        begin: \s*\b(trait|friend)\b\s*
        end: (?<=})|(?=;)|$|^
        beginCaptures:
          1: {name: storage.type.trait.ig}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.ig

  clauses:
    patterns:
      - include: "#arguments-clause"
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      arguments-clause:
        patterns:
          - begin: |
              (?x)
              (?<=(?:[({\[]\|?|\b(?:#keywords
              (?:re)?do|equals?|[io]nto|select|where
              |(?:\b(?:fold|scan)\b)\s*(?:\b(?:left|right)\b)?\s*(?:\b(?:by|while|until|with)\b)?
              |(?:\b(?:take|drop)\b)\s*(?:\b(?:left|right|init|head|tail|last)\b)?\s*(?:\b(?:by|while|until|with)\b)?
              )\b)\s*)
              (\|)
              (?!\|)
            captures:
              1: {name: punctuation.separator.arguments.ig}
            end: (?<!\|)(\|)(?!\|)
            patterns:
              - include: "#function-params"

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.ig}
        patterns:
          - include: "#function-params"

      method-clause:
        patterns:
          - begin: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s+
              (:?=)\s+
              (

              (?:(?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
              )
              )\s*\b)*

              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.method.ig}
              2: {name: keyword.operator.assignment.ig}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.ig}
            endCaptures:
              1: {name: punctuation.separator.arguments.ig}
            patterns:
              - include: "#function-params"
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.=?|[?!:]:=?|->)
              ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s+
              (:?=)\s+

              ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s+
              (:?=)\s+

              ((?:
              \s*(?:
              (?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              func?|function|proc|process|macro
              )\b
              )
            captures:
              1: {name: entity.name.function.method.ig}
              2: {name: keyword.operator.assignment.ig}
              3: {patterns: *modifier-keywords}

      function-clause:
        patterns:
          - begin: |
              (?x)\s*
              ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s+
              (:?=)\s+
              (

              (?:(?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
              )
              )\s*\b)*

              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.ig}
              2: {name: keyword.operator.assignment.ig}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.ig}
            endCaptures:
              1: {name: punctuation.separator.arguments.ig}
            patterns:
              - include: "#function-params"
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\s+
              (:?=)\s+

              ((?:
              \s*(?:
              (?:# Access modifiers
              public|private|protected|readonly|a?sync|inline|lazy|eager|transparent|transient|partial|whole
              |lawful|rogue|early|late|unique|handle|override|abstract|volatile|static|dynamic|threadsafe|final
              # Function or method modifiers
              |[gs]etter|[dr]efer|recursive|generator|operator|(?:im)?(?:mut|pure)|local|global|native|opaque
              |(?:un)?(?:signed|safe|checked|locked|fixed|sized|bound)
              |# Function or method modifiers
              (?:pre|in|post|suf|af|trans|interface)fix|
              (?:u|bi|ter|)nary|oper
              |# Decorators
              @(?:
              [_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*
              (?:(?:[?!~]?\.|[?!:]:|->)
              (?:(?:[_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)))*
              )
              ))
              \s*)*)
              (?=\s*\b
              (?:
              func?|function|proc|process|macro
              )\b
              )
            captures:
              1: {name: entity.name.function.ig}
              2: {name: keyword.operator.assignment.ig}
              3: {patterns: *modifier-keywords}

      # variable-clause:
      #   applyEndPatternLast: 1
      #   begin: \s*\b(var|let)\b
      #   end: (?=\O)|$
      #   beginCaptures:
      #     1: {name: storage.type.ig}
      #   patterns:
      #     - include: $self

      constant-clause:
        applyEndPatternLast: 1
        begin: \s*\b(val|const)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: storage.type.ig}
        patterns:
          - match: *entity-name
            captures:
              1: {name: variable.other.constant.ig}

      new-clause:
        applyEndPatternLast: 1
        begin: \s*\b(new)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.ig}
        patterns:
          - match: \s*([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)
            name: entity.name.instance.ig
          - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: \s*\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.ig}
            patterns:
              - include: "#types"
          - begin: \s*\b(type|alias)\b\s*\b([_\p{L}\p{Nl}][_\p{L}\p{M}\p{N}]*)\b\s*(?:(:?=)|(:))?\s*
            end: ^(?=\S)|(?!\G)
            name: meta.type-alias.ig
            beginCaptures:
              1: {name: keyword.other.typedef.ig}
              2: {patterns: [{include: "#types"}]}
              3: {name: keyword.operator.assignment.ig}
              4: {name: punctuation.separator.colon.ig}
            patterns:
              - begin: ^((\p{Zs})+)(?!\2)
                end: ^(?!\1|\s*$)
                name: meta.type-alias.ig
                patterns:
                  - include: "#types"
              - include: $self
          - applyEndPatternLast: 1
            begin: \s*\b(type|alias)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.typedef.ig}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.ig}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: \s*\b(declare)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.declare.ig}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.ig}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*\b((?:return|give|await|yield|throw|raise)s)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.modifier.ig}
            patterns:
              - include: "#types"

      case-clause:
        begin: \s*\b(case|fail|default)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        beginCaptures:
          1: {name: keyword.control.switch.ig}
        patterns:
          - include: "#code-block"
          - include: $self

      catch-clause:
        begin: \s*\b(try|retry|catch|rescue|finally)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.catch.ig
        beginCaptures:
          1: {name: keyword.control.error.ig}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.ig}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.error.ig
              - include: "#code-block"
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.error.ig
          - include: "#code-block"
          - include: $self

      thread-clause:
        begin: \s*\b(parallel|series|spawn|discard|fixed|lock)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.thread.ig
        beginCaptures:
          1: {name: keyword.control.thread.ig}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.ig}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.thread.ig
              - include: "#code-block"
              - include: $self
          - match: \s*\b(as)\b
            name: keyword.control.thread.ig
          - include: "#code-block"
          - include: $self

      do-clause:
        begin: \s*\b(do|redo)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.do.ig
        beginCaptures:
          1: {name: keyword.control.do.ig}
        patterns:
          - include: "#code-block"
          - include: $self

      for-clause:
        begin: \s*\b(for|each|repeat\s*\b\s*(?:while|until)?|while|until|repeat)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.for.ig
        beginCaptures:
          1: {name: keyword.control.loop.ig}
        patterns:
          - match: \s*\b(in|of|to|til|thru|at|by)\b
            name: keyword.control.loop.ig
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.ig}
            patterns:
              - match: \s*\b(in|of|to|til|thru|at|by)\b
                name: keyword.control.loop.ig
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      if-clause:
        begin: \s*\b(if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.if.ig
        beginCaptures:
          1: {name: keyword.control.conditional.ig}
        patterns:
          - include: "#code-block"
          - include: $self

      match-clause:
        begin: \s*\b(match)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.match.ig
        beginCaptures:
          1: {name: keyword.control.match.ig}
        patterns:
          - include: "#code-block"
          - include: $self

      switch-clause:
        begin: \s*\b(switch)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.switch.ig
        beginCaptures:
          1: {name: keyword.control.switch.ig}
        patterns:
          - include: "#code-block"
          - include: $self

      when-clause:
        begin: \s*\b(when)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        beginCaptures:
          1: {name: keyword.control.match.ig}
        patterns:
          - applyEndPatternLast: 1
            begin: \s*\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.ig}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*\b((?:return|give|await|yield|throw|raise)s?)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.ig}
            patterns:
              - include: "#types"
          - begin: \s*\b(if|else\s*(?:if|unless)?|els?if|ell?ess|unless|guard)\b
            end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.ig}
            beginCaptures:
              1: {name: keyword.control.match.ig}
            patterns:
              - include: "#code-block"
              - include: $self
          - include: "#type-operators"
          - include: "#code-block"
          - include: $self

      with-clause:
        begin: \s*\b(with)\b
        end: (?<=})|(?=;|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.ig}
        name: meta.with.ig
        beginCaptures:
          1: {name: keyword.control.with.ig}
        patterns:
          - begin: \s*
            end: \s*(?=[{,])
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.with.ig
              - include: "#code-block"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.ig}
            patterns:
              - match: \s*\b(as)\b
                name: keyword.control.with.ig
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#semicolon"
      - include: "#double-semi"

    repository:
      line-continuation:
        match: (\\)\s*(?=#|$)
        captures:
          1: {name: punctuation.separator.continuation.line.ig}
      comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.separator.comma.ig}
      right-arrow:
        match: (?:^|['"`\\({\[\s]*)(->)(?:$|['"`\\\s)}\]])
        captures:
          1: {name: punctuation.definition.arrow.ig}
      double-semi:
        match: \s*(;;)
        captures:
          1: {name: punctuation.terminator.statement.ig}
      semicolon:
        match: \s*(;)(?!;)
        captures:
          1: {name: punctuation.terminator.expression.ig}

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  code-block:
    patterns:
      - begin: (\{\|)\s*
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.function.ig}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.ig}
        patterns:
          - include: $self

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.ig
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.ig
          - match: (?<=^|[({\[])\s*([*+-](?:\s+[*+-])*)
            name: punctuation.definition.block.sequence.item.saga

    patterns:
      - begin: (\{\|)\s*
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.mapping.ig}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.ig}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.ig

    patterns:
      - begin: (\(\|)\s*
        end: \s*(\|\))
        captures:
          1: {name: punctuation.definition.parameters.ig}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.ig}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<=\b|^|[)}\]'"`\\\s])(:)(?=\b|$|[({\['"`\\\s])
            captures:
              1: {name: punctuation.separator.slice.ig}
          - match: ","
            name: punctuation.separator.sequence.ig

    patterns:
      - begin: (\[<)\s*
        end: \s*(>\])
        captures:
          1: {name: punctuation.definition.typeparameters.ig}
        patterns:
          - include: "#types"
          - include: $self
      - begin: (\[\|)\s*
        end: \s*(\|\])
        captures:
          1: {name: punctuation.definition.sequence.ig}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.ig}
        patterns:
          - include: "#punctuation"
          - include: $self

  support-js:
    patterns:
      - begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<=\.)\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.mutator.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.error.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(debugger)\b
        captures:
          1: {name: keyword.other.js}
      - match: (?<!\.)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.js}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.js}
      - begin: (?<!\.)\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.console.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.console.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.process.js}
      - begin: (?<!\.)\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.process.js}
        patterns:
          - include: "#round-brackets"
      - match: (((?<!\.)\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.module.js}
      - match: (?<!\.)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.js}
      - begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.node.js}
        patterns:
          - include: "#round-brackets"

  support-php:
    patterns:
      - match: (?i)\b(TRUE|FALSE|NULL|__(FILE|DIR|FUNCTION|CLASS|METHOD|LINE|NAMESPACE)__|ON|OFF|YES|NO|NL|BR|TAB)\b
        name: constant.language.php
      - match: >-
          (?x)

          (\\)?\b

          (DEFAULT_INCLUDE_PATH

          |EAR_(INSTALL|EXTENSION)_DIR

          |E_(ALL|COMPILE_(ERROR|WARNING)|CORE_(ERROR|WARNING)|DEPRECATED|ERROR|NOTICE
          |PARSE|RECOVERABLE_ERROR|STRICT|USER_(DEPRECATED|ERROR|NOTICE|WARNING)|WARNING)
          |PHP_(ROUND_HALF_(DOWN|EVEN|ODD|UP)|(MAJOR|MINOR|RELEASE)_VERSION|MAXPATHLEN
          |BINDIR|SHLIB_SUFFIX|SYSCONFDIR|SAPI|CONFIG_FILE_(PATH|SCAN_DIR)
          |INT_(MAX|SIZE)|ZTS|OS|OUTPUT_HANDLER_(START|CONT|END)|DEBUG|DATADIR
          |URL_(SCHEME|HOST|USER|PORT|PASS|PATH|QUERY|FRAGMENT)|PREFIX
          |EXTRA_VERSION|EXTENSION_DIR|EOL|VERSION(_ID)?
          |WINDOWS_(NT_(SERVER|DOMAIN_CONTROLLER|WORKSTATION)
          |VERSION_(MAJOR|MINOR)|BUILD|SUITEMASK|SP_(MAJOR|MINOR)
          |PRODUCTTYPE|PLATFORM)
          |LIBDIR|LOCALSTATEDIR)
          |STD(ERR|IN|OUT)|ZEND_(DEBUG_BUILD|THREAD_SAFE))

          \b
        name: support.constant.core.php
        captures:
          1: {name: punctuation.separator.inheritance.php}
      - match: >-
          (?x)

          (\\)?\b

          (__COMPILER_HALT_OFFSET__|AB(MON_(1|2|3|4|5|6|7|8|9|10|11|12)|DAY[1-7])

          |AM_STR|ASSERT_(ACTIVE|BAIL|CALLBACK_QUIET_EVAL|WARNING)|ALT_DIGITS

          |CASE_(UPPER|LOWER)|CHAR_MAX|CONNECTION_(ABORTED|NORMAL|TIMEOUT)|CODESET|COUNT_(NORMAL|RECURSIVE)

          |CREDITS_(ALL|DOCS|FULLPAGE|GENERAL|GROUP|MODULES|QA|SAPI)

          |CRYPT_(BLOWFISH|EXT_DES|MD5|SHA(256|512)|SALT_LENGTH|STD_DES)|CURRENCY_SYMBOL

          |D_(T_)?FMT|DATE_(ATOM|COOKIE|ISO8601|RFC(822|850|1036|1123|2822|3339)|RSS|W3C)

          |DAY_[1-7]|DECIMAL_POINT|DIRECTORY_SEPARATOR

          |ENT_(COMPAT|IGNORE|(NO)?QUOTES)|EXTR_(IF_EXISTS|OVERWRITE|PREFIX_(ALL|IF_EXISTS|INVALID|SAME)|REFS|SKIP)

          |ERA(_(D_(T_)?FMT)|T_FMT|YEAR)?|FRAC_DIGITS|GROUPING|HASH_HMAC|HTML_(ENTITIES|SPECIALCHARS)

          |INF|INFO_(ALL|CREDITS|CONFIGURATION|ENVIRONMENT|GENERAL|LICENSEMODULES|VARIABLES)

          |INI_(ALL|CANNER_(NORMAL|RAW)|PERDIR|SYSTEM|USER)|INT_(CURR_SYMBOL|FRAC_DIGITS)

          |LC_(ALL|COLLATE|CTYPE|MESSAGES|MONETARY|NUMERIC|TIME)|LOCK_(EX|NB|SH|UN)

          |LOG_(ALERT|AUTH(PRIV)?|CRIT|CRON|CONS|DAEMON|DEBUG|EMERG|ERR|INFO|LOCAL[1-7]|LPR|KERN|MAIL
          |NEWS|NODELAY|NOTICE|NOWAIT|ODELAY|PID|PERROR|WARNING|SYSLOG|UCP|USER)
          |M_(1_PI|SQRT(1_2|2|3|PI)|2_(SQRT)?PI|PI(_(2|4))?|E(ULER)?|LN(10|2|PI)|LOG(10|2)E)

          |MON_(1|2|3|4|5|6|7|8|9|10|11|12|DECIMAL_POINT|GROUPING|THOUSANDS_SEP)

          |N_(CS_PRECEDES|SEP_BY_SPACE|SIGN_POSN)|NAN|NEGATIVE_SIGN|NO(EXPR|STR)

          |P_(CS_PRECEDES|SEP_BY_SPACE|SIGN_POSN)|PM_STR|POSITIVE_SIGN

          |PATH(_SEPARATOR|INFO_(EXTENSION|(BASE|DIR|FILE)NAME))|RADIXCHAR

          |SEEK_(CUR|END|SET)|SORT_(ASC|DESC|LOCALE_STRING|REGULAR|STRING)|STR_PAD_(BOTH|LEFT|RIGHT)

          |T_FMT(_AMPM)?|THOUSEP|THOUSANDS_SEP

          |UPLOAD_ERR_(CANT_WRITE|EXTENSION|(FORM|INI)_SIZE|NO_(FILE|TMP_DIR)|OK|PARTIAL)

          |YES(EXPR|STR))

          \b
        name: support.constant.std.php
        captures:
          1: {name: punctuation.separator.inheritance.php}
      - match: >-
          (?x)

          (\\)?\b

          (GLOB_(MARK|BRACE|NO(SORT|CHECK|ESCAPE)|ONLYDIR|ERR|AVAILABLE_FLAGS)

          |XML_(SAX_IMPL|(DTD|DOCUMENT(_(FRAG|TYPE))?|HTML_DOCUMENT|NOTATION|NAMESPACE_DECL|PI|COMMENT|DATA_SECTION|TEXT)_NODE
          |OPTION_(SKIP_(TAGSTART|WHITE)|CASE_FOLDING|TARGET_ENCODING)
          |ERROR_((BAD_CHAR|(ATTRIBUTE_EXTERNAL|BINARY|PARAM|RECURSIVE)_ENTITY)_REF|MISPLACED_XML_PI|SYNTAX|NONE
          |NO_(MEMORY|ELEMENTS)|TAG_MISMATCH|INCORRECT_ENCODING|INVALID_TOKEN|DUPLICATE_ATTRIBUTE
          |UNCLOSED_(CDATA_SECTION|TOKEN)|UNDEFINED_ENTITY|UNKNOWN_ENCODING|JUNK_AFTER_DOC_ELEMENT
          |PARTIAL_CHAR|EXTERNAL_ENTITY_HANDLING|ASYNC_ENTITY)
          |ENTITY_(((REF|DECL)_)?NODE)|ELEMENT(_DECL)?_NODE|LOCAL_NAMESPACE|ATTRIBUTE_(NMTOKEN(S)?|NOTATION|NODE)
          |CDATA|ID(REF(S)?)?|DECL_NODE|ENTITY|ENUMERATION)
          |MHASH_(RIPEMD(128|160|256|320)|GOST|MD(2|4|5)|SHA(1|224|256|384|512)|SNEFRU256|HAVAL(128|160|192|224|256)
          |CRC23(B)?|TIGER(128|160)?|WHIRLPOOL|ADLER32)
          |MYSQL_(BOTH|NUM|CLIENT_(SSL|COMPRESS|IGNORE_SPACE|INTERACTIVE|ASSOC))

          |MYSQLI_(REPORT_(STRICT|INDEX|OFF|ERROR|ALL)|REFRESH_(GRANT|MASTER|BACKUP_LOG|STATUS|SLAVE|HOSTS|THREADS|TABLES|LOG)
          |READ_DEFAULT_(FILE|GROUP)|(GROUP|MULTIPLE_KEY|BINARY|BLOB)_FLAG|BOTH
          |STMT_ATTR_(CURSOR_TYPE|UPDATE_MAX_LENGTH|PREFETCH_ROWS)|STORE_RESULT
          |SERVER_QUERY_(NO_((GOOD_)?INDEX_USED)|WAS_SLOW)|SET_(CHARSET_NAME|FLAG)
          |NO_(DEFAULT_VALUE_FLAG|DATA)|NOT_NULL_FLAG|NUM(_FLAG)?
          |CURSOR_TYPE_(READ_ONLY|SCROLLABLE|NO_CURSOR|FOR_UPDATE)
          |CLIENT_(SSL|NO_SCHEMA|COMPRESS|IGNORE_SPACE|INTERACTIVE|FOUND_ROWS)
          |TYPE_(GEOMETRY|((MEDIUM|LONG|TINY)_)?BLOB|BIT|SHORT|STRING|SET|YEAR|NULL|NEWDECIMAL|NEWDATE|CHAR
          |TIME(STAMP)?|TINY|INT24|INTERVAL|DOUBLE|DECIMAL|DATE(TIME)?|ENUM|VAR_STRING|FLOAT|LONG(LONG)?)
          |TIME_STAMP_FLAG|INIT_COMMAND|ZEROFILL_FLAG|ON_UPDATE_NOW_FLAG
          |OPT_(NET_((CMD|READ)_BUFFER_SIZE)|CONNECT_TIMEOUT|INT_AND_FLOAT_NATIVE|LOCAL_INFILE)
          |DEBUG_TRACE_ENABLED|DATA_TRUNCATED|USE_RESULT|(ENUM|(PART|PRI|UNIQUE)_KEY|UNSIGNED)_FLAG
          |ASSOC|ASYNC|AUTO_INCREMENT_FLAG)
          |MCRYPT_(RC(2|6)|RIJNDAEL_(128|192|256)|RAND|GOST|XTEA|MODE_(STREAM|NOFB|CBC|CFB|OFB|ECB)|MARS
          |BLOWFISH(_COMPAT)?|SERPENT|SKIPJACK|SAFER(64|128|PLUS)|CRYPT|CAST_(128|256)|TRIPLEDES|THREEWAY
          |TWOFISH|IDEA|(3)?DES|DECRYPT|DEV_(U)?RANDOM|PANAMA|ENCRYPT|ENIGNA|WAKE|LOKI97|ARCFOUR(_IV)?)
          |STREAM_(REPORT_ERRORS|MUST_SEEK|MKDIR_RECURSIVE|BUFFER_(NONE|FULL|LINE)|SHUT_(RD)?WR
          |SOCK_(RDM|RAW|STREAM|SEQPACKET|DGRAM)|SERVER_(BIND|LISTEN)
          |NOTIFY_(REDIRECTED|RESOLVE|MIME_TYPE_IS|SEVERITY_(INFO|ERR|WARN)|COMPLETED|CONNECT|PROGRESS
          |FILE_SIZE_IS|FAILURE|AUTH_(REQUIRED|RESULT))
          |CRYPTO_METHOD_((SSLv2(3)?|SSLv3|TLS)_(CLIENT|SERVER))|CLIENT_((ASYNC_)?CONNECT|PERSISTENT)
          |CAST_(AS_STREAM|FOR_SELECT)|(IGNORE|IS)_URL|IPPROTO_(RAW|TCP|ICMP|IP|UDP)|OOB
          |OPTION_(READ_(BUFFER|TIMEOUT)|BLOCKING|WRITE_BUFFER)|URL_STAT_(LINK|QUIET)|USE_PATH
          |PEEK|PF_(INET(6)?|UNIX)|ENFORCE_SAFE_MODE|FILTER_(ALL|READ|WRITE))
          |SUNFUNCS_RET_(DOUBLE|STRING|TIMESTAMP)

          |SQLITE_(READONLY|ROW|MISMATCH|MISUSE|BOTH|BUSY|SCHEMA|NOMEM|NOTFOUND|NOTADB|NOLFS|NUM|CORRUPT
          |CONSTRAINT|CANTOPEN|TOOBIG|INTERRUPT|INTERNAL|IOERR|OK|DONE|PROTOCOL|PERM|ERROR|EMPTY
          |FORMAT|FULL|LOCKED|ABORT|ASSOC|AUTH)
          |SQLITE3_(BOTH|BLOB|NUM|NULL|TEXT|INTEGER|OPEN_(READ(ONLY|WRITE)|CREATE)|FLOAT_ASSOC)

          |CURL(M_(BAD_((EASY)?HANDLE)|CALL_MULTI_PERFORM|INTERNAL_ERROR|OUT_OF_MEMORY|OK)
          |MSG_DONE|SSH_AUTH_(HOST|NONE|DEFAULT|PUBLICKEY|PASSWORD|KEYBOARD)
          |CLOSEPOLICY_(SLOWEST|CALLBACK|OLDEST|LEAST_(RECENTLY_USED|TRAFFIC)
          |INFO_(REDIRECT_(COUNT|TIME)|REQUEST_SIZE|SSL_VERIFYRESULT|STARTTRANSFER_TIME
          |(SIZE|SPEED)_(DOWNLOAD|UPLOAD)|HTTP_CODE|HEADER_(OUT|SIZE)|NAMELOOKUP_TIME
          |CONNECT_TIME|CONTENT_(TYPE|LENGTH_(DOWNLOAD|UPLOAD))|CERTINFO|TOTAL_TIME
          |PRIVATE|PRETRANSFER_TIME|EFFECTIVE_URL|FILETIME)
          |OPT_(RESUME_FROM|RETURNTRANSFER|REDIR_PROTOCOLS|REFERER|READ(DATA|FUNCTION)|RANGE|RANDOM_FILE
          |MAX(CONNECTS|REDIRS)|BINARYTRANSFER|BUFFERSIZE
          |SSH_(HOST_PUBLIC_KEY_MD5|(PRIVATE|PUBLIC)_KEYFILE)|AUTH_TYPES)
          |SSL(CERT(TYPE|PASSWD)?|ENGINE(_DEFAULT)?|VERSION|KEY(TYPE|PASSWD)?)
          |SSL_(CIPHER_LIST|VERIFY(HOST|PEER))
          |STDERR|HTTP(GET|HEADER|200ALIASES|_VERSION|PROXYTUNNEL|AUTH)
          |HEADER(FUNCTION)?|NO(BODY|SIGNAL|PROGRESS)|NETRC|CRLF|CONNECTTIMEOUT(_MS)?
          |COOKIE(SESSION|JAR|FILE)?|CUSTOMREQUEST|CERTINFO|CLOSEPOLICY|CA(INFO|PATH)|TRANSFERTEXT
          |TCP_NODELAY|TIME(CONDITION|OUT(_MS)?|VALUE)|INTERFACE|INFILE(SIZE)?|IPRESOLVE
          |DNS_(CACHE_TIMEOUT|USE_GLOBAL_CACHE)|URL|USER(AGENT|PWD)|UNRESTRICTED_AUTH|UPLOAD
          |PRIVATE|PROGRESSFUNCTION|PROXY(TYPE|USERPWD|PORT|AUTH)?|PROTOCOLS|PORT
          |POST(REDIR|QUOTE|FIELDS)?|PUT|EGDSOCKET|ENCODING|VERBOSE|KRB4LEVEL|KEYPASSWD|QUOTE|FRESH_CONNECT
          |FTP(APPEND|LISTONLY|PORT|SSLAUTH)
          |FTP_(SSL|SKIP_PASV_IP|CREATE_MISSING_DIRS|USE_EP(RT|SV)|FILEMETHOD)
          |FILE(TIME)?|FORBID_REUSE|FOLLOWLOCATION|FAILONERROR|WRITE(FUNCTION|HEADER)|LOW_SPEED_(LIMIT|TIME)
          |AUTOREFERER)
          |PROXY_(HTTP|SOCKS(4|5))|PROTO_(SCP|SFTP|HTTP(S)?|TELNET|TFTP|DICT|FTP(S)?|FILE|LDAP(S)?|ALL)
          |E_((RECV|READ)_ERROR|GOT_NOTHING|MALFORMAT_USER
          |BAD_(CONTENT_ENCODING|CALLING_ORDER|PASSWORD_ENTERED|FUNCTION_ARGUMENT)
          |SSH|SSL_(CIPHER|CONNECT_ERROR|CERTPROBLEM|CACERT|PEER_CERTIFICATE|ENGINE_(NOTFOUND|SETFAILED))
          |SHARE_IN_USE|SEND_ERROR|HTTP_(RANGE_ERROR|NOT_FOUND|PORT_FAILED|POST_ERROR)
          |COULDNT_(RESOLVE_(HOST|PROXY)|CONNECT)|TOO_MANY_REDIRECTS|TELNET_OPTION_SYNTAX|OBSOLETE
          |OUT_OF_MEMORY|OPERATION|TIMEOUTED|OK|URL_MALFORMAT(_USER)?|UNSUPPORTED_PROTOCOL
          |UNKNOWN_TELNET_OPTION|PARTIAL_FILE
          |FTP_(BAD_DOWNLOAD_RESUME|SSL_FAILED|COULDNT_(RETR_FILE|GET_SIZE|STOR_FILE|SET_(BINARY|ASCII)|USE_REST)
          |CANT_(GET_HOST|RECONNECT)|USER_PASSWORD_INCORRECT|PORT_FAILED|QUOTE_ERROR|WRITE_ERROR
          |WEIRD_((PASS|PASV|SERVER|USER)_REPLY|227_FORMAT)|ACCESS_DENIED)
          |FILESIZE_EXCEEDED|FILE_COULDNT_READ_FILE|FUNCTION_NOT_FOUND|FAILED_INIT|WRITE_ERROR|LIBRARY_NOT_FOUND
          |LDAP_(SEARCH_FAILED|CANNOT_BIND|INVALID_URL)|ABORTED_BY_CALLBACK)
          |VERSION_NOW
          |FTP(METHOD_(MULTI|SINGLE|NO)CWD|SSL_(ALL|NONE|CONTROL|TRY)|AUTH_(DEFAULT|SSL|TLS))
          |AUTH_(ANY(SAFE)?|BASIC|DIGEST|GSSNEGOTIATE|NTLM))
          |CURL_(HTTP_VERSION_(1_(0|1)|NONE)|NETRC_(REQUIRED|IGNORED|OPTIONAL)|TIMECOND_(IF(UN)?MODSINCE|LASTMOD)
          |IPRESOLVE_(V(4|6)|WHATEVER)|VERSION_(SSL|IPV6|KERBEROS4|LIBZ))
          |IMAGETYPE_(GIF|XBM|BMP|SWF|COUNT|TIFF_(MM|II)|ICO|IFF|UNKNOWN|JB2|JPX|JP2|JPC|JPEG(2000)?|PSD|PNG|WBMP)

          |INPUT_(REQUEST|GET|SERVER|SESSION|COOKIE|POST|ENV)|ICONV_(MIME_DECODE_(STRICT|CONTINUE_ON_ERROR)|IMPL|VERSION)

          |DNS_(MX|SRV|SOA|HINFO|NS|NAPTR|CNAME|TXT|PTR|ANY|ALL|AAAA|A(6)?)

          |DOM(STRING_SIZE_ERR)

          |DOM_((SYNTAX|HIERARCHY_REQUEST|NO_(MODIFICATION_ALLOWED|DATA_ALLOWED)|NOT_(FOUND|SUPPORTED)|NAMESPACE
          |INDEX_SIZE|USE_ATTRIBUTE|VALID_(MODIFICATION|STATE|CHARACTER|ACCESS)|PHP|VALIDATION|WRONG_DOCUMENT)_ERR)
          |JSON_(HEX_(TAG|QUOT|AMP|APOS)|NUMERIC_CHECK|ERROR_(SYNTAX|STATE_MISMATCH|NONE|CTRL_CHAR|DEPTH|UTF8)|FORCE_OBJECT)

          |PREG_((D_UTF8(_OFFSET)?|NO|INTERNAL|(BACKTRACK|RECURSION)_LIMIT)_ERROR|GREP_INVERT
          |SPLIT_(NO_EMPTY|(DELIM|OFFSET)_CAPTURE)|SET_ORDER|OFFSET_CAPTURE|PATTERN_ORDER)
          |PSFS_(PASS_ON|ERR_FATAL|FEED_ME|FLAG_(NORMAL|FLUSH_(CLOSE|INC)))

          |PCRE_VERSION|POSIX_((F|R|W|X)_OK|S_IF(REG|BLK|SOCK|CHR|IFO))

          |FNM_(NOESCAPE|CASEFOLD|PERIOD|PATHNAME)

          |FILTER_(REQUIRE_(SCALAR|ARRAY)|NULL_ON_FAILURE|CALLBACK|DEFAULT|UNSAFE_RAW
          |SANITIZE_(MAGIC_QUOTES|STRING|STRIPPED|SPECIAL_CHARS|NUMBER_(INT|FLOAT)|URL
          |EMAIL|ENCODED|FULL_SPCIAL_CHARS)
          |VALIDATE_(REGEXP|BOOLEAN|INT|IP|URL|EMAIL|FLOAT)
          |FORCE_ARRAY
          |FLAG_(SCHEME_REQUIRED|STRIP_(BACKTICK|HIGH|LOW)|HOST_REQUIRED|NONE|NO_(RES|PRIV)_RANGE|ENCODE_QUOTES
          |IPV(4|6)|PATH_REQUIRED|EMPTY_STRING_NULL|ENCODE_(HIGH|LOW|AMP)|QUERY_REQUIRED
          |ALLOW_(SCIENTIFIC|HEX|THOUSAND|OCTAL|FRACTION)))
          |FILE_(BINARY|SKIP_EMPTY_LINES|NO_DEFAULT_CONTEXT|TEXT|IGNORE_NEW_LINES|USE_INCLUDE_PATH|APPEND)

          |FILEINFO_(RAW|MIME(_(ENCODING|TYPE))?|SYMLINK|NONE|CONTINUE|DEVICES|PRESERVE_ATIME)

          |FORCE_(DEFLATE|GZIP)

          |LIBXML_(XINCLUDE|NSCLEAN|NO(XMLDECL|BLANKS|NET|CDATA|ERROR|EMPTYTAG|ENT|WARNING)
          |COMPACT|DTD(VALID|LOAD|ATTR)|((DOTTED|LOADED)_)?VERSION|PARSEHUGE|ERR_(NONE|ERROR|FATAL|WARNING)))
          \b
        name: support.constant.ext.php
        captures:
          1: {name: punctuation.separator.inheritance.php}
      - match: >-
          (?x)

          (\\)?\b

          (T_(RETURN|REQUIRE(_ONCE)?|GOTO|GLOBAL|(MINUS|MOD|MUL|XOR)_EQUAL|METHOD_C|ML_COMMENT|BREAK
          |BOOL_CAST|BOOLEAN_(AND|OR)|BAD_CHARACTER|SR(_EQUAL)?|STRING(_CAST|VARNAME)?|START_HEREDOC|STATIC
          |SWITCH|SL(_EQUAL)?|HALT_COMPILER|NS_(C|SEPARATOR)|NUM_STRING|NEW|NAMESPACE|CHARACTER|COMMENT
          |CONSTANT(_ENCAPSED_STRING)?|CONCAT_EQUAL|CONTINUE|CURLY_OPEN|CLOSE_TAG|CLONE|CLASS(_C)?
          |CASE|CATCH|TRY|THROW|IMPLEMENTS|ISSET|IS_((GREATER|SMALLER)_OR_EQUAL|(NOT_)?(IDENTICAL|EQUAL))
          |INSTANCEOF|INCLUDE(_ONCE)?|INC|INT_CAST|INTERFACE|INLINE_HTML|IF|OR_EQUAL|OBJECT_(CAST|OPERATOR)
          |OPEN_TAG(_WITH_ECHO)?|OLD_FUNCTION|DNUMBER|DIR|DIV_EQUAL|DOC_COMMENT|DOUBLE_(ARROW|CAST|COLON)
          |DOLLAR_OPEN_CURLY_BRACES|DO|DEC|DECLARE|DEFAULT|USE|UNSET(_CAST)?|PRINT|PRIVATE|PROTECTED|PUBLIC
          |PLUS_EQUAL|PAAMAYIM_NEKUDOTAYIM|EXTENDS|EXIT|EMPTY|ENCAPSED_AND_WHITESPACE
          |END(SWITCH|IF|DECLARE|FOR(EACH)?|WHILE)|END_HEREDOC|ECHO|EVAL|ELSE(IF)?|VAR(IABLE)?|FINAL|FILE
          |FOR(EACH)?|FUNC_C|FUNCTION|WHITESPACE|WHILE|LNUMBER|LIST|LINE|LOGICAL_(AND|OR|XOR)
          |ARRAY_(CAST)?|ABSTRACT|AS|AND_EQUAL))
          \b
        name: support.constant.parser-token.php
        captures:
          1: {name: punctuation.separator.inheritance.php}

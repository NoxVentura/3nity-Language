name: SagaScript
scopeName: source.swift
fileTypes: [saga, swift, sga, sgs, sgi]
patterns: [include: '#core']

information for contributors: |
  This is the grammar for the SagaScript language.

  The grammar is nearing completion but needs to be thoroughly refactored and
  reorganized. There also are some bugfixes which are on the verge of being
  performed.

  Should you feel any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo, and I
  will be very happy to receive it/them.

fixes: |
  New changes:

  - Syntax now closely resembles JavaScript's. This includes keywords, comments,
    literals, strings etc. Many parts of this document have been changed.
  - Large regular expressions scattered through this document also have been
    fixed up to be more readable to any editors out there. It once was presented
    in a rather unpretty format.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [x] identifiers and variables
    - [x] operators
    - [x] object literals
    - [x] object labels
    - [x] pipeline functions
    - [x] modifier keywords
    - [x] function assignments
    - [x] anonymous functions
    - [x] embedded content
    - [x] rounded and square brackets
    - [x] LINQ, inline SQL and validation syntax (more to come later)
  - Numbers and escape sequences have been reworked, and will no longer accept
    integers bigger than decimal 1114111 which now are highlighted as an error.
  - Bases 4, 6, and 12 have been scrapped, though a multi-base generic numeric
    literal is still in the works.
  - Interpolation and formatting syntax have been reworked and fixed, and can now
    span multiple lines and beyond 20 nested layers thanks to applyEndPatternLast.
    Because of this, spacing around most of the patterns here have also been removed;
    a separate space scope is added to join everything together.
  - Function call syntax is heavily standardized and would need a later fix in
    the long run. This is if a more terser variant of SagaScript is in the need.
    and if so would be inspired by Haskell.
  - Fixed some bugs with regular expressions:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)
    - Improved highlighting for regexes with flags
  - Added prefixes to strings.
  - Switched around regular expressions: / triggers a regex when it begins an
    expression. ` is now used to open unquoted strings.
  - Two (or more) regular expressions in a row on the same line without a comma
    triggers a replacement string instead of a normal regular expression literal.
  - Changed up syntax highlighting of switch and match statements to be more
    consistent with JavaScript.
  - Function calls now trigger beside ( and {.
  - Added Perl/Ruby's unless and until keywords.
  - Fixed JSX highlighting and attributes, inspired by Svelte, Angular (TS), HAML
    - @directive
    - #id and .class
    - :event and |pipe (both from Svelte)
    - %directive
    - &reference and *spread

  Fixes:

  - Match unquoted globs in routes
  - Plan and add Trinity's standard library, then integrate it into the grammar.
    This would all be done in a separate PR and once the grammar is completely
    finished.
    - A handful of built-in properties and constants are part of this grammar
      and are used to highlight CSS properties, constants and HTML tags. Other
      than that, nothing else is present...
      at least not in the moment
    - This features would include:
      - Type, interface, module/namespace and class names
      - Functions and methods
      - Constants and properties
      - Special variables
      - Various UI elements and color names
      - Character names (LaTeX/HTML/AGLFN)

  - Revamp Markdown syntax with these extensions:
    - [ ] Citations
    - [ ] Strike-through
    - [ ] Deleted and inserted text
    - [ ] Superscript
    - [ ] Subscript
    - [ ] Spans
    - [ ] Selectors and anchors
    - [ ] Code blocks
    - [ ] Definition blocks
    - [ ] Tables
    - [ ] Headings and subheadings

define:
  class-name: &class-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|till|thru|by|delete
        |unset|ref|and|or|xor|not
        |var|val|let|const|function
        |procedure|method|type|class
        |interface|enum|module|struct
        |protocol|iterator|macro|query
        |object|contract|trait|style
        |element|field|model|union
        |go|defer|do|with|from|where
        |if|unless|else|then|def
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|fallthru|default|goto
        |break|continue|redo|retry
        |return|yield|await|scope
        |import|export|route
        |debug|assert|check
        |extends|implements
      )
      (?!\B|\p{Pd}+\b)
    )

    # identifier
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|till|thru|by|delete
        |unset|ref|and|or|xor|not
        |var|val|let|const|function
        |procedure|method|type|class
        |interface|enum|module|struct
        |protocol|iterator|macro|query
        |object|contract|trait|style
        |element|field|model|union
        |go|defer|do|with|from|where
        |if|unless|else|then|def
        |for|foreach|repeat|while|until
        |try|throw|catch|finally|switch
        |match|case|fallthru|default|goto
        |break|continue|redo|retry
        |return|yield|await|scope
        |import|export|route
        |debug|assert|check
      )
      (?!\B|\p{Pd}+\b)
    )

    # identifier
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  html-tag-names: &html-tag-names
    - match: '\.|:|::'
      name: punctuation.separator.namespace.saga
    - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
      name: entity.name.tag.namespace.saga
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)\b
      name: support.class.component.saga
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#argument-list'
      - include: '#function-clause'
      - include: '#symbols'
      - include: '#decorators'
      - include: '#type-signature'
      - include: '#jsx'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#literals'
      - include: '#operators'
      - include: '#function-calls'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{1024,}$

  space:
    match: \s+
    name: meta.var.expr.saga

  # Function brackets (early here as not to break things)

  param-bracket-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.saga
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.saga
      - include: '#clauses'
      - include: '#constants'
      - include: '#declaration-keywords'
      - include: '#parameter-variables'
      - include: '#keywords'

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.saga
      - match: '[\w]+?'
        name: invalid.illegal.variable.saga
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.saga
      - match: '[\p{S}\p{P}&&[^,;''"`({\[)}\]\p{Pc}]]+'
        name: invalid.illegal.operator.saga
      - match: \S+?
        name: invalid.illegal.uncaught.saga

  # Types

  types:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#argument-list'
      - include: '#angle-brackets'
      - include: '#modifiers'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#type-brackets'
      - include: '#space'

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \s* \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          in|of|as|is|new
          |to|till|thru|by|delete
          |unset|ref|and|or|xor|not
          |var|val|let|const|function
          |procedure|method|type|class
          |interface|enum|module|struct
          |protocol|iterator|macro|query
          |object|contract|trait|style
          |element|field|model|union
          |go|defer|do|with|from|where
          |if|unless|else|then|def
          |for|foreach|repeat|while|until
          |try|throw|catch|finally|switch
          |match|case|fallthru|default|goto
          |break|continue|redo|retry
          |return|yield|await|scope
          |import|export|route
          |debug|assert|check
          |extends|implements
        )
        (?!\B|\p{Pd}+\b)
      )

      (?:
        (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
        (?: # Properties
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
      )\b \s*
    captures:
      1: { name: entity.name.trait.saga }
      2: { name: entity.name.interface.saga }
      3: { name: entity.name.interface.saga }
      4: { name: entity.name.trait.saga }
      5: { name: entity.name.module.saga }
      6: { name: entity.name.namespace.saga }
      7: { name: entity.name.namespace.saga }
      8: { name: entity.name.module.saga }
      9: { name: entity.name.type.saga }
      10: { name: entity.name.class.saga }
      11: { name: entity.name.class.saga }
      12: { name: entity.name.type.saga }

  type-signature:
    applyEndPatternLast: true
    name: meta.type.saga
    begin: (:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: { name: punctuation.definition.annotation.saga }
    patterns:
      - include: '#types'

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.saga
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.saga

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.mapping.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.dictionary.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.saga
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.saga
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.saga
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.parameters.saga }
        patterns:
          - include: '#param-bracket-content'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.saga }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.tuple.saga }
        patterns:
          - include: '#types'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.expression.saga }
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.saga
    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.attribute-selector.saga }
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.binding-pattern.array.saga }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.sequence.saga }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.array.saga }
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(extends|implements)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.$1.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as|is)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((instance|value|pair|type|name|size|key)of)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.saga

  type-operators:
    old:
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: { name: keyword.operator.type.function.saga }
          2: { name: keyword.operator.type.channel.saga }
          3: { name: keyword.operator.type.function.saga }
          4: { name: keyword.operator.type.channel.saga }

    patterns:
      - &qualified-name-separators
        comment: Primary binary operators
        match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
        captures:
          1: { name: keyword.operator.optional.saga }
          2: { name: keyword.operator.assert.saga }
          3: { name: keyword.operator.accessor.saga }
      - match: \s*(--?>|~~?>|==?>)
        name: keyword.operator.type.function.saga
      - match: \s*(<--?|<~~?|<==?)
        name: keyword.operator.type.channel.saga
      - comment: type unions
        match: (?<=^|[\s({\[])(\|)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\|)(?=['"`({\[\w])
        captures:
          1: { name: keyword.operator.union.saga }
          2: { name: keyword.operator.union.saga }
      - comment: type operators
        match: |
          (?x)
          (?<=^|[,;'"`({\[)}\]\w\s]|\\.)
            (?:
              (\+)|(\-)|(\*)|(\/)|(\%)|(\!)
              |(\?)|(\&)|(\^)|(\~)|(\$)|(:[<>]|[<>]:)
            )
          (?=$|[,;'"`({\[)}\]\w\s])
        captures: &type-operators
          1: { name: keyword.operator.sum.saga }
          2: { name: keyword.operator.difference.saga }
          3: { name: keyword.operator.product.saga }
          4: { name: keyword.operator.quotient.saga }
          5: { name: keyword.operator.remainder.saga }
          6: { name: keyword.operator.only.saga }
          7: { name: keyword.operator.maybe.saga }
          8: { name: keyword.operator.intersection.saga }
          9: { name: keyword.operator.symmetric.saga }
          10: { name: keyword.operator.negation.saga }
          11: { name: keyword.operator.macro.dollar.saga }
          12: { name: keyword.operator.class.saga }

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'
      - include: '#strings-unquoted'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan|undefined|infinity) # null, NaN
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: { name: constant.language.boolean.$1.saga }
          2: { name: constant.language.$2.saga }
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|super|self) # special arguments
            |(params) # arguments
            |(constructor) # constructor
            |(prototype) # prototype
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: { name: variable.language.$1.saga }
          2: { name: variable.language.arguments.saga }
          3: { name: variable.language.constructor.saga }
          4: { name: variable.language.prototype.saga }
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (
            console|document|window|global|process|require|module|exports
            |navigator|location|history|localStorage|sessionStorage
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: { name: support.type.object.$1.saga }

  # Numbers

  numbers:
    patterns:
      - comment: hexadecimal integers
        name: constant.numeric.hexadecimal.saga
        match: |
          (?ix) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.saga }
          2: { name: keyword.other.unit.saga }
          3: { name: keyword.operator.expression.exponent.saga }
          4: { name: keyword.operator.exponent.sign.saga }
          5: { name: constant.numeric.decimal.exponent.mantissa.saga }
          6: { name: keyword.other.unit.saga }
      - comment: octal integers
        name: constant.numeric.octal.saga
        match: |
          (?ix) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.saga }
          2: { name: keyword.other.unit.saga }
          3: { name: keyword.operator.expression.exponent.saga }
          4: { name: keyword.operator.exponent.sign.saga }
          5: { name: constant.numeric.decimal.exponent.mantissa.saga }
          6: { name: keyword.other.unit.saga }
      - comment: binary 0b
        name: constant.numeric.binary.saga
        match: |
          (?ix) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.saga }
          2: { name: keyword.other.unit.saga }
          3: { name: keyword.operator.expression.exponent.saga }
          4: { name: keyword.operator.exponent.sign.saga }
          5: { name: constant.numeric.decimal.exponent.mantissa.saga }
          6: { name: keyword.other.unit.saga }
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.saga
        match: |
          (?ix) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: { name: storage.type.numeric.saga }
          2: { name: keyword.other.unit.saga }
          3: { name: keyword.operator.expression.exponent.saga }
          4: { name: keyword.operator.exponent.sign.saga }
          5: { name: constant.numeric.decimal.exponent.mantissa.saga }
          6: { name: keyword.other.unit.saga }

  # Symbols

  decorators:
    applyEndPatternLast: true
    begin: (?<=^|\\.|['"`({\[)}\]\s:=])(\@)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    name: entity.name.decorator.saga
    captures:
      1: { name: punctuation.definition.decorator.saga }
      2: { name: entity.name.decorator.saga }
    patterns:
      - match: ::|\.
        name: punctuation.separator.namespace.saga
      - include: '#brackets'
      - include: '#strings'
      - include: '#function-calls'
      - include: '#variables'

  symbols:
    patterns:
      - comment: quoted symbol
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s:=])(:)(?=[\\'"])
        end: (?=)|$
        name: constant.language.symbol-type.saga
        captures:
          1: { name: punctuation.definition.symbol.saga }
        patterns:
          - include: '#strings-single-quoted'
          - include: '#strings-double-quoted'
          - include: '#strings-unquoted'
      - match: (?<=^|\\.|['"`({\[)}\]\s:=])(:)(\b[\p{Pc}\p{L}][\w\p{Pd}]*\b)
        name: constant.other.symbol.saga
        captures:
          1: { name: punctuation.definition.symbol.saga }
          2: { name: constant.other.symbol.saga }
        patterns:
          - match: ''
          - include: '#string-escapes'

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (`)
    end: (?=\W)|$
    name: string.template.saga
    captures:
      1: { name: punctuation.definition.string.saga }
    patterns:
      - match: \b\p{Pd}+\b
      - include: '#string-escapes'

  strings:
    patterns:
      - include: '#strings-prefixed'
      - include: '#strings-double-quoted'
      - include: '#strings-single-quoted'

  strings-single-quoted:
    patterns:
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:\p{L}+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
      - comment: single-quoted plain string
        begin: (?<!'+)((?i:))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'

  strings-double-quoted:
    patterns:
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:\p{L}+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
      - comment: double-quoted plain string
        begin: (?<!"+)((?i:))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'

  string-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded'

  string-escapes:
    patterns:
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: { name: constant.character.escape.newline.saga }
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.saga
      - match: \\[abefprnstv]
        name: constant.character.escape.saga
      - match: \\\p{S}
        name: constant.character.escape.symbol.saga
      - match: \\\p{P}
        name: constant.character.escape.punctuation.saga
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.saga
      - match: \\\s
        name: constant.character.escape.space.saga
      - match: \\\p{L}
        name: constant.character.escape.letter.saga
      - match: \\\p{N}
        name: constant.character.escape.number.saga
      - match: \\.
        name: constant.character.escape.other.saga

  named-characters:
    name: string.unquoted.plain.in.saga
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.saga
        begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: { name: constant.other.function.saga }
            patterns:
              - include: '#named-characters'
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
        name: constant.character.escape.saga
        captures:
          1: { patterns: [include: '#character-namespace'] }
      - include: '#string-content'
      - include: '#punctuation'
      - include: '#illegal'

  function-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: support entity.name.tag.namespace.saga
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: support entity.name.function.member.saga

  character-namespace:
    patterns:
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: constant.other.character-class.saga
      - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: constant.character.escape.unicode.saga

  named-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.saga
        begin: \\N([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: { patterns: [include: '#function-namespace'] }
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: { name: constant.other.function.saga }
            patterns:
              - include: '#named-characters'
      - match: \\N([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
        name: constant.character.escape.saga
        captures:
          1: { patterns: [include: '#character-namespace'] }
      - begin: \\N{\s*
        end: \s*}
        name: constant.other.character-class.unicode.saga
        patterns:
          - applyEndPatternLast: true
            name: constant.other.function.saga
            begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
            beginCaptures:
              1: { patterns: [include: '#function-namespace'] }
            end: (?=)|$
            patterns:
              - begin: (\{)
                end: (\})
                captures:
                  1: { name: constant.other.function.saga }
                patterns:
                  - include: '#named-characters'
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
            name: constant.character.escape.saga
            captures:
              1: { patterns: [include: '#character-namespace'] }
          - include: '#string-content'
          - include: '#punctuation'
          - include: '#illegal'

  numeric-escapes:
    comments: |
      Hexadecimal escapes \u encode UTF-16 while \x encodes UTF-8 code points
      in addition to Unicode characters.
    patterns:
      - comment: Binary escape sequences (0 to 417777)
        match: |
          (?x)
          \\b # prefix
            0* # leading zeroes
          (?: # numbers leading to 0001 0000 1111 1111 1111 1111
              10000[01]{16}
            | [01]{1,20}
          )
            (?![01])
        name: constant.character.escape.binary.saga
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\b # prefix
            [01]+
            (?![01])
        name: invalid.illegal.escape.binary.saga
      - begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.saga
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers leading to 0001 0000 1111 1111 1111 1111
                  10000[01]{16}
                | [01]{1,20}
              )
                (?![01])
            name: constant.character.escape.binary.saga
          - include: '#illegal'

      - comment: Octal escape sequences (0 to 417777)
        match: |
          (?x)
          \\o # prefix
            0* # leading zeroes
          (?: # numbers leading to 417777
              4[01][0-7]{4}
            | [1-3][0-7]{5}
            | [1-7][0-7]{1,4}
            | [0-7]
          )
            (?![0-7])
        name: constant.character.escape.octal.saga
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\o # prefix
            [0-7]+
            (?![0-7])
        name: invalid.illegal.escape.octal.saga
      - begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.saga
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              ( # numbers up to 417777
                  4[01][0-7]{4}
                | [1-3][0-7]{5}
                | [1-7][0-7]{1,4}
                | [0-7]
              )
                (?![0-7])
            name: constant.character.escape.octal.saga
          - include: '#illegal'

      - comment: Decimal escapes (0 to 1114111)
        match: |
          (?x)
          \\d? # prefix
            0* # leading zeroes
          (?: # numbers up to 1114111
              111411[01]
            | 111410\d
            | 11140\d{2}
            | 111[0-3]\d{3}
            | 110\d{4}
            | 10\d{5}
            | [1-9]\d{1,5}
            | \d
          )
            (?!\d)
        name: constant.character.escape.decimal.saga
      - comment: Decimal escape sequences
        match: |
          (?x)
          \\d? # prefix
            \d+
            (?!\d)
        name: invalid.illegal.escape.decimal.saga
      - begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.saga
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              0* # leading zeroes
              (?: # numbers up to 1114111
                  111411[01]
                | 111410\d
                | 11140\d{2}
                | 111[0-3]\d{3}
                | 110\d{4}
                | 10\d{5}
                | [1-9]\d{1,5}
                | \d
              )
                (?!\d)
            name: constant.character.escape.decimal.saga
          - include: '#illegal'

      - comment: Trailing byte pair U+80-U+BF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            [89ab]\h
          )
            (?!\h)
        name: constant.character.escape.trailing.saga
      - comment: Leading byte pair U+C0-U+FF
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # C0 to FF
                [c-f]\h
            )
          )
            (?!\h)
        name: constant.character.escape.leading.saga
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\x # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.hexadecimal.saga
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
          \\x # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.hexadecimal.saga
      - begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.saga
        patterns:
          - include: '#punctuation'
          - comment: Trailing byte pair U+80-U+BF
            match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                [89ab]\h # 80 to BF
              )
                (?!\h)
            name: constant.character.escape.trailing.saga
          - comment: Leading byte pair U+C0-U+FF
            match: |
              (?x)
                \b # prefix
              (?i:
                0* # leading zeroes
                (?: # C0 to FF
                    [c-f]\h
                )
              )
                (?!\h)
            name: constant.character.escape.leading.saga
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.hexadecimal.saga
          - include: '#illegal'

      - comment: Low surrogate pairs U+DC00-DFFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[c-f] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.low.saga
      - comment: High surrogate pairs U+D800-DBFF
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            d[89ab] \h{2}
          )
            (?!\h)
        name: constant.character.escape.surrogate.high.saga
      - comment: Hexadecimal escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
          )
            (?!\h)
        name: constant.character.escape.unicode.saga
      - comment: Unicode escape sequences
        match: |
          (?x)
          \\u # prefix
            \h+
            (?!\h)
        name: invalid.illegal.escape.unicode.saga
      - comment: Unicode escape sequences
        match: |
          (?x)
            \\u # prefix
          (?i:
            0* # leading zeroes
            (?: # 0 to 10FFFF
                10\h{4}
              | [1-9a-f]\h{1,4}
              | \h
            )
            (?!\h)
          )
        name: constant.character.escape.unicode.saga
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.saga
        patterns:
          - include: '#punctuation'
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [c-f] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.low.saga
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                d [89ab] \h{2}
              )
                (?!\h)
            name: constant.character.escape.surrogate.high.saga
          - match: |
              (?x)
                \b
              (?i:
                0* # leading zeroes
                (?: # 0 to 10FFFF
                    10\h{4}
                  | [1-9a-f]\h{1,4}
                  | \h
                )
              )
                (?!\h)
            name: constant.character.escape.unicode.saga
          - include: '#illegal'

  # Embedded expressions

  embedded:
    patterns:
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-verbatim:
    patterns:
      - match: \#\#|\$\$|\%\%
        name: constant.character.escape.saga
      - include: '#embedded-expression'
      - include: '#embedded-format'
      - include: '#embedded-placeholder'

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: meta.embedded.expression.saga
        captures:
          1: { name: punctuation.definition.variable.saga }
        patterns:
          - include: $self
      - comment: Interpolated expression
        applyEndPatternLast: true
        name: meta.embedded.expression.saga
        begin: |
          (?x)
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
              |go|defer|do|with|from|where
              |if|unless|else|then|def
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
            (?!\B|\p{Pd}+\b)
          )
          (?=[\p{Pc}\p{L}]) # next to a word
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.variable.saga }
        patterns:
          - include: '#constants'
          - include: '#brackets'
          - include: '#embedded-function-calls'
          - include: '#variables'
          - include: '#numbers'
          - *qualified-name-separators

  embedded-placeholder:
    patterns:
      - name: meta.embedded.placeholder.saga
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )?
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: { name: punctuation.definition.anchor.saga }
          2:
            name: constant.numeric.decimal.saga
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.saga
              - match: (?:[>.]\.[.<] | \.\. | [=.]\.[.=]|\.\.=?|=\.=)
                name: keyword.operator.range.saga
      - name: meta.embedded.placeholder.saga
        match: |
          (?x)
          (\#) # sigil
          (
            (?:
              (?:&|%|\$|~~?|\*\*?)? # sigil
              [!?]? # required or optional
            )
            \b
             [\p{Pc}\p{L}][\w\p{Pd}]*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style
                |element|field|model|union
                |go|defer|do|with|from|where
                |if|unless|else|then|def
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            \b
            [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
            \b
          )
        captures:
          1: { name: punctuation.definition.anchor.saga }
          2: { patterns: [include: '#placeholder-variables'] }
      - name: meta.embedded.placeholder.saga
        begin: (\#{)\s*
        end: \s*(})
        captures:
          1: { name: punctuation.definition.anchor.saga }
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(//)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.saga }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: { name: keyword.other.flag.saga }
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?<=^|\\.|['"`({\[)}\]\s])(/)(?=[\p{Pc}\p{L}])
        end: (?=)|$
        captures:
          1: { name: punctuation.definition.flag.saga }
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: { name: keyword.modifier.saga }

  embedded-format:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    name: meta.embedded.formatting.saga
    begin: (?<!%)(%)(?=[\p{Pc}\p{L}])
    end: (?=)|$
    captures:
      1: { name: punctuation.definition.directive.saga }
    patterns:
      - include: '#format-syntax'

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: with optional value
        applyEndPatternLast: true
        begin: (?:(?<=%)|(\|))([\p{Pc}\p{L}][\w\p{Pd}]*)\b(:)
        end: (?=)|$
        name: storage.type.format.saga
        captures:
          1: { name: punctuation.separator.mapping.saga }
          2: { name: storage.type.format.saga }
          3: { name: punctuation.separator.key-value.saga }
        patterns: &format-values
          - include: '#constants'
          - include: '#embedded-function-calls'
          - include: '#variables'
          - include: '#brackets'
          - include: '#regexps'
          - include: '#numbers'
          - include: '#symbols'
          - *qualified-name-separators
      - comment: type specifier
        match: (?:(?<=%)|(\|))([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: storage.type.format.saga
        captures:
          1: { name: punctuation.separator.mapping.saga }
          2: { name: storage.type.format.saga }

  # Regular expressions

  regexps:
    applyEndPatternLast: true
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
              |go|defer|do|with|from|where
              |if|unless|else|then|def
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?= />?)
    end: (?=)|$
    name: meta.regexp.saga
    patterns:
      - applyEndPatternLast: true
        comment: Pattern section
        begin: (/>)\s*
        end: \s*(</)(\p{L}*)
        name: string.pattern.regexp.saga
        captures:
          1: { name: punctuation.definition.regexp.saga }
          2: { name: keyword.other.flag.saga }
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'
          - comment: Replacement section
            begin: (</>)\s*
            end: \s*(?=</)
            name: string.replace.regexp.saga
            captures:
              1: { name: punctuation.definition.regexp.saga }
            patterns:
              - include: '#back-references'
              - include: '#string-content'
      - comment: Replacement section
        begin: (?<=/)\s*(/)\s*
        end: \s*(/)(\p{L}*)
        name: string.replace.regexp.saga
        captures:
          1: { name: punctuation.definition.regexp.saga }
          2: { name: keyword.other.flag.saga }
        patterns:
          - include: '#back-references'
          - include: '#string-content'
      - comment: Pattern section
        begin: (/)\s*
        end: \s*(/)(\p{L}*)
        name: string.pattern.regexp.saga
        captures:
          1: { name: punctuation.definition.regexp.saga }
          2: { name: keyword.other.flag.saga }
        patterns:
          - include: '#regexp-patterns'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#function-calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}][\w\p{Pd}]*\b
        name: keyword.other.unit.saga
      - include: '#space'

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: { name: punctuation.definition.mapping.saga }
        patterns:
          - match: ','
            name: punctuation.separator.mapping.saga
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: { name: punctuation.definition.array.saga }
        patterns:
          - match: ','
            name: punctuation.separator.sequence.saga
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.expression.saga }
        patterns:
          - match: ','
            name: punctuation.separator.arguments.saga
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*)
        name: keyword.other.back-reference.saga
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.saga
        captures:
          1: { name: keyword.other.back-reference.saga }
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#string-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.saga
        captures:
          1: { name: keyword.other.back-reference.saga }
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#strings'
      - match: \|
        name: keyword.operator.or.saga
      - match: \&
        name: keyword.operator.compose.saga
      - match: \.
        name: constant.character.all.saga
      - match: \\[bB](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.saga
      - match: \$|\\[yYzZ](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.saga}
      - match: \^|\\[AmM](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.saga
      - match: \\K
        name: keyword.control.keepout.saga
      - match: \\G
        name: keyword.control.search.saga
      - match: \\R
        name: constant.character.control.saga
      - match: \\[XO]
        name: constant.character.unicode.saga
      - match: \\\d+
        name: keyword.other.back-reference.saga
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: { name: keyword.operator.quantifier.saga }
          1: { name: keyword.operator.modifier.lazy.saga }
          2: { name: keyword.operator.modifier.eager.saga }
          3: { name: keyword.operator.modifier.greedy.saga }
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: { name: keyword.operator.quantifier.lazy.saga }
          2: { name: keyword.operator.quantifier.eager.saga }
          3: { name: keyword.operator.quantifier.greedy.saga }
          4: { name: keyword.operator.modifier.lazy.saga }
          5: { name: keyword.operator.modifier.eager.saga }
          6: { name: keyword.operator.modifier.greedy.saga }
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.saga
        captures:
          1: { name: keyword.other.back-reference.saga }
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.saga
        captures:
          1: { name: keyword.other.subroutine.saga }
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.saga
        captures:
          1: { name: keyword.other.back-reference.saga }
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.saga
        captures:
          1: { name: keyword.other.subroutine.saga }
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.saga
        captures:
          1: { name: punctuation.definition.fuzzy.saga }
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`({\[)}\]\w\s])(:)
            beginCaptures:
              1: { name: punctuation.separator.key-value.saga }
            end: (?=[,;}]|)|$
            patterns: &regexp-patterns
              - include: '#regexp-patterns'
          - include: '#fuzzy-expression'
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'
      - include: '#space'

  regexp-groups:
    patterns:
      - comment: Backtracking control verb
        begin: (\(\*([\p{Pc}\p{L}][\w\p{Pd}]*)?(:)?)
        end: \s*(\))
        name: meta.group.backtrack.saga
        captures:
          1: { name: punctuation.section.expression.saga }
          2: { name: keyword.control.saga }
          3: { name: punctuation.separator.colon.saga }
        patterns: *regexp-patterns
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.saga
        end: \s*(\))
        name: comment.block.regexp.saga
        captures:
          1: { name: punctuation.definition.comment.saga }
        patterns:
          - match: \\.
            name: comment.block.regexp.saga
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.saga
        captures:
          1: { name: punctuation.definition.group.look-ahead.saga }
        patterns: *regexp-patterns
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.saga
        captures:
          1: { name: punctuation.definition.group.look-behind.saga }
        patterns: *regexp-patterns
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.saga
        captures:
          1: { name: punctuation.definition.group.negative-look-ahead.saga }
        patterns: *regexp-patterns
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.saga
        captures:
          1: { name: punctuation.definition.group.negative-look-behind.saga }
        patterns: *regexp-patterns
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: { name: punctuation.definition.directive.saga }
        end: \s*(\))
        name: meta.group.directive.saga
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.saga
        captures:
          1: { name: punctuation.definition.group.longest.saga }
        patterns: *regexp-patterns
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.saga
        captures:
          0: { name: punctuation.definition.group.flag.saga }
          1: { name: punctuation.definition.group.flag.saga }
          2: { name: constant.numeric.index.saga }
          3: { name: keyword.control.recursion.saga }
          4: { name: keyword.other.flag.saga }
          5: { name: punctuation.separator.colon.saga }
        patterns: *regexp-patterns
      - comment: Call-outs
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.saga
        captures:
          1: { name: punctuation.definition.group.call-out.saga }
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.saga
            captures:
              1: { name: punctuation.definition.group.call-out.saga }
              2: { name: keyword.operator.range.saga }
              3: { name: punctuation.definition.tag.saga }
              4: { patterns: [include: '#function-names'] }
              5: { name: punctuation.definition.tag.saga }
            patterns:
              - include: $self
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.saga
        captures:
          1: { name: punctuation.definition.group.atomic.saga }
        patterns: *regexp-patterns
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.saga
        captures:
          1: { name: punctuation.definition.group.non-capturing.saga }
        patterns: *regexp-patterns
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.saga
        captures:
          1: { name: punctuation.definition.group.branch.saga }
        patterns: *regexp-patterns
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.saga
        captures:
          1: { name: punctuation.definition.group.absent.saga }
        patterns: *regexp-patterns
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.saga
        captures:
          0: { name: punctuation.definition.group.back-reference.saga }
          1: { name: punctuation.definition.group.back-reference.saga }
          2: { name: constant.numeric.index.saga }
          3: { patterns: [include: '#variables'] }
          4: { name: punctuation.separator.colon.saga }
        patterns: *regexp-patterns
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.saga
        captures:
          0: { name: punctuation.definition.group.named.saga }
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.saga
            captures:
              1: { name: punctuation.definition.group.named.saga }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.saga
        captures:
          0: { name: punctuation.definition.group.named.saga }
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.saga
            captures:
              1: { name: punctuation.definition.group.named.saga }
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.saga
        captures:
          1: { name: punctuation.definition.group.saga }
        patterns: *regexp-patterns

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - begin: (\\)(?=\s*$)
        end: ^\s*(?=\S)
        captures:
          1: { name: constant.character.escape.newline.saga }
      - include: '#named-escapes'
      - include: '#numeric-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.saga
        patterns:
          - include: '#attribute-selectors'
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.saga
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.saga
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.saga
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.saga
      - match: \\[abefprntv]
        name: constant.character.escape.saga
      - match: \\[a-z]
        name: constant.other.character-class.saga
      - match: \\[A-Z]
        name: constant.other.character-class.negated.saga
      - match: \\\p{S}
        name: constant.character.escape.symbol.saga
      - match: \\\p{P}
        name: constant.character.escape.punctuation.saga
      - match: \\[a-zA-Z\p{C}]
        name: invalid.illegal.escape.saga
      - match: \\\s
        name: constant.character.escape.space.saga
      - match: \\\p{L}
        name: constant.character.escape.letter.saga
      - match: \\\p{N}
        name: constant.character.escape.number.saga
      - match: \\.
        name: constant.character.escape.other.saga

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[abefprntv]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.saga
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          2:
            name: keyword.operator.range.saga
          3:
            name: constant.other.character-class.range.to.saga
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          4:
            name: keyword.operator.range.saga
          5:
            name: constant.other.character-class.range.by.saga
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
      - match: \|\|
        name: keyword.operator.union.saga
      - match: \&&
        name: keyword.operator.intersection.saga
      - match: \^\^
        name: keyword.operator.symmetric.saga
      - match: ~~
        name: keyword.operator.negation.saga
      - match: --
        name: keyword.operator.difference.saga

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.saga
        captures:
          1: { name: punctuation.definition.character-class.posix.saga }
        patterns:
          - include: '#attribute-selectors'
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.saga
        captures:
          1: { name: punctuation.definition.character-class.negated.saga }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.saga
        captures:
          1: { name: punctuation.definition.character-class.saga }
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    patterns:
      - match: ','
        name: punctuation.separator.sequence.saga
      - include: '#comments'
      - include: '#strings'
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.saga
      - include: '#string-escapes'
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.saga
      - match: \&\&|\|\||\^\^|\!
        name: keyword.operator.logical.saga
      - match: \b(in|is)\b
        name: keyword.operator.expression.$1.saga
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: { name: entity.other.attribute-name.key.saga }
          2: { name: keyword.operator.pattern.saga }
        end: (?=\&\&|\|\||\^\^|[\s,:;'"`({\[)}\]])
        name: string.unquoted.attribute-name.saga
        patterns:
          - include: '#style-property-values'
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: { name: entity.other.attribute-name.saga }
          2: { name: keyword.operator.pattern.saga }
      - include: '#operators'

  # JSX and Markdown

  jsx:
    applyEndPatternLast: true
    comment: Only captured when next to opening brackets, commas, semicolons, keywords, and operators. JSX also supports functional components, so we need to be careful to also match those.
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
              |go|defer|do|with|from|where
              |if|unless|else|then|def
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (?=<[>\p{Pc}\p{L}])
    end: (?=)|$
    patterns:
      - include: '#tag-component-name'

  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: meta.jsx.fragment.saga
        begin: (<)(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: { name: punctuation.definition.tag.saga }
        endCaptures:
          1: { name: punctuation.definition.tag.saga }
        patterns:
          - include: '#tag-termination'
      - comment: Tags that end > are trapped in tag-termination
        contentName: meta.jsx.saga
        begin: |
          (?x)
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?:::|\.?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
            \b
          )
          (?=[,;'"`({\[)}\]/>\s])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</)\O*?)>
          )
        beginCaptures:
          1: { name: punctuation.definition.tag.saga }
          2: { patterns: [include: '#tag-names'] }
        endCaptures:
          1: { patterns: [include: '#tag-names'] }
          2: { name: punctuation.definition.tag.saga }
          3: { name: punctuation.definition.tag.saga }
          4: { name: invalid.illegal.termination.saga }
        patterns:
          - include: '#tag-termination'
          - include: '#tag-attributes'

  jsx-comments:
    begin: (<!--)
    end: (-->)
    captures:
      1: { name: punctuation.definition.comment.saga }
    name: comment.block.html.saga
    patterns:
      - include: '#jsx-comments'

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.saga
    begin: (>)
    end: (</)
    captures:
      0: { name: punctuation.definition.tag.saga }
    patterns:
      - include: '#evaluated-code'
      - include: '#jsx-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#jsx-comments'

  tag-attributes:
    patterns:
      - include: '#literals'
      - include: '#embedded'
      - include: '#brackets'
      - applyEndPatternLast: true
        begin: \s*(=)\s*
        beginCaptures:
          1: { name: punctuation.separator.key-value.saga }
        end: (?=)|$
        name: meta.property.jsx.saga
        patterns:
          - include: '#style-property-values'
      - include: '#style-selectors'
      - include: '#attribute-names'
      - include: '#comments'
      - include: '#punctuation'

  attribute-names:
    match: \s*([\p{Pd}\w]+)\b\s*
    name: meta.attribute.saga
    captures:
      1:
        name: entity.other.attribute-name.${1:/camelcase}.saga
        patterns:
          - include: '#css-property-names'

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.saga

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: { name: punctuation.definition.entity.saga }
          2: { name: punctuation.definition.entity.saga }
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.saga
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.saga
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.saga
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.saga
      - captures: *jsx-entities
        match: (&)(?:\\.|[^({\[)}\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.saga
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.saga

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z0-9]+|#[0-9]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: { name: punctuation.definition.bold.markdown }
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#italic'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!({\[)}\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.image.markdown }
      8: { name: punctuation.definition.link.markdown }
      9: { name: string.other.link.description.title.markdown }
      10: { name: punctuation.definition.string.markdown }
      11: { name: punctuation.definition.string.markdown }
      12: { name: string.other.link.description.title.markdown }
      13: { name: punctuation.definition.string.markdown }
      14: { name: punctuation.definition.string.markdown }
      15: { name: string.other.link.description.title.markdown }
      16: { name: punctuation.definition.string.markdown }
      17: { name: punctuation.definition.string.markdown }
      18: { name: punctuation.definition.metadata.markdown }
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.description.markdown }
      4: { name: punctuation.definition.string.begin.markdown }
      5: { name: punctuation.definition.constant.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.markdown }
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns:
      - include: '#string-content'

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: { name: punctuation.definition.italic.markdown }
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  link-email:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      4: { name: punctuation.definition.link.markdown }
    match: (<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns:
      - include: '#string-content'

  link-inet:
    captures:
      1: { name: punctuation.definition.link.markdown }
      2: { name: markup.underline.link.markdown }
      3: { name: punctuation.definition.link.markdown }
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns:
      - include: '#string-content'

  link-inline:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.metadata.markdown }
      6: { name: punctuation.definition.link.markdown }
      7: { name: markup.underline.link.markdown }
      9: { name: punctuation.definition.link.markdown }
      10: { name: string.other.link.description.title.markdown }
      11: { name: punctuation.definition.string.begin.markdown }
      12: { name: punctuation.definition.string.end.markdown }
      13: { name: string.other.link.description.title.markdown }
      14: { name: punctuation.definition.string.begin.markdown }
      15: { name: punctuation.definition.string.end.markdown }
      16: { name: string.other.link.description.title.markdown }
      17: { name: punctuation.definition.string.begin.markdown }
      18: { name: punctuation.definition.string.end.markdown }
      19: { name: punctuation.definition.metadata.markdown }
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns:
      - include: '#string-content'

  link-ref:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: constant.other.reference.link.markdown }
      7: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  link-ref-literal:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      4: { name: punctuation.definition.string.end.markdown }
      5: { name: punctuation.definition.constant.begin.markdown }
      6: { name: punctuation.definition.constant.end.markdown }
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns:
      - include: '#string-content'

  link-ref-shortcut:
    captures:
      1: { name: punctuation.definition.string.begin.markdown }
      2: { name: string.other.link.title.markdown }
      3: { name: punctuation.definition.string.end.markdown }
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns:
      - include: '#string-content'

  raw:
    captures:
      1: { name: punctuation.definition.raw.markdown }
      2: { patterns: [include: '#string-content'] }
      3: { name: punctuation.definition.raw.markdown }
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns:
      - include: '#string-content'

  markdown:
    patterns:
      - include: '#comments'
      - include: '#jsx-entities'
      - include: '#html-tag'
      - include: '#string-content'
      - include: '#evaluated-code'
      - include: '#executed-code'
      - include: '#inline-styles'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

    repository:
      blockquote:
        comment: '> blockquote'
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.quote.begin.markdown }
          2:
            name: markup.quote.markdown
            patterns: [include: '#markdown']
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: '#markdown']

      unordered-list:
        comment: '- unordered list'
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.list.begin.markdown }
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']

      ordered-list:
        comment: '+ ordered list'
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: { name: punctuation.definition.list.begin.markdown }
          2:
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: { name: storage.type.method.saga }
        patterns:
          - include: $self

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: { name: storage.type.subroutine.saga }
        patterns:
          - include: $self

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.saga
        captures:
          1: { name: punctuation.definition.tag.saga }
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
            captures:
              1:
                name: entity.name.tag.saga
                patterns: *html-tag-names
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.id.saga
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.class.saga
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: { name: punctuation.definition.directive.saga }
            patterns:
          - include: $self
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: { name: punctuation.definition.mapping.saga }
            patterns:
              - include: '#style-properties'
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.parameters.saga }
            patterns:
              - include: '#tag-attributes'
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.saga
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.saga
            end: \s*((\1)(?!'+))
            captures:
              1: { name: punctuation.definition.string.saga }
            patterns: [include: '#markdown']
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.saga
            end: \s*((\1)(?!"+))
            captures:
              1: { name: punctuation.definition.string.saga }
            patterns: [include: '#markdown']
          - include: '#regexps'

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1:
            name: storage.type.style.saga
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: { name: keyword.operator.assignment.saga }
              - include: '#comments'
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#declaration-clause'
              - match: *entity-name
                name: entity.name.style.saga
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: '#style-properties']

  # Special code blocks

  html-builtins:
    patterns:
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  property-name:
    match: \b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:::|\.?)[\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
    name: meta.property-name.saga
    captures:
      1:
        patterns:
          - include: '#css-value-names'
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
            name: constant.other.saga
          - match: ([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: constant.language.saga
          - match: '\.|:|::'
            name: punctuation.separator.namespace.saga

  style-list:
    begin: (\[)\s*
    end: \s*(\])
    name: meta.brace.square.saga
    captures:
      1: { name: punctuation.definition.expression.saga }
    patterns:
      - include: '#punctuation'
      - include: '#style-property-values'
      - include: $self

  style-property-values:
    patterns:
      - include: '#style-list'
      - include: '#style-block'
      - include: '#literals'
      - include: '#property-name'
      - include: '#hex-colors'
      - include: '#embedded-expression'
      - include: '#html-builtins'
      - include: '#line-continuation'
      - include: '#jsx'
      - include: '#brackets'

  hex-colors:
    match: (#)\b(?:\h{3,4}|\h{6}|\h{8})\b
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: { name: punctuation.definition.constant.css }

  tag-names:
    match: \s*\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:::|\.?)[\p{Pc}\p{L}][\w\p{Pd}]*)*)\b\s*
    name: entity.name.tag.saga
    captures:
      1:
        name: entity.name.tag.saga
        patterns: *html-tag-names

  style-block:
    begin: (\{)\s*
    end: \s*(\})
    name: meta.brace.style.saga
    captures:
      1: { name: punctuation.section.property-list.saga }
    patterns:
      - include: '#style-properties'

  style-pair:
    applyEndPatternLast: true
    begin: \s*([\p{Pd}\w]+)\b(:)\s*
    end: (?=)|$
    name: meta.property.css.saga
    beginCaptures:
      1:
        name: support.type.property-name.saga
        patterns: [include: '#css-property-names']
      2:
        name: punctuation.separator.key-value.saga
    patterns:
      - include: '#style-property-values'
      - match: \s+
        name: meta.var.expr.saga

  style-properties:
    patterns:
      - include: '#comments'
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-pair'
      - include: '#style-rules'
      - include: '#style-block'
      - include: $self

  style-rules:
    patterns:
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: { name: keyword.operator.sum.saga }
          2: { name: keyword.operator.difference.saga }
          3: { name: keyword.operator.product.saga }
          4: { name: keyword.operator.quotient.saga }
          5: { name: keyword.operator.remainder.saga }
          6: { name: keyword.operator.only.saga }
          7: { name: keyword.operator.maybe.saga }
          8: { name: keyword.operator.intersection.saga }
          9: { name: keyword.operator.union.saga }
          10: { name: keyword.operator.symmetric.saga }
          11: { name: keyword.operator.negation.saga }
          12: { name: keyword.operator.macro.dollar.saga }
          13: { name: keyword.operator.private.saga }
          14: { name: keyword.operator.class.saga }
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: { name: punctuation.definition.parameters.saga }
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.saga
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: { name: punctuation.definition.selector.saga }
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|except|only|as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.saga
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*([@#&*|%.:~^]|::)(?=[\w$'"`])
        name: punctuation.definition.entity.saga
      - match: \s*(?<=\@)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: keyword.control.at-rule.saga
      - match: \s*(?<=\#)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.id.saga
      - match: \s*(?<=\.)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.class.saga
      - match: \s*(?<=::)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.pseudo-component.saga
      - match: \s*(?<=\~)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.key.saga
      - match: \s*(?<=\&)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.type.anchor.saga
      - match: \s*(?<=\*)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.type.alias.saga
      - match: \s*(?<=\%)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.function.saga
      - match: \s*(?<=\|)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.method.saga
      - match: \s*(?<=\:)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.procedure.saga
      - match: \s*(?<=\^)[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: entity.other.attribute-name.saga entity.name.property.saga

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'
      - include: '#nested-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.documentation.saga
        captures:
          1: { name: punctuation.definition.comment.saga }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc'
      - begin: \s*(/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*(\*/)
        name: comment.block.saga
        captures:
          1: { name: punctuation.definition.comment.saga }
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block'

  line-comments:
    patterns:
      - begin: \s*(///)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.documentation.saga
        captures:
          1: { name: punctuation.definition.comment.saga }
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
        end: \s*$
        name: comment.line.number-sign.saga
        captures:
          1: { name: punctuation.definition.comment.saga }
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.documentation.nested.saga
    captures:
      1: { name: punctuation.definition.comment.saga }
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc'

  nested-block:
    begin: (/\*)(?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)
    end: \s*(\*/)
    name: comment.block.nested.saga
    captures:
      1: { name: punctuation.definition.comment.saga }
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: { name: storage.type.class.jsdoc }
      3: { name: storage.modifier.jsdoc }

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: { name: keyword.module.jsdoc }
          2: { name: punctuation.jsdoc }
          3: { name: string.modulename.jsdoc }

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: { name: storage.type.class.jsdoc }

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|property|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: { name: storage.type.class.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: { name: string.linktext.jsdoc }
      2: { name: meta.brace.curly.jsdoc }
    endCaptures:
      1: { name: meta.brace.curly.jsdoc }
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: { name: storage.type.class.jsdoc }
          3: { name: string.jsdoc }

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: { name: support.type.builtin.primitive.jsdoc }

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: { name: meta.brace.curly.jsdoc }
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b\s*(:)
        captures:
          1: { name: variable.other.readwrite.jsdoc }
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: { name: variable.other.jsdoc }
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*(?=[\p{Pc}\p{L}])
        captures:
          1: { name: keyword.as.jsdoc }
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: { name: entity.name.class.jsdoc }
          2: { name: entity.name.function.jsdoc }
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.static.jsdoc }
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.instance.jsdoc }
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: entity.name.function.method.inner.jsdoc }
      - match: (\#)(event)(:)
        captures:
          1: { name: keyword.operator.accessor.jsdoc }
          2: { name: keyword.event.jsdoc }
          3: { name: keyword.operator.jsdoc }
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: '#jsdoc-string'

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  function-calls:
    patterns:
      - applyEndPatternLast: true
        name: meta.function.arguments.saga
        begin: |
          (?x)
          (?<=
            ['"`)}\]] |
            \\.\s |
            \b # qualified name
              (?:
                [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
                \b
                  (?:
                    (?:(?:[?!]?\.|[?!:]:)=?) # q-name separator
                    [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
                  )*
                \b
              )
            \b
          ) \s*
          (?=\b\w+)
        end: (?=)|$
        patterns:
          - include: '#literals'
          - include: '#variables'
          - include: '#brackets'
          - *qualified-name-separators
      - name: meta.function.arguments.saga
        match: |
          (?x)
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style
                |element|field|model|union
                |go|defer|do|with|from|where
                |if|unless|else|then|def
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b
          (?=
            \s*
            (?: # function application, composition and piping
                (?: \$ | \s\.\s | <\|{1,3} | <\+) ['"`({\[\w\s]
              | # C-style function call
                (?:[!?]\.=?|\.=)? \#? [({]
              | # generics
                (?:[!?]\.=?|\.=)? < ['"`({\[\w]
              | # literals
                ['"`\d]
              | (
                # ignore all keywords
                (?!
                  (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                  (?: # keywords
                    in|of|as|is|new
                    |to|till|thru|by|delete
                    |unset|ref|and|or|xor|not
                    |var|val|let|const|function
                    |procedure|method|type|class
                    |interface|enum|module|struct
                    |protocol|iterator|macro|query
                    |object|contract|trait|style
                    |element|field|model|union
                    |go|defer|do|with|from|where
                    |if|unless|else|then|def
                    |for|foreach|repeat|while|until
                    |try|throw|catch|finally|switch
                    |match|case|fallthru|default|goto
                    |break|continue|redo|retry
                    |return|yield|await|scope
                    |import|export|route
                    |debug|assert|check
                  )
                  (?!\B|\p{Pd}+\b)
                )
                (?:
                  \b
                  [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
                  \b
                  (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
                )*
                [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
              )
            )
          )
        captures:
          1: { patterns: [include: '#function-names'] }
      - name: meta.function.arguments.saga
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | \+>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
                |var|val|let|const|function
                |procedure|method|type|class
                |interface|enum|module|struct
                |protocol|iterator|macro|query
                |object|contract|trait|style
                |element|field|model|union
                |go|defer|do|with|from|where
                |if|unless|else|then|def
                |for|foreach|repeat|while|until
                |try|throw|catch|finally|switch
                |match|case|fallthru|default|goto
                |break|continue|redo|retry
                |return|yield|await|scope
                |import|export|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b
        captures:
          1: { patterns: [include: '#function-names'] }

  embedded-function-calls:
    patterns:
      - &function-names
        name: meta.function.name.saga
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? [({] ) # opening bracket
            |
            (?<= ^ # beginning of line
              | ['"`({\[)}\]\w\s] # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? [({] ) # opening bracket
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.saga
          2:
            patterns: *builtin-names
            name: entity.name.tag.saga support.class.component.saga
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.saga
          4:
            patterns: *builtin-names
            name: entity.name.function.method.saga
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.saga
          6:
            patterns: *builtin-names
            name: entity.name.type.saga
          7:
            patterns: *builtin-names
            name: entity.name.class.saga
          8:
            patterns: *builtin-names
            name: entity.name.function.saga

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.saga
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | \$ | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
            |
            (?<=
              (?: ^ | [,;'"`({\[)}\]\w\s] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | \$ | \s\.
                  )?
                  ['"`({\[)}\]\w\s]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.saga
          2:
            patterns: *builtin-names
            name: entity.name.tag.saga support.class.component.saga
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.saga
          4:
            patterns: *builtin-names
            name: entity.name.function.method.saga
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.saga
          6:
            patterns: *builtin-names
            name: entity.name.type.saga
          7:
            patterns: *builtin-names
            name: entity.name.class.saga
          8:
            patterns: *builtin-names
            name: entity.name.function.saga
      - include: '#variables'
      - include: '#primary-operators'

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            [?!] # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.optional.saga
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \*\*? # spread
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.spread.saga
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            ~~? # named
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.name.saga
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \& # reference
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.reference.saga
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \% # other
            [?!]? # optional or required
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.other.saga
      - match: |
          (?x)
          (?<=
            (?:
              ^ # SOL
              | (?:^ | [^|]) \| # open pipe
              | [({\[] # open bracket
              | [;,] # separator
              | [(|]\. \s # uncurried function
              | (?:^|[,;'"({\[)}\]\s])
                \b (?:
                  var|val|let|const|function
                  |procedure|method|type|class
                  |interface|enum|module|struct
                  |protocol|iterator|macro|query
                  |object|contract|trait|style
                  |element|field|model|union|as
                ) \b
                (?:$|[,;'"({\[)}\]\s]) # var/val/as keyword
            ) \s*
          )
            \s*
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`({\[)}\]]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)
              \s*
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`({\[]
          )
        name: variable.parameter.saga

  placeholder-variables:
    patterns:
      - match: (?i)\s*[?!][\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.saga
      - match: (?i)\s*\*\*?[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.saga
      - match: (?i)\s*~~?[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.saga
      - match: (?i)\s*&[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.saga
      - match: (?i)\s*%[?!]?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.saga
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.saga

  variables:
    patterns:
      - match: |
          (?x)
          (?<=
            \b # qualified name
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              (?:(?:[?!]?\.|[?!:]:)=?)
            \b
          )
          (?:\d\w+)
        name: variable.other.index.saga
      - comment: |
          Four types of variables:
          - _lead_underscore
          - UPPERCASE
          - PascalCase
          - camelCase
        match: |
          (?x) \b

          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
              |go|defer|do|with|from|where
              |if|unless|else|then|def
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
              |extends|implements
            )
            (?!\B|\p{Pd}+\b)
          )

          (?:
            (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
            (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
            )
            |
            (?: # Objects
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
            )
            (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
            |
            (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
            )
          ) \b
        captures:
          1: { name: variable.other.global.saga }
          2: { name: variable.other.constant.property.saga }
          3: { name: variable.other.property.static.saga }
          4: { name: variable.other.property.saga }
          5: { name: variable.other.global.saga }
          6: { name: variable.other.constant.object.saga }
          7: { name: variable.other.object.saga }
          8: { name: variable.other.object.saga }
          9: { name: variable.other.dollar.saga }
          10: { name: variable.other.constant.saga }
          11: { name: variable.other.class.saga }
          12: { name: variable.other.readwrite.saga }

  # Operators

  operators:
    patterns:
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#primary-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - comment: '? ternary operator'
        begin: (?<=^|[\s({\[])(\?)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: { name: keyword.operator.conditional.saga }
          2: { name: keyword.operator.conditional.saga }
        patterns:
          - include: $self
      - comment: '! ternary operator'
        begin: (?<=^|[\s({\[])(\!)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`({\[\w])
        captures:
          1: { name: keyword.operator.ternary.saga }
          2: { name: keyword.operator.ternary.saga }
        patterns:
          - include: $self

  infix-operators:
    patterns:
      - name: keyword.operator.infix.saga
        match: |
          (?xi)
          (?<=^|[\s({\[]) # opening
          (?:
            ( # 1: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 2: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 3: string / regex
              \+\+ | --
            ) |
            ( # 4: logical operator
              \&\& | \|\| | \^\^ | ! | /\\ | \\/
            ) |
            ( # 5: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 6: bitwise shift
              <<<? | >>>?
            ) |
            ( # 7: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 8: composition
              <\+ | \+>
            ) |
            ( # 9: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 10: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 11: equality
              == | != | === | !==
            ) |
            ( # 12: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 13: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 14: null coalescing
              \?+
            ) |
            ( # 15: non null coalescing
              !+
            ) |
            ( # 16: falsy coalescing
              \?:
            ) |
            ( # 17: truthy coalescing
              !:
            ) |
            ( # 18: function application
              [.$]
            ) |
            ( # 19: assignment
              :?=
            ) |
            ( # 20: range
              [>.]\.[.<] | \.\. | [=.]\.[.=]
            ) |
            ( # 21: fat arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 22: skinny arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 23: wavy arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 24: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 25: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 26: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 27: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: catch all
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
          )
          (?=$|[)}\]\s]) # closing
        captures:
          1: { name: keyword.operator.assignment.augmented.saga }
          2: { name: keyword.operator.arithmetic.saga }
          3: { name: keyword.operator.successor.saga }
          4: { name: keyword.operator.logical.saga }
          5: { name: keyword.operator.bitwise.saga }
          6: { name: keyword.operator.bitwise.shift.saga }
          7: { name: keyword.operator.pipeline.saga }
          8: { name: keyword.operator.compose.saga }
          9: { name: keyword.operator.class.saga }
          10: { name: keyword.operator.relational.saga }
          11: { name: keyword.operator.comparison.saga }
          12: { name: keyword.operator.similarity.saga }
          13: { name: keyword.operator.function.saga }
          14: { name: keyword.operator.null-coalescing.saga }
          15: { name: keyword.operator.coalescing.saga }
          16: { name: keyword.operator.conditional.saga }
          17: { name: keyword.operator.ternary.saga }
          18: { name: keyword.operator.macro.saga }
          19: { name: keyword.operator.assignment.saga }
          20: { name: keyword.operator.range.saga }
          21: { name: keyword.operator.arrow.fat.saga }
          22: { name: keyword.operator.arrow.skinny.saga }
          23: { name: keyword.operator.arrow.wavy.saga }
          24: { name: keyword.operator.logical.custom.saga }
          25: { name: keyword.operator.arithmetic.custom.saga }
          26: { name: keyword.operator.prototype.custom.saga }
          27: { name: keyword.operator.accessor.custom.saga }
          28: { name: keyword.operator.comparison.custom.saga }
          29: { name: keyword.operator.relational.custom.saga }
          30: { name: keyword.operator.private.custom.saga }
          31: { name: keyword.operator.math.custom.saga }
          32: { name: keyword.operator.currency.custom.saga }
          33: { name: keyword.operator.ascii.custom.saga }
          34: { name: keyword.operator.infix.saga }

  primary-operators:
    patterns:
      - name: keyword.operator.primary.saga
        match: |
          (?x)
          (?<=['"`)}\]\w]|\\.) # closing
          (?:
            ( # 1: optional accessor
            \?[.:]=?
            ) |
            ( # 2: assertion/call operator
              ![.:]=?
            ) |
            ( # 3: accessor operator
              (?:::|\.)=?
            ) |
            ( # 4: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`({\[)}\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 5: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 6: string / regex
              \+\+ | --
            ) |
            ( # 7: logical operator
              \&\& | \|\| | \^\^ | ! | /\\ | \\/
            ) |
            ( # 8: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 9: bitwise shift
              <<<? | >>>?
            ) |
            ( # 10: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 11: composition
              <\+ | \+>
            ) |
            ( # 12: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 13: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 14: equality
              == | != | === | !==
            ) |
            ( # 15: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 16: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 17: null coalescing
              \?+
            ) |
            ( # 18: non null coalescing
              !+
            ) |
            ( # 19: falsy coalescing
              \?:
            ) |
            ( # 20: truthy coalescing
              !:
            ) |
            ( # 21: function application
              [.$]
            ) |
            ( # 22: assignment
              :?=
            ) |
            ( # 23: range
              [>.]\.[.<] | \.\. | [=.]\.[.=]
            ) |
            ( # 24: fat arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 25: skinny arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 26: wavy arrow
                [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]* # left side
            ) |
            ( # 27: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 28: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 29: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 30: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 31: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 32: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 33: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 34: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 35: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 36: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            ) |
            ( # 37: catch all
              [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
          )
          (?=['"`({\[\w]) # opening
        captures:
          1: { name: keyword.operator.optional.saga }
          2: { name: keyword.operator.assert.saga }
          3: { name: keyword.operator.accessor.saga }
          4: { name: keyword.operator.assignment.augmented.saga }
          5: { name: keyword.operator.arithmetic.saga }
          6: { name: keyword.operator.successor.saga }
          7: { name: keyword.operator.logical.saga }
          8: { name: keyword.operator.bitwise.saga }
          9: { name: keyword.operator.bitwise.shift.saga }
          10: { name: keyword.operator.pipeline.saga }
          11: { name: keyword.operator.compose.saga }
          12: { name: keyword.operator.class.saga }
          13: { name: keyword.operator.relational.saga }
          14: { name: keyword.operator.comparison.saga }
          15: { name: keyword.operator.similarity.saga }
          16: { name: keyword.operator.function.saga }
          17: { name: keyword.operator.null-coalescing.saga }
          18: { name: keyword.operator.coalescing.saga }
          19: { name: keyword.operator.conditional.saga }
          20: { name: keyword.operator.ternary.saga }
          21: { name: keyword.operator.macro.saga }
          22: { name: keyword.operator.assignment.saga }
          23: { name: keyword.operator.range.saga }
          24: { name: keyword.operator.arrow.fat.saga }
          25: { name: keyword.operator.arrow.skinny.saga }
          26: { name: keyword.operator.arrow.wavy.saga }
          27: { name: keyword.operator.logical.custom.saga }
          28: { name: keyword.operator.arithmetic.custom.saga }
          29: { name: keyword.operator.prototype.custom.saga }
          30: { name: keyword.operator.accessor.custom.saga }
          31: { name: keyword.operator.comparison.custom.saga }
          32: { name: keyword.operator.relational.custom.saga }
          33: { name: keyword.operator.private.custom.saga }
          34: { name: keyword.operator.math.custom.saga }
          35: { name: keyword.operator.currency.custom.saga }
          36: { name: keyword.operator.ascii.custom.saga }
          37: { name: keyword.operator.primary.saga }

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*
      ['"`({\[\w])
    name: keyword.operator.prefix.saga
    captures:
      1: { name: keyword.operator.module.all.saga }
      2: { name: keyword.operator.increment.saga }
      3: { name: keyword.operator.decrement.saga }
      4: { name: keyword.operator.intersection.saga }
      5: { name: keyword.operator.union.saga }
      6: { name: keyword.operator.symmetric.saga }
      7: { name: keyword.operator.logical.saga }
      8: { name: keyword.operator.private.saga }
      9: { name: keyword.operator.decorator.saga }
      10: { name: keyword.operator.bitwise.not.saga }
      11: { name: keyword.operator.existential.saga }
      12: { name: keyword.operator.assignment.saga }
      13: { name: keyword.operator.pipeline.saga }
      14: { name: keyword.operator.private.saga }
      15: { name: keyword.operator.prefix.saga }

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.saga
    captures:
      1: { name: keyword.operator.module.all.saga }
      2: { name: keyword.operator.increment.saga }
      3: { name: keyword.operator.decrement.saga }
      4: { name: keyword.operator.intersection.saga }
      5: { name: keyword.operator.union.saga }
      6: { name: keyword.operator.symmetric.saga }
      7: { name: keyword.operator.assert.saga }
      8: { name: keyword.operator.private.saga }
      9: { name: keyword.operator.decorator.saga }
      10: { name: keyword.operator.bitwise.saga }
      11: { name: keyword.operator.optional.saga }
      12: { name: keyword.operator.assignment.saga }
      13: { name: keyword.operator.pipeline.saga }
      14: { name: keyword.operator.private.saga }
      15: { name: keyword.operator.suffix.saga }

  # Clauses and Keywords

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: { name: punctuation.definition.parameters.saga }
    patterns:
      - include: '#param-bracket-content'
      - include: $self

  declaration-clause:
    name: meta.declaration.saga
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=::|\.)
        name: entity.name.namespace.saga
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(implements)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: { name: storage.type.$1.saga }
        patterns:
          - match: ::|\.
            name: punctuation.separator.namespace.saga
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=::|\.)
            name: entity.name.namespace.saga
          - match: *class-name
            name: entity.name.trait.saga
          - include: '#comments'
          - include: '#type-square-brackets'
          - include: '#brackets'
          - include: '#comma'
          - include: '#line-continuation'
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(extends)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: { name: storage.type.$1.saga }
        patterns:
          - match: ::|\.
            name: punctuation.separator.namespace.saga
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=::|\.)
            name: entity.name.module.saga
          - match: *class-name
            name: entity.name.class.saga
          - include: '#comments'
          - include: '#type-square-brackets'
          - include: '#brackets'
          - include: '#comma'
          - include: '#line-continuation'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.saga
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - include: '#type-keywords'
      - include: '#type-square-brackets'
      - include: '#modifiers'
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.section.class.saga }
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.block.saga }
        patterns:
          - include: $self
      - include: '#brackets'
      - include: '#type-signature'
      - include: '#literals'
      - include: '#decorators'
      - match: ::|\.
        name: punctuation.separator.namespace.saga
      - match: \s+
        name: meta.block.saga

  modifier-keywords:
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
            )
            (?!\B|\p{Pd}+\b)
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|let|const|function
          |procedure|method|type|class
          |interface|enum|module|struct
          |protocol|iterator|macro|query
          |object|contract|trait|style
          |element|field|model|union
        )
        (?!\B|\p{Pd}+\b)
      )
    captures:
      1:
        patterns:
          - include: '#modifiers'

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            public|private|protected|final|readonly|override
            |global|local|intern|extern|implicit|explicit
            |post|get|set|put|delete|required|optional
            |checked|unchecked|delegate|safe|unsafe|virtual
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.modifier.saga
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            sealed|abstract|impure|pure|early|late
            |covar|contra|a?sync|static|dynamic|lazy
            |eager|bound|free|unique|struct|union
            |changed|unchanged|open|opened|closed?
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.modifier.declaration.saga
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            recursive|operator|curried|inline|prefix
            |infix|suffix|unary|left|right
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.modifier.function.saga

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl|def)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.declare.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.saga
      - match: |
          (?x)
          \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (
              function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
            )
            (?!\B|\p{Pd}+\b)
          \s*
        name: storage.type.$1.saga

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless|else)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.conditional.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|repeat|while|until)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.loop.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|finally|then)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.trycatch.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|default)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.switch.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|return|await|scope|yield|goto|fallthru)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.flow.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.module.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|do|from|ref|go|defer)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.$1.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.$1.saga

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(delete)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.delete.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|till|thru|by)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.range.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.void.saga
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.logical.saga

  keywords:
    patterns:
      - include: '#modifier-keywords'
      - include: '#validation-expression'
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

    repository:
      control-expression:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|redo|retry|mark|goto|fallthru)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.control.flow.saga }
        patterns:
          - match: *entity-name
            name: constant.other.label.saga

      module-expression:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.control.module.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|as|only|except|default)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.module.saga
              - include: '#type-keywords'
              - include: '#declarations'
              - include: '#strings'
              - include: '#symbols'
              - include: '#type-operators'
              - match: ','
                name: punctuation.separator.comma.saga
              - match: *entity-name
                name: variable.other.readwrite.alias.saga

      validation-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: { name: keyword.control.validate.saga }
        end: (?=[,;)}\]])
        patterns:
          - match: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  (?:
                    require|ensure|(de|in)(crease|crement)|throw|read|assume
                    |return|yield|varie|change|create|alter|delete|drop|rename
                    |reveal
                  )s?
                  | modify|modifies
                )
              (?!\B|\p{Pd}+\b)
              \s*
            name: keyword.control.validate.saga
          - include: $self

      query-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: { name: keyword.control.query.saga }
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      query-body:
        patterns:
          - include: '#in-clause'
          - include: '#where-clause'
          - include: '#join-clause'
          - include: '#sort-clause'
          - include: '#select-clause'
          - include: '#group-clause'
          - include: '#limit-clause'
          - include: '#reduce-clause'

        repository:
          in-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  in|of
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
              2: { patterns: [include: $self] }
              3: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          join-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  \b (?:full|part|self|cross)? \b \s*
                  \b (?:inner|outer|left|right)? \b \s*
                  \b (?:join)
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
              2: { patterns: [include: $self] }
              3: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.saga
              - include: '#query-body'
              - include: $self

          where-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  where|having|filter|reject
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          sort-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  \b (?:sort|order) \b \s*
                  \b (?:asc|desc)? \b \s*
                  \b (?:by|with)?
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          select-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  \b (?:select|map) \b \s*
                  \b (?:unique|any|all|some|every)?
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.saga
              - include: '#query-body'
              - include: $self

          limit-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  \b (?:take|drop|limit|offset) \b \s*
                  \b (?:first|last|head|tail)?
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.saga
              - include: '#query-body'
              - include: $self

          reduce-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  \b (?:fold|reduce|scan) \b \s*
                  \b (?:first|last|left|right)?
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.saga
              - include: '#query-body'
              - include: $self

          group-clause:
            begin: |
              (?x)
              \s*
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                (
                  group
                )
              (?!\B|\p{Pd}+\b)
              \s*
            beginCaptures:
              1: { name: keyword.control.query.saga }
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|[io]nto)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.saga
              - include: '#query-body'
              - include: $self

  declarations:
    patterns:
      - include: '#variable'
      - include: '#declare'
      - include: '#style'
      - include: '#markup'
      - include: '#function'
      - include: '#procedure'
      - include: '#method'
      - include: '#class'
      - include: '#interface'
      - include: '#enum'
      - include: '#module'
      - include: '#iterator'
      - include: '#macro'
      - include: '#query'
      - include: '#object'
      - include: '#trait'
      - include: '#component'
      - include: '#field'
      - include: '#contract'
      - include: '#struct'
      - include: '#protocol'
      - include: '#model'
      - include: '#union'

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.style.saga }
        name: meta.style.saga
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.style.saga

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(element)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.component.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.component.saga
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val|let|const)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.variable.saga }
        patterns:
          - include: '#modifiers'
          - include: '#decorators'

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.other.declare.saga }
        patterns:
          - include: '#modifiers'
          - include: '#decorators'

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(function)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.function.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.function.saga

      union:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(union)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.union.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.union.saga

      method:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(method)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.method.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.method.saga

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(procedure)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.procedure.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.procedure.saga

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.class.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.class.saga

      interface:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(interface)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.interface.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.interface.saga

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.enum.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.enum.saga

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.module.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.module.saga

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iterator)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.iterator.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.iterator.saga

      model:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(model)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.model.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.model.saga

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.macro.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.macro.saga

      query:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(query)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.query.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.query.saga

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.object.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.object.saga

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.trait.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.trait.saga

      contract:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(contract)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.contract.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.contract.saga

      protocol:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(protocol)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.protocol.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.protocol.saga

      struct:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.struct.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.struct.saga

      field:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(field)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: { name: storage.type.field.saga }
        patterns:
          - include: '#declaration-clause'
          - match: *entity-name
            name: entity.name.field.saga

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|element|field|model|union
            )
            \b
          )
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.method.saga }
          2: { name: keyword.operator.assignment.saga }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.method.saga }
          2: { name: keyword.operator.assignment.saga }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.saga }
        endCaptures:
          1: { name: punctuation.separator.arguments.saga }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|element|field|model|union
            )
            \b
          )
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.saga }
          2: { name: keyword.operator.assignment.saga }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.saga }
          2: { name: keyword.operator.assignment.saga }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.saga }
        endCaptures:
          1: { name: punctuation.separator.arguments.saga }
        patterns:
          - include: '#param-bracket-content'
          - include: $self

  argument-list:
    name: meta.function.arguments.saga
    begin: |
      (?x)
      (?<=
        (?:
            # beginning of line
            ^
          | # separator
            [,;]
          | # opening bracket
            [({\[]
          | # postfix or infix operator
            [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+ \s
        ) \s*
        | # a keyword
        (?:
          (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
          \b
            (?: # keywords
              in|of|as|is|new
              |to|till|thru|by|delete
              |unset|ref|and|or|xor|not
              |var|val|let|const|function
              |procedure|method|type|class
              |interface|enum|module|struct
              |protocol|iterator|macro|query
              |object|contract|trait|style
              |element|field|model|union
              |go|defer|do|with|from|where
              |if|unless|else|then|def
              |for|foreach|repeat|while|until
              |try|throw|catch|finally|switch
              |match|case|fallthru|default|goto
              |break|continue|redo|retry
              |return|yield|await|scope
              |import|export|route
              |debug|assert|check
            )
          \b
        ) \s*
      ) \s*
      (\|)(?!\|)
    captures:
      1: { name: punctuation.separator.arguments.saga }
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: '#param-bracket-content'
      - include: $self

  clauses:
    patterns:
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#switch-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#do-clause'
      - include: '#type-clause'
      - include: '#new-clause'

    repository:
      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?!\B|\p{Pd}+\b)
        end: (?=)|$
        beginCaptures:
          1: { name: keyword.operator.expression.$1.saga }
        patterns:
          - match: *entity-name
            name: entity.name.instance.saga
          - include: '#type-keywords'
          - include: '#type-square-brackets'
          - include: '#parameter-brackets'
          - include: '#round-brackets'

      type-clause:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: { name: keyword.operator.expression.$1.saga }
            patterns:
              - include: '#types'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            captures:
              1: { name: keyword.other.typedef.saga }
            patterns:
              - include: '#types'
              - match: \s*([?:]?=)\s*
                captures:
                  1: { name: keyword.operator.assignment.saga }

      catch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.catch.saga
        captures:
          1: { name: keyword.control.error.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.saga
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: { name: punctuation.definition.block.saga }
            patterns:
              - include: '#catch-case-clause'
              - include: $self

      catch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: { name: keyword.control.error.saga }
              2: { name: punctuation.definition.case-statement.saga }
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: { name: keyword.control.error.saga }
            endCaptures:
              1: { name: punctuation.definition.case-statement.saga }
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                end: (?=)|$
                beginCaptures:
                  1: { name: keyword.control.error.saga }
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.saga
              - include: '#type-keywords'
              - include: $self

      for-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|foreach|while|until)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.for.saga
        captures:
          1: { name: keyword.control.loop.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.loop.saga
              - include: $self

      if-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|unless)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.if.saga
        captures:
          1: { name: keyword.control.conditional.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.conditional.saga
              - include: $self

      match-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.match.saga
        captures:
          1: { name: keyword.control.match.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.match.saga
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: { name: punctuation.definition.block.saga }
            patterns:
              - include: '#match-case-clause'
              - include: $self

      switch-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.switch.saga
        captures:
          1: { name: keyword.control.switch.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.switch.saga
              - include: $self
          - begin: \s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: { name: punctuation.definition.block.saga }
            patterns:
              - include: '#switch-case-clause'
              - include: $self

      switch-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: { name: keyword.control.switch.saga }
              2: { name: punctuation.definition.case-statement.saga }
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: { name: keyword.control.switch.saga }
            endCaptures:
              1: { name: punctuation.definition.case-statement.saga }
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                end: (?=)|$
                beginCaptures:
                  1: { name: keyword.control.switch.saga }
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.switch.saga
              - include: '#type-keywords'
              - include: $self

      match-case-clause:
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(default)\b\s*(:)
            captures:
              1: { name: keyword.control.match.saga }
              2: { name: punctuation.definition.case-statement.saga }
          - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
            end: \s*(:)(?=['"`({\[)}\]\w\s])|$
            beginCaptures:
              1: { name: keyword.control.match.saga }
            endCaptures:
              1: { name: punctuation.definition.case-statement.saga }
            patterns:
              - include: '#argument-list'
              - applyEndPatternLast: true
                begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
                end: (?=)|$
                beginCaptures:
                  1: { name: keyword.control.match.saga }
                patterns:
                  - include: '#types'
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.match.saga
              - include: '#type-keywords'
              - include: $self

      with-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*(?=\()
        end: (?=)|$
        name: meta.with.saga
        captures:
          1: { name: keyword.control.with.saga }
        patterns:
          - begin: \s*(\()\s*
            end: \s*(\))
            captures:
              1: { name: punctuation.definition.expression.saga }
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(await|as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.with.saga
              - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              function|procedure|method|type
              |class|interface|enum|module|struct|protocol
              |iterator|macro|query|object|contract
              |trait|style|element|field|model|union
            )
            \b
          )
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.saga }
          2: { name: punctuation.separator.key-value.saga }
          3: { patterns: [include: '#modifier-keywords'] }
      - begin: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                public|private|protected|final|readonly|override
                |global|local|intern|extern|implicit|explicit
                |post|get|set|put|delete|required|optional
                |checked|unchecked|delegate|safe|unsafe|virtual

                |sealed|abstract|impure|pure|early|late
                |covar|contra|a?sync|static|dynamic|lazy
                |eager|bound|free|unique|struct|union
                |changed|unchanged|open|opened|closed?

                |recursive|operator|curried|inline|prefix
                |infix|suffix|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.saga
        captures:
          1: { name: entity.name.saga }
          2: { name: punctuation.separator.key-value.saga }
          3: { patterns: [include: '#modifier-keywords'] }
          4: { name: punctuation.separator.arguments.saga }
        endCaptures:
          1: { name: punctuation.separator.arguments.saga }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - match: |
          (?x)
          (?<=(?:^ | [{;,]) \s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`({\[)}\]\w\s])
        name: meta.object-literal.key.saga
        captures:
          1:
            name: constant.other.object.key.saga
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#string-content'

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(`)\s*(?=/[/*](?![\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+)|$)
    end: ^\s*(?=\S)
    captures:
      1: { name: punctuation.separator.continuation.line.saga }
    patterns:
      - include: '#comments'
  comma:
    match: \s*(,)
    name: punctuation.separator.expression.saga
  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.saga
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.saga

  brackets:
    patterns:
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'
      - include: '#angle-brackets'

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]\w\s])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: { name: punctuation.type.arguments.saga }
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'
          - include: '#type-signature'

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.saga
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]*):(?=['"`({\[\w\s]|$)
            name: punctuation.separator.key-value.saga

    patterns:
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.binding-pattern.object.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.mapping.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|till|thru|by|delete
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.dictionary.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.section.class.saga }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|[,;'"`)}\]\w\s]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.block.saga }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.mapping.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;({\[)}\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`({\[)}\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.dictionary.saga }
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.section.class.saga }
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        name: meta.brace.curly.saga
        captures:
          1: { name: punctuation.definition.block.saga }
        patterns:
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.saga
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.saga
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.saga

    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.parameters.saga }
        patterns:
          - include: '#param-bracket-content'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.binding-pattern.tuple.saga }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\#\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.tuple.saga }
        patterns:
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        name: meta.brace.round.saga
        captures:
          1: { name: punctuation.definition.expression.saga }
        patterns:
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.saga

    patterns:
      - begin: |
          (?x)
          (?<= # literal
              (?: [\w'"`)}\]] | \\.) \s*
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.attribute-selector.saga }
        patterns:
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val|let|const
              )
            \b
            (?:$|[,;'"({\[)}\]\s]) # beside a delimiter or space
            \s*
          )
          (\#?\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.binding-pattern.array.saga }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.sequence.saga }
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        name: meta.brace.square.saga
        captures:
          1: { name: punctuation.definition.array.saga }
        patterns:
          - include: '#punctuation'
          - include: $self

  # Support

  css-property-names:
    match: (?x)\b( additive-symbols|additiveSymbols|adjust|after|align|align-content|align-items|align-last|align-self|alignContent|alignItems|alignLast|alignment|alignment-adjust|alignment-baseline|alignmentAdjust|alignmentBaseline|alignSelf|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animationDelay|animationDirection|animationDuration|animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|appearance|attachment|azimuth|backdrop-filter|backdropFilter|backface-visibility|backfaceVisibility|background|background-attachment|background-blend-mode|background-break|background-clip|background-color|background-image|background-origin|background-position|background-position-[xy]|background-repeat|background-size|backgroundAttachment|backgroundBlendMode|backgroundBreak|backgroundClip|backgroundColor|backgroundImage|backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|balance|baseline|baseline-shift|baselineShift|before|bidi|binding|bleed|block-size|blockSize|bookmark|bookmark-label|bookmark-level|bookmark-target|bookmarkLabel|bookmarkLevel|bookmarkTarget|border|border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color|border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end|border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color|border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width|border-length|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius|border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor|borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius|borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage|borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd|borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor|borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth|borderLength|borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius|borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle|borderTopWidth|borderWidth|bottom|bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|box-align|box-decoration-break|box-direction|box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|boxAlign|boxDecorationBreak|boxDirection|boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|boxShadow|boxSizing|break|break-after|break-before|break-inside|breakAfter|breakBefore|breakInside|caption-side|captionSide|caret-color|caretColor|character|clear|clip|clip-path|clip-rule|clipPath|clipRule|collapse|color|color-adjust|color-interpolation|color-interpolation-filters|color-profile|color-rendering|colorAdjust|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|column|column-break-after|column-break-before|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columnBreakAfter|columnBreakBefore|columnCount|columnFill|columnGap|columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columns|columnSpan|columnWidth|contain|content|count|counter|counter-increment|counter-reset|counterIncrement|counterReset|crop|cue|cue-after|cue-before|cueAfter|cueBefore|cursor|cx|cy|decoration|decoration-break|decorationBreak|delay|direction|display|display-model|display-role|displayModel|displayRole|dominant-baseline|dominantBaseline|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust|dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|empty-cells|emptyCells|enable-background|enableBackground|fallback|family|fill|fill-opacity|fill-rule|fillOpacity|fillRule|filter|fit|fit-position|fitPosition|flex|flex-basis|flex-direction|flex-flow|flex-group|flex-grow|flex-shrink|flex-wrap|flexBasis|flexDirection|flexFlow|flexGroup|flexGrow|flexShrink|flexWrap|float|float-offset|floatOffset|flood-color|flood-opacity|floodColor|floodOpacity|font|font-display|font-family|font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch|font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures|font-variant-numeric|font-variant-position|font-variation-settings|font-weight|fontDisplay|fontFamily|fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures|fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyph-orientation-horizontal|glyph-orientation-vertical|glyphOrientationHorizontal|glyphOrientationVertical|grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start|grid-columns|grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-rows|grid-template|grid-template-areas|grid-template-columns|grid-template-rows|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumns|gridColumnStart|gridGap|gridRow|gridRowEnd|gridRowGap|gridRows|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows|hanging-punctuation|hangingPunctuation|header|height|hyphenate|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphenateAfter|hyphenateBefore|hyphenateCharacter|hyphenateLines|hyphenateResource|hyphens|icon|image|image-orientation|image-rendering|image-resolution|imageOrientation|imageRendering|imageResolution|ime-mode|imeMode|increment|indent|index|initial-after-adjust|initial-after-align|initial-before-adjust|initial-before-align|initial-letter|initial-letter-align|initial-size|initial-value|initialAfterAdjust|initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialLetter|initialLetterAlign|initialSize|initialValue|inline-box-align|inline-size|inlineBoxAlign|inlineSize|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation|iteration-count|iterationCount|justify|justify-content|justify-items|justify-self|justifyContent|justifyItems|justifySelf|kerning|label|left|left-color|left-style|left-width|leftColor|leftStyle|leftWidth|length|letter-spacing|letterSpacing|level|lighting-color|lightingColor|line|line-break|line-clamp|line-height|line-stacking|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|lineBreak|lineClamp|lineHeight|lines|lineStacking|lineStackingRuby|lineStackingShift|lineStackingStrategy|list|list-style|list-style-image|list-style-position|list-style-type|listStyle|listStyleImage|listStylePosition|listStyleType|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start|margin-left|margin-right|margin-top|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart|marginLeft|marginRight|marginTop|mark|mark-after|mark-before|markAfter|markBefore|marker-end|marker-mid|marker-start|markerEnd|markerMid|markerStart|marks|marquee|marquee-direction|marquee-play-count|marquee-speed|marquee-style|marqueeDirection|marqueePlayCount|marqueeSpeed|marqueeStyle|mask|mask-border|mask-border-mode|mask-border-outset|mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode|mask-origin|mask-position|mask-repeat|mask-size|mask-type|maskBorder|maskBorderMode|maskBorderOutset|maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode|maskOrigin|maskPosition|maskRepeat|maskSize|maskType|max|max-block-size|max-height|max-inline-size|max-lines|max-width|max-zoom|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth|maxZoom|min|min-block-size|min-height|min-inline-size|min-width|min-zoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mix-blend-mode|mixBlendMode|model|move-to|moveTo|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|navDown|navIndex|navLeft|navRight|navUp|negative|new|numeral|object-fit|object-position|objectFit|objectPosition|offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|ordinal-group|ordinalGroup|orient|orientation|origin|orphans|outline|outline-color|outline-offset|outline-style|outline-width|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflow-[xy]|overflow-anchor|overflow-block|overflow-inline|overflow-style|overflow-wrap|overflow[XY]|overflowAnchor|overflowBlock|overflowInline|overflowStyle|overflowWrap|overhang|overscroll-behavior|overscroll-behavior-[xy]|overscroll-behavior-block|overscroll-behavior-inline|overscrollBehavior|overscrollBehavior[XY]|overscrollBehaviorBlock|overscrollBehaviorInline|pack|pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left|padding-right|padding-top|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft|paddingRight|paddingTop|page|page-break-after|page-break-before|page-break-inside|page-policy|pageBreakAfter|pageBreakBefore|pageBreakInside|pagePolicy|paint-order|paintOrder|pause|pause-after|pause-before|pauseAfter|pauseBefore|perspective|perspective-origin|perspectiveOrigin|phonemes|pitch|pitch-range|pitchRange|place-content|place-items|place-self|placeContent|placeItems|placeSelf|play-count|play-during|play-state|playCount|playDuring|playState|point|pointer-events|pointerEvents|position|prefix|presentation|presentation-level|presentationLevel|profile|property|punctuation|punctuation-trim|punctuationTrim|quotes|r|radius|range|rate|rendering-intent|renderingIntent|repeat|replace|reset|resize|resolution|resource|respond-to|respondTo|rest|rest-after|rest-before|restAfter|restBefore|richness|right|right-color|right-style|right-width|rightColor|rightStyle|rightWidth|role|rotate|rotation|rotation-point|rotationPoint|row-gap|rowGap|rows|ruby|ruby-align|ruby-merge|ruby-overhang|ruby-position|ruby-span|rubyAlign|rubyMerge|rubyOverhang|rubyPosition|rubySpan|rule|rule-color|rule-style|rule-width|ruleColor|ruleStyle|ruleWidth|rx|ry|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start|scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right|scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom|scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right|scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type|scrollbar-color|scrollbar-gutter|scrollbar-width|scrollbarColor|scrollbarGutter|scrollbarWidth|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart|scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight|scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom|scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight|scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType|shadow|shape-image-threshold|shape-margin|shape-outside|shape-rendering|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size|size-adjust|sizeAdjust|sizing|space|space-collapse|spaceCollapse|spacing|span|speak|speak-as|speak-header|speak-numeral|speak-punctuation|speakAs|speakHeader|speakNumeral|speakPunctuation|speech|speech-rate|speechRate|speed|src|stacking|stacking-ruby|stacking-shift|stacking-strategy|stackingRuby|stackingShift|stackingStrategy|stop-color|stop-opacity|stopColor|stopOpacity|stress|stretch|string-set|stringSet|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|style|style-image|style-position|style-type|styleImage|stylePosition|styleType|suffix|symbols|system|tab-size|table-layout|tableLayout|tabSize|target|target-name|target-new|target-position|targetName|targetNew|targetPosition|text|text-align|text-align-last|text-anchor|text-combine-upright|text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style|text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-height|text-indent|text-justify|text-orientation|text-outline|text-overflow|text-rendering|text-replace|text-shadow|text-size-adjust|text-transform|text-underline-position|text-wrap|textAlign|textAlignLast|textAnchor|textCombineUpright|textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle|textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textHeight|textIndent|textJustify|textOrientation|textOutline|textOverflow|textRendering|textReplace|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|textWrap|timing-function|timingFunction|top|top-color|top-left-radius|top-right-radius|top-style|top-width|topColor|topLeftRadius|topRightRadius|topStyle|topWidth|touch-action|touchAction|transform|transform-box|transform-origin|transform-style|transformBox|transformOrigin|transformStyle|transition|transition-delay|transition-duration|transition-property|transition-timing-function|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction|translate|trim|unicode|unicode-bidi|unicode-range|unicodeBidi|unicodeRange|up|user-select|user-zoom|userSelect|userZoom|variant|vertical-align|verticalAlign|visibility|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range|voice-rate|voice-stress|voice-volume|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange|voiceRate|voiceStress|voiceVolume|volume|weight|white|white-space|white-space-collapse|whiteSpace|whiteSpaceCollapse|widows|width|will-change|willChange|word|word-break|word-spacing|word-wrap|wordBreak|wordSpacing|wordWrap|wrap|writing-mode|writingMode|x|y|z-index|zIndex|zoom )(?!\B|\p{Pd}+\b)
    name: support.type.property-name.css.saga

  css-value-names:
    comment: TODO
    patterns:
      - match: (?x)\b( aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-standard-color-name.css.saga
      - match: (?x)\b( aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-extended-color-name.css.saga
      - match: (?x)\b( currentColor )(?!\B|\p{Pd}+\b)
        name: support.constant.color.current.css.saga
      - match: (?x)\b( ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText )(?!\B|\p{Pd}+\b)
        name: support.constant.color.system.css.saga
      - match: (?x)\b( above|absolute|active|add|additive|after-edge|afterEdge|alias|all|all-petite-caps|all-scroll|all-small-caps|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternate-reverse|alternateReverse|always|antialiased|auto|auto-pos|autoPos|available|avoid|avoid-column|avoid-page|avoid-region|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|before-edge|beforeEdge|below|bevel|bidi-override|bidiOverride|blink|block|block-axis|block-end|block-start|blockAxis|blockEnd|blockStart|bold|bolder|border|border-box|borderBox|both|bottom|bottom-outside|bottomOutside|break-all|break-word|breakAll|breakWord|bullets|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closeQuote|closest-corner|closest-side|closestCorner|closestSide|col-resize|collapse|color|color-burn|color-dodge|colorBurn|colorDodge|colResize|column|column-reverse|columnReverse|common-ligatures|commonLigatures|compact|condensed|contain|content|content-box|contentBox|contents|context-menu|contextMenu|contextual|copy|cover|crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|diagonalFractions|difference|digits|disabled|disc|discretionary-ligatures|discretionaryLigatures|distribute|distribute-all-lines|distribute-letter|distribute-space|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|double-circle|doubleCircle|downleft|downright|e-resize|each-line|eachLine|ease|ease-in|ease-in-out|ease-out|easeIn|easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|eResize|evenodd|ew-resize|ewResize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded|extraCondensed|extraExpanded|fallback|farthest-corner|farthest-side|farthestCorner|farthestSide|fill|fill-available|fill-box|fillAvailable|fillBox|filled|fit-content|fitContent|fixed|flat|flex|flex-end|flex-start|flexEnd|flexStart|flip|flow-root|flowRoot|forwards|free|from-image|fromImage|full-width|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|hardLight|help|hidden|hide|historical-forms|historical-ligatures|historicalForms|historicalLigatures|horizontal|horizontal-tb|horizontalTb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographAlpha|ideographic|ideographNumeric|ideographParenthesis|ideographSpace|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start|inline-table|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart|inlineTable|inset|inside|inter-character|inter-ideograph|inter-word|interCharacter|interIdeograph|intersect|interWord|invert|isolate|isolate-override|isolateOverride|italic|jis04|jis78|jis83|jis90|justify|justify-all|justifyAll|kannada|keep-all|keepAll|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB|lineEdge|lineThrough|lining-nums|liningNums|list-item|listItem|local|loose|lowercase|lr|lr-tb|lrTb|ltr|luminance|luminosity|main-size|mainSize|mandatory|manipulation|manual|margin-box|marginBox|match-parent|match-source|matchParent|matchSource|mathematical|max-content|maxContent|medium|menu|message-box|messageBox|middle|min-content|minContent|miter|mixed|move|multiply|n-resize|narrower|ne-resize|nearest-neighbor|nearestNeighbor|neResize|nesw-resize|neswResize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures|no-drop|no-historical-ligatures|no-open-quote|no-repeat|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures|noDrop|noHistoricalLigatures|none|nonzero|noOpenQuote|noRepeat|normal|not-allowed|notAllowed|nowrap|nResize|ns-resize|nsResize|numbers|numeric|nw-resize|nwResize|nwse-resize|nwseResize|oblique|oldstyle-nums|oldstyleNums|open|open-quote|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding|padding-box|paddingBox|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|panDown|panLeft|panRight|panUp|panX|panY|paused|petite-caps|petiteCaps|pixelated|plaintext|pointer|portrait|pre|pre-line|pre-wrap|preLine|preserve-3d|preserve3d|preWrap|progress|progressive|proportional-nums|proportional-width|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]|repeat[xy]|reset-size|resetSize|reverse|revert|ridge|right|rl|rl-tb|rlTb|round|row|row-resize|row-reverse|row-severse|rowResize|rowReverse|rowSeverse|rtl|ruby|ruby-base|ruby-base-container|ruby-text|ruby-text-container|rubyBase|rubyBaseContainer|rubyText|rubyTextContainer|run-in|runIn|running|s-resize|saturation|scale-down|scaleDown|screen|scroll|scroll-position|scrollPosition|se-resize|semi-condensed|semi-expanded|semiCondensed|semiExpanded|separate|seResize|sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashed-zero|slashedZero|slice|small|small-caps|small-caption|smallCaps|smallCaption|smaller|smooth|soft-light|softLight|solid|space|space-around|space-between|space-evenly|spaceAround|spaceBetween|spaceEvenly|spell-out|spellOut|square|sResize|sRGB|stacked-fractions|stackedFractions|start|static|status-bar|statusBar|step-end|step-start|stepEnd|stepStart|sticky|stretch|strict|stroke|stroke-box|strokeBox|structze|style|sub|subgrid|subpixel-antialiased|subpixelAntialiased|subtract|super|sw-resize|swap|swResize|symbolic|table|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabular-nums|tabularNums|tb|tb-rl|tbRl|text|text-after-edge|text-before-edge|text-bottom|text-top|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titling-caps|titlingCaps|top|top-outside|topOutside|touch|traditional|transparent|triangle|ultra-condensed|ultra-expanded|ultraCondensed|ultraExpanded|under|underline|unicase|uniq|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|useGlyphOrientation|useScript|verso|vertical|vertical-ideographic|vertical-lr|vertical-rl|vertical-text|verticalIdeographic|verticalLr|verticalRl|verticalText|view-box|viewBox|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy|weight|whitespace|wider|words|wrap|wrap-reverse|wrapReverse|wResize|x|x-large|x-small|xLarge|xSmall|xx-large|xx-small|xxLarge|xxSmall|y|zero|zoom-in|zoom-out|zoomIn|zoomOut )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.css.saga
      - match: (?x)\b( arabic-indic|arabicIndic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic|decimal|decimal-leading-zero|decimalLeadingZero|devanagari|disc|disclosure-closed|disclosure-open|disclosureClosed|disclosureOpen|ethiopic-halehame-am|ethiopic-halehame-ti-e[rt]|ethiopic-numeric|ethiopicHalehameAm|ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hangulConsonant|hebrew|hiragana|hiragana-iroha|hiraganaIroha|japanese-formal|japanese-informal|japaneseFormal|japaneseInformal|kannada|katakana|katakana-iroha|katakanaIroha|khmer|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lower-alpha|lower-armenian|lower-greek|lower-latin|lower-roman|lowerAlpha|lowerArmenian|lowerGreek|lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal|simpChineseFormal|simpChineseInformal|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|tradChineseFormal|tradChineseInformal|upper-alpha|upper-armenian|upper-latin|upper-roman|upperAlpha|upperArmenian|upperLatin|upperRoman|urdu )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.list-style-type.css.saga
      - match: (?x)\b( arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|monospace|sans-serif|sansSerif|serif|symbol|system|system-ui|systemUi|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings )(?!\B|\p{Pd}+\b)
        name: support.constant.font-name.css.saga

  html-tag-names:
    patterns:
      - match: (?x)\b( all|print|screen|speech|aural|braille|embossed|handheld|projection|tty|tv )(?!\B|\p{Pd}+\b)
        name: support.constant.media.css.saga
      - match: (?x)\b( a|abbr|acronym|address|altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|annotation|annotationXml|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|circle|cite|clipPath|code|col|colgroup|colorProfile|command|content|cursor|data|datalist|dd|defs|del|desc|details|dfn|dialog|dir|discard|div|dl|dt|element|ellipse|em|embed|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|fieldset|figcaption|figure|filter|font|fontFace|fontFaceFormat|fontFaceName|fontFaceSrc|fontFaceUri|footer|foreignObject|form|frame|frameset|g|glyph|glyphRef|hatch|hatchpath|hd|head|header|hgroup|hkern|hr|html|h[1-6]|i|iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|line|linearGradient|link|listing|maction|main|maligngroup|malignmark|map|mark|marker|marquee|mask|math|menclose|menu|menuitem|merror|mesh|meshgradient|meshpatch|meshrow|meta|metadata|meter|mfenced|mfrac|mglyph|mi|missingGlyph|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mpath|mphantom|mroot|mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup|msup|mtable|mtd|mtext|mtr|multicol|munder|munderover|nav|nextid|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|path|pattern|picture|plaintext|polygon|polyline|pre|progress|q|radialGradient|rb|rect|rp|rt|rtc|ruby|s|samp|script|section|select|semantics|set|shadow|slot|small|solidcolor|source|spacer|span|stop|strike|strong|style|sub|summary|sup|svg|switch|symbol|table|tbody|td|template|text|textarea|textPath|tfoot|th|thead|time|title|tr|track|tref|tspan|tt|u|ul|use|var|video|view|vkern|wbr|xmp )(?!\B|\p{Pd}+\b)
        name: entity.name.tag.css.saga

  entities:
    patterns:
      - include: '#function-names'
      - include: '#constant-names'
      - include: '#type-names'
      - include: '#variable-names'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Boolean|bool|Char|Rune|String|Symbol
            |(Big)?(
              Number|Int(eger)?|Float|Decimal|Natural
              |Rational|Imaginary|Complex
            )|
            # lower flat case
            boolean|bool|char|rune|string|symbol
            |(big)?(
              number|int(eger)?|float|decimal|natural
              |rational|imaginary|complex
            )
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.primitive.saga
      - comment: Data query classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|Set|Map|Object|Sequence|Record|Dictionary
            |Process|Range|Stack|Heap|Queue|Tree|Trie|Graph
            |Future|Stream|RegExp|Function|Buffer|FrozenSe[tq]
            # lower flat case
            |array|tuple|set|map|object|sequence|record|dictionary
            |process|range|stack|heap|queue|tree|trie|graph
            |future|stream|regexp|function|buffer|frozense[tq]
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.saga
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Infinity|Empty|Unit|Object
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const|Undefined
            # lower flat case
            |true|false|null|void|nan|infinity|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const|undefined
          )(?!\B|\p{Pd}+\b)
        name: support.type.primitive.saga
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)(?!\B|\p{Pd}+\b)
        name: support.class.error.saga
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.interface.saga
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.namespace.saga
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able(?!\B|\p{Pd}+\b)
        name: support.class.trait.saga

  support-functions:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: predicate functions
        match: \s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+(?!\B|\p{Pd}+\b)\s*
        name: support.function.predicate.saga
      - comment: magic functions
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}][\w\p{Pd}]*)+\p{Pc}+(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.saga

  # Generated

  strings-prefixed:
    patterns:
      - comment: single-quoted verbatim, interpolated, format, and template string
        begin: (?<!'+)((?i:f+p+r+s+|f+p+s+r+|f+r+p+s+|f+r+s+p+|f+s+p+r+|f+s+r+p+|p+f+r+s+|p+f+s+r+|p+r+f+s+|p+r+s+f+|p+s+f+r+|p+s+r+f+|r+f+p+s+|r+f+s+p+|r+p+f+s+|r+p+s+f+|r+s+f+p+|r+s+p+f+|s+f+p+r+|s+f+r+p+|s+p+f+r+|s+p+r+f+|s+r+f+p+|s+r+p+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|\$\$|%%|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, format, and template string
        begin: (?<!"+)((?i:f+p+r+s+|f+p+s+r+|f+r+p+s+|f+r+s+p+|f+s+p+r+|f+s+r+p+|p+f+r+s+|p+f+s+r+|p+r+f+s+|p+r+s+f+|p+s+f+r+|p+s+r+f+|r+f+p+s+|r+f+s+p+|r+p+f+s+|r+p+s+f+|r+s+f+p+|r+s+p+f+|s+f+p+r+|s+f+r+p+|s+p+f+r+|s+p+r+f+|s+r+f+p+|s+r+p+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|\$\$|%%|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, interpolated, and format string
        begin: (?<!'+)((?i:f+r+s+|f+s+r+|r+f+s+|r+s+f+|s+f+r+|s+r+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|\$\$|%%'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted verbatim, interpolated, and format string
        begin: (?<!"+)((?i:f+r+s+|f+s+r+|r+f+s+|r+s+f+|s+f+r+|s+r+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|\$\$|%%'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim, interpolated, and template string
        begin: (?<!'+)((?i:p+r+s+|p+s+r+|r+p+s+|r+s+p+|s+p+r+|s+r+p+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|\$\$|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, interpolated, and template string
        begin: (?<!"+)((?i:p+r+s+|p+s+r+|r+p+s+|r+s+p+|s+p+r+|s+r+p+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|\$\$|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim, format, and template string
        begin: (?<!'+)((?i:f+p+r+|f+r+p+|p+f+r+|p+r+f+|r+f+p+|r+p+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|%%|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim, format, and template string
        begin: (?<!"+)((?i:f+p+r+|f+r+p+|p+f+r+|p+r+f+|r+f+p+|r+p+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|%%|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated, format, and template string
        begin: (?<!'+)((?i:f+p+s+|f+s+p+|p+f+s+|p+s+f+|s+f+p+|s+p+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated, format, and template string
        begin: (?<!"+)((?i:f+p+s+|f+s+p+|p+f+s+|p+s+f+|s+f+p+|s+p+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim and interpolated string
        begin: (?<!'+)((?i:r+s+|s+r+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|\$\$'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
      - comment: double-quoted verbatim and interpolated string
        begin: (?<!"+)((?i:r+s+|s+r+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|\$\$'
            name: constant.character.escape.saga
          - include: '#embedded-expression'
      - comment: single-quoted interpolated and format string
        begin: (?<!'+)((?i:f+s+|s+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: double-quoted interpolated and format string
        begin: (?<!"+)((?i:f+s+|s+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-format'
      - comment: single-quoted verbatim and template string
        begin: (?<!'+)((?i:p+r+|r+p+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '''''|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-placeholder'
      - comment: double-quoted verbatim and template string
        begin: (?<!"+)((?i:p+r+|r+p+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""|\#\#'
            name: constant.character.escape.saga
          - include: '#embedded-placeholder'
      - comment: single-quoted interpolated and template string
        begin: (?<!'+)((?i:p+s+|s+p+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: double-quoted interpolated and template string
        begin: (?<!"+)((?i:p+s+|s+p+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
          - include: '#embedded-placeholder'
      - comment: single-quoted format and template string
        begin: (?<!'+)((?i:f+p+|p+f+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: double-quoted format and template string
        begin: (?<!"+)((?i:f+p+|p+f+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-format'
          - include: '#embedded-placeholder'
      - comment: single-quoted verbatim string
        begin: (?<!'+)((?i:r+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: "''"
            name: constant.character.escape.saga
      - comment: double-quoted verbatim string
        begin: (?<!"+)((?i:r+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - match: '""'
            name: constant.character.escape.saga
      - comment: single-quoted interpolated string
        begin: (?<!'+)((?i:s+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: double-quoted interpolated string
        begin: (?<!"+)((?i:s+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-expression'
      - comment: single-quoted template string
        begin: (?<!'+)((?i:p+))('''+|')\s*
        contentName: string.quoted.single.saga
        end: \s*()(\2)(?!'+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'
      - comment: double-quoted template string
        begin: (?<!"+)((?i:p+))("""+|")\s*
        contentName: string.quoted.double.saga
        end: \s*()(\2)(?!"+)
        captures:
          1: { name: storage.type.string.saga }
          2: { name: punctuation.definition.string.saga }
        patterns:
          - include: '#string-escapes'
          - include: '#embedded-placeholder'

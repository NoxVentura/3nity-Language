name: Protea
scopeName: source.dart
fileTypes: [dart, pr]
patterns: [include: '#core']

information for contributors: |
  This is the grammar for the Protea programming language. It is primarily
  based on Ruby, Python, Haskell and ML, but is intended for building cross-
  platform apps and software with the web.

  The grammar is nearing completion but needs to be thoroughly refactored
  and reorganized. There also are some bugfixes which are on the verge of
  being performed.

  Should any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo,
  and I will be very happy to receive it/them.

fixes: |
  Changes in 2022:

  - Added back backslash strings.
  - Removed JSX and style blocks, replaced them with indentation.
  - Comments have been standardized into C/Swift-style comments.
    - // line comment
    - /* block comment */
    - /// doc line comment
    - /** doc block comment */
  - Added '/' (full) and '//' (shorthand) command flags
  - Numbers and escape sequences have been reworked; bases 4, 6, and 12
    have been scrapped.
  - Interpolation and formatting syntax have been reworked and fixed.
    Spacing around identifiers have also been removed.
  - Function call syntax has been reworked and is still sometimes buggy.
    Still some improvements have to be made.
  - Removed '\' from valid operator characters.
  - Added/removed a few more keywords: use, show, hide;
    removed import, export, var, val, let, const;
    shortened some to three or four letters:
      'struct' -> 'inter', 'module' -> 'mod', 'markup' -> 'mark', 'object' -> 'obj'
  - Fixed regular expression highlighting:
    - Added and expanded quantifiers and range highlighting
    - Add support for fuzzy matching (edits, insertions, deletions, etc.)

  Fixes:

  - Match unquoted glob patterns in routes without quotes
  - Fix type strings and symbol-quoted strings to match properly
  - Add new keywords to end blocks:
    - if/elif then else fi
    - for/loop/while do done
    - match with exit
    - case then ouse esac
    - try catch after yrt
    - with away
    - do done
  - Percent literals inspired by Ruby (this time using dollar signs as the
    percent sign is used for string formatting).
  - Grammar is a bit messy at the moment, so adding comments to some regexes
    would help a lot. I'll be fixing this soon.
  - Rewrite complex regular expressions and add some comments to make them more
    readable and less confusing.
    - [x] Markdown syntax
    - [x] function parameters
    - [x] function calls
    - [ ] identifiers and variables
    - [x] operators
    - [ ] object literals
    - [ ] object labels
    - [x] pipeline functions
    - [ ] modifier keywords
    - [ ] function assignments
    - [x] anonymous functions
    - [ ] embedded content
  - Add some more Markdown syntax:
    - Citations
    - Strike-through
    - Deleted and inserted text
    - Superscript
    - Subscript
    - Citation
    - Spans
    - Selectors and anchors
    - Code blocks
    - Definition blocks
    - Tables
    - Headings and subheadings
  - Unify function call variables to 9 groups instead of 12:
    - Objects, properties and variables
    - UPPERCASE, PascalCase and camelCase

define:
  entity-name: &entity-name |
    (?x) \s*\b

    (?!
      (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?: # keywords
        in|of|as|is|new
        |to|til|thru|by|del
        |unset|ref|and|or|xor|not
        |var|val|func|proc|type
        |class|data|enum|module
        |iter|macro|inter|object
        |trait|style|elem|prop
        |go|defer|do|from|where|with
        |if|elif|else|then|def
        |for|each|loop|while
        |try|throw|catch|after
        |match|case|pass|fail|goto
        |break|next|redo|retry
        |return|yield|await|label
        |use|show|hide|route
        |debug|assert|check
      )
      (?!\B|\p{Pd}+\b)
    )

    # identifier
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.protea}
    patterns: [include: '#param-bracket-content']

  html-tag-names: &html-tag-names
    - match: '\.|:|::'
      name: punctuation.separator.namespace.protea
    - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
      name: entity.name.tag.namespace.protea
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)\b
      name: support.class.component.protea
    - include: '#clauses'
    - include: '#declarations'
    - include: '#keywords'
    - include: '#html-tag-names'

repository:
  core:
    patterns:
      - include: '#ignore-long-lines'
      - include: '#closures'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#comments'
      - include: '#params-clause'
      - include: '#function-clause'
      - include: '#embedded-expression'
      - include: '#jsx'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#symbols'
      - include: '#switch-clause'
      - include: '#format-clause'
      - include: '#type-signature'
      - include: '#literals'
      - include: '#operators'
      - include: '#calls'
      - include: '#variables'
      - include: '#illegal'
      - include: '#space'

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{1024,}$

  space:
    match: \s+
    name: meta.var.expr.protea

  # Function brackets (early here as not to break things)

  param-bracket-content:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.protea
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.protea
      - include: '#closures'
      - include: '#clauses'
      - include: '#constants'
      - include: '#declarations'
      - include: '#expression-keywords'
      - include: '#parameter-variables'
      - include: '#keywords'
      - include: '#comments'
      - include: '#params-clause'
      - include: '#function-clause'
      - include: '#embedded-expression'
      - include: '#jsx'
      - include: '#brackets'
      - include: '#punctuation'
      - include: '#symbols'
      - include: '#switch-clause'
      - include: '#format-clause'
      - include: '#type-signature'
      - include: '#literals'
      - include: '#operators'
      - include: '#calls'
      - include: '#variables'
      - include: '#space'

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.protea
      - match: '[\w]+?'
        name: invalid.illegal.variable.protea
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.protea
      - match: '[\p{S}\p{P}&&[^,;''"`(){}\[\]\p{Pc}]]+'
        name: invalid.illegal.operator.protea
      - match: \S+?
        name: invalid.illegal.uncaught.protea

  # Literals and Constants

  literals:
    patterns:
      - include: '#regexps'
      - include: '#strings-unquoted'
      - include: '#strings'
      - include: '#numbers'
      - include: '#constants'

  constants:
    patterns:
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (true|false) # boolean
            |(null|nan) # null, NaN
            |(void) # undefined
            |(infin) # infinity
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: {name: constant.language.boolean.$1.protea}
          2: {name: constant.language.$2.protea}
          3: {name: constant.language.undefined.protea}
          4: {name: constant.language.infinity.protea}
      - match: |
          (?x)
          (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
          (?:
            (it|this|that|self) # special arguments
            |(args) # arguments
            |(ctor) # constructor
            |(proto) # prototype
          )
          (?!\B|\p{Pd}+\b)
        captures:
          1: {name: variable.language.$1.protea}
          2: {name: variable.language.arguments.protea}
          3: {name: variable.language.constructor.protea}
          4: {name: variable.language.prototype.protea}

  # Numbers

  numbers:
    patterns:
      - comment: hexadecimal integers
        name: constant.numeric.hexadecimal.protea
        match: |
          (?x) \b
            (0x) # prefix
            \h [\h_]* # integer part
            (\.)? # decimal point
            [\h_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: octal integers
        name: constant.numeric.octal.protea
        match: |
          (?x) \b
            (0o) # prefix
            [0-7] [0-7_]* # integer part
            (\.)? # decimal point
            [0-7_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: binary 0b
        name: constant.numeric.binary.protea
        match: |
          (?x) \b
            (0b) # prefix
            [01] [01_]* # integer part
            (\.)? # decimal point
            [01_]* # fractional part
            (?: # exponent part
              (p) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}
      - comment: decimal (no prefix)
        name: constant.numeric.decimal.protea
        match: |
          (?x) \b
            () # prefix
            \d [\d_]* # integer part
            (\.)? # decimal point
            [\d_]* # fractional part
            (?: # exponent part
              (e) # delimiter
              ([+-])? # sign
              ([\d_]+) # mantissa
            )?
            ([\p{Pc}\p{L}][\w\p{Pd}]*)? # type suffix
          \b
        captures:
          1: {name: storage.type.numeric.protea}
          2: {name: keyword.other.unit.protea}
          3: {name: keyword.operator.expression.exponent.protea}
          4: {name: keyword.operator.exponent.sign.protea}
          5: {name: constant.numeric.decimal.exponent.mantissa.protea}
          6: {name: keyword.other.unit.protea}

  # Symbols

  symbols:
    patterns:
      - match: \@[\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*\b)*\s*
        name: entity.name.class.decorator.protea
      - match: \B(:)(?=['"])
        name: punctuation.definition.symbol.protea
      - match: \B(:)([\p{Pc}\p{L}][\w\p{Pd}]*\b)
        captures:
          1: {name: punctuation.definition.symbol.protea}
          2: {name: constant.other.symbol.protea}

  strings-unquoted:
    comment: Unquoted string
    applyEndPatternLast: true
    begin: (\\)
    end: (?=[\p{Z}\p{P}\p{S}])|$
    name: string.unquoted.protea
    captures:
      1: {name: punctuation.definition.string.protea}
    patterns: [include: '#string-escapes']

  strings:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)\s*
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns: [include: '#embedded-verbatim']
      - comment: single quoted string
        begin: (?<!'+)\s*(')\s*
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - match: "''"
            name: constant.character.escape.protea
          - include: '#embedded-verbatim'
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)\s*
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns: [include: '#string-content']
      - comment: double quoted string
        begin: (?<!"+)\s*(")\s*
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns: [include: '#string-content']

  string-content:
    patterns:
      - include: '#string-escapes'
      - include: '#embedded'

  function-namespace:
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: support entity.name.tag.namespace.protea
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: support entity.name.function.member.protea

  character-namespace:
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
        name: constant.other.character-class.protea
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: constant.character.escape.unicode.protea

  character-escapes:
    patterns:
      - applyEndPatternLast: true
        name: constant.other.function.protea
        begin: \\:([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.protea}
            patterns:
          - include: '$self'
      - match: \\:\b([\p{Pc}\p{L}][\w\p{Pd}]*\b([:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b([;,]|(?=\W))
        name: constant.character.escape.protea
        captures:
          1: {patterns: [include: '#character-namespace']}

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - include: '#character-escapes'
      - include: '#numeric-escapes'
      - match: \\([cm][a-z])
        name: constant.character.control.protea
      - match: \\[prntfvabes]
        name: constant.character.escape.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.deprecated.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: \\b[01]+
        name: constant.character.escape.binary.protea
      - comment: Binary escape sequences
        begin: \\b{
        end: \s*}
        name: constant.character.escape.binary.protea
        patterns:
          - match: \b[01]+\b
            name: constant.character.escape.binary.protea
          - include: '#punctuation'
          - match: \w+
            name: invalid.illegal.escape.protea
      - comment: Octal escape sequences
        match: \\o[0-7]+
        name: constant.character.escape.octal.protea
      - comment: Octal escape sequences
        begin: \\o{
        end: \s*}
        name: constant.character.escape.octal.protea
        patterns:
          - match: \b[0-7]+\b
            name: constant.character.escape.octal.protea
          - include: '#punctuation'
          - match: \w+
            name: invalid.illegal.escape.protea
      - comment: Decimal escapes
        match: \\d?\d+
        name: constant.character.escape.decimal.protea
      - comment: Decimal escapes inside curly brackets
        begin: \\d{
        end: \s*}
        name: constant.character.escape.decimal.protea
        patterns:
          - match: \b\d+\b
            name: constant.character.escape.decimal.protea
          - include: '#punctuation'
          - match: \w+
            name: invalid.illegal.escape.protea
      - comment: Hexadecimal escape sequences
        match: \\x\h+
        name: constant.character.escape.hexadecimal.protea
      - comment: Hexadecimal escape sequences
        begin: \\x{
        end: \s*}
        name: constant.character.escape.hexadecimal.protea
        patterns:
          - match: \b\h+\b
            name: constant.character.escape.hexadecimal.protea
          - include: '#punctuation'
          - match: \w+
            name: invalid.illegal.escape.protea

      - comment: Low and high surrogates are specially highlighted as calculated in UTF-16
      - comment: Low surrogate pairs U+DC00-DFFF
        match: \\u(?i:d[cdef]\h{2}(?!\h))
        name: constant.character.escape.surrogate.low.protea
      - comment: High surrogate pairs U+D800-DBFF
        match: \\u(?i:d[89ab]\h{2}(?!\h))
        name: constant.character.escape.surrogate.high.protea
      - comment: Unicode escapes
        match: \\u\h+
        name: constant.character.escape.unicode.protea
      - comment: Unicode escapes
        begin: \\u{
        end: \s*}
        name: constant.character.escape.unicode.protea
        patterns:
          - match: \b(?i:d[89ab]\h{2}(?!\h))\b
            name: constant.character.escape.surrogate.high.protea
          - match: \b(?i:d[cdef]\h{2}(?!\h))\b
            name: constant.character.escape.surrogate.low.protea
          - match: \b\h+\b
            name: constant.character.escape.unicode.protea
          - include: '#punctuation'
          - match: \w+
            name: invalid.illegal.escape.protea

  # Embedded expressions

  embedded:
    patterns:
      - include: '#format-clause'
      - include: '#embedded-placeholder'
      - include: '#embedded-expression'

  embedded-verbatim:
    patterns:
      - match: '([#$%])\1'
        name: constant.character.escape.protea
      - include: '#format-clause'
      - include: '#embedded-placeholder'
      - include: '#embedded-expression'

  embedded-expression:
    patterns:
      - comment: Interpolated expression
        begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.protea
        captures:
          1: {name: punctuation.section.embedded.protea}
        patterns:
          - include: '$self'
      - comment: Interpolated expression
        applyEndPatternLast: true
        begin: |
          (?x)
          (?<=^|\\.|[,;'"`\\(){}\[\]\w\s]>?) # SOL or after a literal or space
          (\$) # beginning of identifier
          # ignore all keywords
          (?!
            (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
            (?: # keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|val|func|proc|type
              |class|data|enum|module
              |iter|macro|inter|object
              |trait|style|elem|prop
              |go|defer|do|from|where|with
              |if|elif|else|then|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|pass|fail|goto
              |break|next|redo|retry
              |return|yield|await|label
              |use|show|hide|route
              |debug|assert|check
            )
            (?!\B|\p{Pd}+\b)
          )
          \b # next to a word
        end: (?=)|$
        captures:
          1: {name: punctuation.section.embedded.protea}
        patterns:
          - include: '#constants'
          - include: '#brackets'
          - include: '#embedded-calls'
          - include: '#variables'
          - include: '#numbers'
          - &embedded-primary-operators
            comment: Primary binary operators
            match: (?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
            captures:
              1: {name: keyword.operator.optional.protea}
              2: {name: keyword.operator.assert.protea}
              3: {name: keyword.operator.accessor.protea}

  embedded-placeholder:
    patterns:
      - match: |
          (?x)
          (\#) # sigil
          (
            \?? \*? # optional and spread
            [+-]? \d+ # start of range
            (?:
              (?:[>.]\.[.<]|\.\.=?|=\.=) # range operator
              [+-]? \d+ # end of range
              (?:
                \.{1,3}
                [+-]? \d+ # increment
              )?
            )?
          )
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2:
            name: constant.numeric.decimal.protea
            patterns:
              - match: '[+-]'
                name: keyword.operator.arithmetic.protea
              - match: (?:[>.]\.[.<]|\.\.=?|=\.=)
                name: keyword.operator.range.protea
      - match: |
          (?x)
          (\#) # sigil
          (
            (?:[*&%]\??|//?\??|\?)
            \b
            [\p{Pc}\p{L}][\w\p{Pd}]*
            \b
            |
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|from|where|with
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|label
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            \b
            [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
            \b
          )
        captures:
          1: {name: punctuation.definition.anchor.protea}
          2: {patterns: [include: '#placeholder-variables']}
      - begin: (\#{)\s*
        end: \s*(})
        name: entity.quasi.component.protea
        captures:
          1: {name: punctuation.definition.anchor.protea}
        patterns:
          - include: '#parameter-variables'
          - include: $self

  # Format and flag specifiers

  switch-clause:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: true
        begin: (?x)(?<=^|\\.|[,;'"`(){}\[\]\s]>?)(//)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.protea}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: {name: keyword.other.flag.protea}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: true
        begin: (?x)(?<=^|\\.|[,;'"`(){}\[\]\s]>?)(/)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.protea}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: {name: keyword.modifier.protea}

  format-clause:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: true
    begin: (?x)(?<=^|\\.|[,;'"`(){}\[\]\s]>?)(%)\b
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.protea}
    patterns: [include: '#format-syntax']

  format-syntax:
    comment: Format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: initial format switch with value
        applyEndPatternLast: true
        begin: (?<=%)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(:)
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.format.main.protea}
          2: {name: punctuation.separator.key-value.protea}
        name: entity.other.attribute-name.protea
        patterns: &format-values
          - include: '#constants'
          - include: '#embedded-calls'
          - include: '#variables'
          - include: '#brackets'
          - include: '#regexps'
          - include: '#numbers'
          - include: '#symbols'
          - *embedded-primary-operators
      - comment: type specifier
        match: (?<=%)([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        name: entity.other.attribute-name.protea
        captures:
          1: {name: storage.type.format.main.protea}
      - comment: Format switch with value /x:24
        applyEndPatternLast: true
        begin: (\|)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(:)
        beginCaptures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: storage.type.format.sub.protea}
          3: {name: punctuation.separator.key-value.protea}
        end: (?=)|$
        patterns: *format-values
      - comment: Format switch without value
        match: (\|)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.separator.mapping.protea}
          2: {name: storage.type.format.sub.protea}

  # Unicode Named Character Language

  latex-sublanguage:
    name: string.unquoted.plain.in.protea
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - applyEndPatternLast: true
        name: meta.function.math.protea
        begin: (\\)([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b(?=\{)
        beginCaptures:
          1: {name: constant.other.function.protea}
          2: {patterns: [include: '#function-namespace']}
        end: (?=)|$
        patterns:
          - begin: (\{)
            end: (\})
            captures:
              1: {name: constant.other.function.protea}
            patterns: [include: '#latex-sublanguage']
      - match: (\\)\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
        captures:
          1: {name: constant.other.character.protea}
          2: {patterns: [include: '#character-namespace']}
      - include: '#string-content'
      - include: '#literals'
      - include: '#numbers'
      - include: source.js#expression-operators
      - include: source.yaml#flow-collection
      - match: ([^\s\\(){}\[\]]+)
        name: string.unquoted.plain.in.protea

  # Regular expressions

  regexps:
    patterns:
      - comment: Replacement section
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        name: string.replace.regexp.protea
        captures:
          1: {name: punctuation.section.regexp.end.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: '#back-references'
          - include: '#string-content'
      - comment: Pattern section
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        name: string.pattern.regexp.protea
        beginCaptures:
          1: {name: keyword.modifier.protea}
          2: {name: punctuation.section.regexp.begin.protea}
        endCaptures:
          1: {name: punctuation.section.regexp.end.protea}
          2: {name: keyword.other.flag.protea}
        patterns:
          - include: '#comments'
          - include: '#regexp-patterns'

  fuzzy-expression:
    patterns:
      - include: '#punctuation'
      - include: '#comments'
      - include: '#calls'
      - include: '#literals'
      - include: '#embedded'
      - include: '#operators'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#fuzzy-brackets'
      - match: \b[\p{Pc}\p{L}][\w\p{Pd}]*\b
        name: keyword.other.unit.protea
      - match: \s+
        name: meta.space.protea

  fuzzy-brackets:
    patterns:
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - include: '#labels'
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: '#fuzzy-expression'
          - include: $self
      - begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - include: '#fuzzy-expression'
          - include: $self

  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*|&)
        name: keyword.other.back-reference.protea
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: &regex-back-references
          - include: '#variables'
          - include: '#numbers'
          - include: '#operators'
          - include: '#string-content'
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references

  regexp-patterns:
    patterns:
      - match: \p{Z}+
        name: meta.space.protea
      - include: '#embedded'
      - include: '#comments'
      - include: '#strings'
      - match: \|
        name: keyword.operator.or.protea
      - match: \&
        name: keyword.operator.compose.protea
      - match: \.
        name: constant.character.all.protea
      - match: \\[bB](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.anchor.protea
      - match: \$|\\[yYzZ](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.end.protea}
      - match: \^|\\[AmM](?:{(?:[^\\{}]|\\.)+})?
        name: keyword.control.begin.protea
      - match: \\K
        name: keyword.control.keepout.protea
      - match: \\G
        name: keyword.control.search.protea
      - match: \\R
        name: constant.character.control.protea
      - match: \\[XO]
        name: constant.character.unicode.protea
      - match: \\\d+
        name: keyword.other.back-reference.protea
      - match: \{\s*(?:\d*\s*,){,2}\s*\d*\s*}\s*(?:(\?)|(\+)|(\*))?
        captures:
          0: {name: keyword.operator.quantifier.protea}
          1: {name: keyword.operator.modifier.lazy.protea}
          2: {name: keyword.operator.modifier.eager.protea}
          3: {name: keyword.operator.modifier.greedy.protea}
      - match: (?:(\?)|(\+)|(\*))\s*(?:(\?)|(\+)|(\*))?
        captures:
          1: {name: keyword.operator.quantifier.lazy.protea}
          2: {name: keyword.operator.quantifier.eager.protea}
          3: {name: keyword.operator.quantifier.greedy.protea}
          4: {name: keyword.operator.modifier.lazy.protea}
          5: {name: keyword.operator.modifier.eager.protea}
          6: {name: keyword.operator.modifier.greedy.protea}
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.protea
        captures:
          1: {name: keyword.other.back-reference.protea}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.protea
        captures:
          1: {name: keyword.other.subroutine.protea}
        patterns: *regex-back-references
      - begin: ({)
        end: \s*(})
        name: meta.fuzzy.protea
        captures:
          1: {name: punctuation.definition.fuzzy.protea}
        patterns:
          - applyEndPatternLast: true
            begin: (?<=^|\\.|[,;'"`(){}\[\]\s\w])(:)
            beginCaptures:
              1: {name: punctuation.separator.key-value.protea}
            end: (?=[,;}]|)|$
            patterns: [include: '#regexp-patterns']
          - include: '#fuzzy-expression'
      - include: '#regexp-groups'
      - include: '#regexp-character-set'
      - include: '#regexp-character-class'

  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(\?([*+])
        end: \s*(\))
        name: constant.other.pcre.protea
        captures:
          0: {name: punctuation.section.expression.protea}
        patterns:
          - include: '$self'
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.protea
        end: \s*(\))
        name: comment.block.regexp.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - match: \\.
            name: comment.block.regexp.protea
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))
        name: meta.group.look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.look-ahead.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))
        name: meta.group.look-behind.protea
        captures:
          1: {name: punctuation.definition.group.look-behind.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))
        name: meta.group.negative-look-ahead.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))
        name: meta.group.negative-look-behind.protea
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: (?x)(\(\?)(?=%)
        captures:
          1: {name: punctuation.definition.directive.protea}
        end: \s*(\))
        name: meta.group.directive.protea
        patterns:
          - include: '#format-syntax'
          - include: '#regexp-patterns'
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))
        name: meta.group.longest.protea
        captures:
          1: {name: punctuation.definition.group.longest.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))
        name: meta.group.flag.protea
        captures:
          0: {name: punctuation.definition.group.flag.protea}
          1: {name: punctuation.definition.group.flag.protea}
          2: {name: constant.numeric.index.protea}
          3: {name: keyword.control.recursion.protea}
          4: {name: keyword.other.flag.protea}
          5: {name: punctuation.separator.colon.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))
        name: meta.group.call-out.protea
        captures:
          1: {name: punctuation.definition.group.call-out.protea}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.protea
            captures:
              1: {name: punctuation.definition.group.call-out.protea}
              2: {name: keyword.operator.range.protea}
              3: {name: punctuation.definition.tag.protea}
              4: {patterns: [include: '#function-names']}
              5: {name: punctuation.definition.tag.protea}
            patterns:
          - include: '$self'
          - include: '#regexp-patterns'
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))
        name: meta.group.atomic.protea
        captures:
          1: {name: punctuation.definition.group.atomic.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))
        name: meta.group.non-capturing.protea
        captures:
          1: {name: punctuation.definition.group.non-capturing.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))
        name: meta.group.branch.protea
        captures:
          1: {name: punctuation.definition.group.branch.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))
        name: meta.group.absent.protea
        captures:
          1: {name: punctuation.definition.group.absent.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.protea
        captures:
          0: {name: punctuation.definition.group.back-reference.protea}
          1: {name: punctuation.definition.group.back-reference.protea}
          2: {name: constant.numeric.index.protea}
          3: {patterns: [include: '#variables']}
          4: {name: punctuation.separator.colon.protea}
        patterns: [include: '#regexp-patterns']
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))
        name: meta.group.named.protea
        captures:
          0: {name: punctuation.definition.group.named.protea}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.protea
            captures:
              1: {name: punctuation.definition.group.named.protea}
            patterns: *regex-back-references
          - include: '#regexp-patterns'
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.protea
        captures:
          1: {name: punctuation.definition.group.protea}
        patterns: [include: '#regexp-patterns']

  regexp-character-class:
    patterns:
      - include: '#embedded'
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.protea
      - include: '#character-escapes'
      - include: '#numeric-escapes'
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.protea
        patterns:
          - include: '#attribute-selectors'
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.protea
      - match: (?i)\\p[a-z]{1,2}
        name: constant.other.character-class.unicode.protea
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.protea
      - match: (?i)\\n{(?:[^\\{}]|\\.)+}
        name: constant.character.escape.unicode.name.protea
      - match: \\[prntfvabe]
        name: constant.character.escape.protea
      - match: \\[a-z]
        name: constant.other.character-class.protea
      - match: \\[A-Z]
        name: constant.other.character-class.negated.protea
      - match: \\\p{S}
        name: constant.character.escape.symbol.protea
      - match: \\\p{P}
        name: constant.character.escape.punctuation.protea
      - match: \\[a-zA-Z\p{C}]
        name: invalid.deprecated.escape.protea
      - match: \\\s
        name: constant.character.escape.space.protea
      - match: \\\p{L}
        name: constant.character.escape.letter.protea
      - match: \\\p{N}
        name: constant.character.escape.number.protea
      - match: \\.
        name: constant.character.escape.other.protea

  regexp-character-operators:
    patterns:
      - match: |
          (?x)
          ( # from
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[prntfvabe]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          )
            \s*
              (-|->|>-|>>) # range
            \s*
          ( # to
              \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
            | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
            | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
            | \\b(?:[01]+|{[01\s,;]+}) # binary escape
            | \\[cm][a-z] # meta-character
            | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
            | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
            | \\(?:[prntfvabe]|[^a-zA-Z]) # any escape character
            | [^-\\\[\]] # any unescaped character
          ) (?:
              \s*
                (:) # range
              \s*
            ( # to
                \d+ # number
              | \\(?:d?\d+|d{[\d\s,;]+}) # decimal escape
              | \\[xu](?:\h+|{[\h\s,;]+}) # hex escape
              | \\o(?:[0-7]+|{[0-7\s,;]+}) # octal escape
              | \\b(?:[01]+|{[01\s,;]+}) # binary escape
              | \\[cm][a-z] # meta-character
              | \\p(?:[a-z]{1,2}|{(?:[^\\{}]|\\.)+}) # Unicode char-group
              | \\n{(?:[^\\{}]|\\.)+} # Unicode named character
              | \\(?:[prntfvabe]|[^a-zA-Z]) # any escape character
              | [^-\\\[\]] # any unescaped character
            )
          )?
        captures:
          1:
            name: constant.other.character-class.range.from.protea
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          2:
            name: keyword.operator.range.protea
          3:
            name: constant.other.character-class.range.to.protea
            patterns:
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
          4:
            name: keyword.operator.range.protea
          5:
            name: constant.other.character-class.range.by.protea
            patterns:
              - include: '#numbers'
              - include: '#regexp-character-operators'
              - include: '#regexp-character-class'
      - match: \|\|
        name: keyword.operator.union.protea
      - match: \&&
        name: keyword.operator.intersection.protea
      - match: \^\^
        name: keyword.operator.symmetric.protea
      - match: ~~
        name: keyword.operator.negation.protea
      - match: --
        name: keyword.operator.difference.protea

  regexp-character-set:
    patterns:
      - begin: (\[:)
        end: \s*(:\])
        name: constant.other.character-set.posix.protea
        captures:
          1: {name: punctuation.definition.character-class.posix.protea}
        patterns: [include: '#attribute-selectors']
      - begin: (\[\^)
        end: \s*(\])
        name: constant.other.character-set.negated.protea
        captures:
          1: {name: punctuation.definition.character-class.negated.protea}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'
      - begin: (\[)
        end: \s*(\])
        name: constant.other.character-set.protea
        captures:
          1: {name: punctuation.definition.character-class.protea}
        patterns:
          - include: '#comments'
          - include: '#regexp-character-operators'
          - include: '#regexp-character-class'
          - include: '#regexp-character-set'

  attribute-selectors:
    patterns:
      - match: ','
        name: punctuation.separator.sequence.protea
      - include: '#comments'
      - include: '#strings'
      - match: (?xi)\b[is]\b\s*(?=[)}\]]|([&|^])\1)
        name: storage.modifier.ignore-when.protea
      - include: '#string-escapes'
      - match: '[:!=</>.^$%?*+|&~]?='
        name: keyword.operator.pattern.protea
      - match: \&&|\|\||\^\^|!
        name: keyword.operator.logical.protea
      - match: \b(i[ns])\b
        name: keyword.operator.expression.$1.protea
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.key.protea}
          2: {name: keyword.operator.pattern.protea}
        end: (?=&&|\|\||\^\^|[\s,:;'"`(){}\[\]])
        name: string.unquoted.attribute-name.protea
        patterns: [include: '#html-properties']
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: {name: entity.other.attribute-name.protea}
          2: {name: keyword.operator.pattern.protea}
      - include: '#operators'

  # Markdown

  jsx:
    applyEndPatternLast: true
    comment: |
      Only after opening brackets, commas, semicolons, keywords, and operators.
      In addition, < > starts a JSX fragment, <?x ... ?> starts a declaration, and =
      <! !> starts a fragment with CDATA-style syntax.
    begin: |
      (?x)
      (?<=
        (?:
          (?:
              ^ # beginning of line
            | [,;] # separator
            | [({\[] # opening bracket
          )
            | \b [\p{Pc}\p{L}][\w\p{Pd}]* \b # identifier or keyword
            | [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+ \s # postfix or infix operator
        ) \s*
      )
      (?=<[\p{Pc}\p{L}]|<\s+>)
    end: (?=)|$
    patterns: [include: '#tag-component-name']

  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: meta.jsx.fragment.protea
        begin: \s*(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
        endCaptures:
          1: {name: punctuation.definition.tag.protea}
        patterns:
          - include: '#tag-termination'
      - comment: Tags that end > are trapped in tag-termination
        contentName: meta.jsx.protea
        begin: |
          (?x)
          \s*
          (<) # start tag begin
          (
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?:\.|::?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
            \b
          )
          (?=[/>\s])(?![:])(?<![.:=])
        end: |
          (?x) \s*
          (?:
              (?<=</)(\2)(>)
            | (<?/>)
            | ((?<=</)\O*?)>
          )
        beginCaptures:
          1: {name: punctuation.definition.tag.protea}
          2: {patterns: [include: '#tag-names']}
        endCaptures:
          1: {patterns: [include: '#tag-names']}
          2: {name: punctuation.definition.tag.protea}
          3: {name: punctuation.definition.tag.protea}
          4: {name: invalid.illegal.termination.protea}
        patterns:
          - include: '#tag-termination'
          - include: '#tag-attributes'

  jsx-comments:
    begin: <!--
    end: -->
    captures:
      1: {name: punctuation.definition.comment.protea}
    name: comment.block.protea

  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: string.unquoted.html.protea
    name: string.unquoted.html.protea
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.protea}
    patterns:
      - include: '#evaluated-code'
      - include: '#jsx-entities'
      - include: '#tag-component-name'
      - include: '#markdown'
      - include: '#jsx-comments'

  tag-attributes:
    patterns:
      - include: '#comma'
      - include: '#semicolon'
      - include: '#style-selectors'
      - include: '#attribute-names'
      - applyEndPatternLast: true
        begin: \s*(=)\s*
        beginCaptures:
          1: {name: punctuation.separator.key-value.protea}
        end: (?=)|$
        name: string.unquoted.protea
        patterns: [include: '#html-properties']
      - include: '#strings'
      - include: '#comments'

  attribute-names:
    match: '\s*([\p{Pd}\w]+)\b\s*'
    captures:
      1:
        name: entity.other.attribute-name.${1:/camelcase}.protea
        patterns: [include: '#css-property-names']
    name: string.unquoted.protea

  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.protea

  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.protea}
          2: {name: punctuation.definition.entity.protea}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.protea
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.protea
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.protea
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.protea
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.protea

  inline-markdown:
    patterns:
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#bold'
      - include: '#italic'
      - include: '#raw'
      - include: '#escape'
      - include: '#image-inline'
      - include: '#image-ref'
      - include: '#link-email'
      - include: '#link-inet'
      - include: '#link-inline'
      - include: '#link-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref-shortcut'

  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: '&(?!([a-zA-Z0-9]+|#[0-9]+|#x\h+);)'
    name: meta.other.valid-ampersand.markdown

  bold:
    begin: |
      (?x)
      (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S)
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#italic'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!(){}\[\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)(\S+?)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns: [include: '#string-content']

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
        (
          <[^>]*+> # HTML tags
          | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
          # Raw
          | \\[\\`*_{}\[\]() #.!+\->]?+ # Escapes
          | \[
          (
              (?<square> # Named group
                [^\[\]\\] # Match most chars
                | \\. # Escaped chars
                | \[ \g<square>*+ \] # Nested brackets
              )*+
            \]
            (
              ( # Reference Link
                [ ]? # Optional space
                \[[^\]]*+\] # Ref name
              )
              | ( # Inline Link
                \( # Opening paren
                  [ \t]*+ # Optional whitespace
                  <?(.*?)>? # URL
                  [ \t]*+ # Optional whitespace
                  ( # Optional Title
                    (?<title>['"])
                    (.*?)
                    \k<title>
                  )?
                \)
              )
            )
          )
          | \k<open>\k<open> # Must be bold closer
          | (?!(?<=\S)\k<open>). # Everything besides
          # style closer
        )++
        (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: '#string-content'
      - include: '#escape'
      - include: '#ampersand'
      - include: '#bracket'
      - include: '#raw'
      - include: '#bold'
      - include: '#image-inline'
      - include: '#link-inline'
      - include: '#link-inet'
      - include: '#link-email'
      - include: '#image-ref'
      - include: '#link-ref-literal'
      - include: '#link-ref'
      - include: '#link-ref-shortcut'

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns: [include: '#string-content']

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns: [include: '#string-content']

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
        (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
        [ \t]* # Optional whitespace
        (?:
            ((\().+?(\))) # Match title in parens...
          | ((").+?(")) # or in double quotes...
          | ((').+?(')) # or in single quotes.
        )? # Title is optional
        \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns: [include: '#string-content']

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns: [include: '#string-content']

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns: [include: '#string-content']

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns: [include: '#string-content']

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: '#string-content']}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns: [include: '#string-content']

  markdown:
    patterns:
      - include: '#comments'
      - include: '#jsx-entities'
      - include: '#html-tag'
      - include: '#string-content'
      - include: '#evaluated-code'
      - include: '#executed-code'
      - include: '#inline-styles'
      - include: '#blockquote'
      - include: '#unordered-list'
      - include: '#ordered-list'
      - include: '#inline-markdown'

    repository:
      blockquote:
        comment: '> blockquote'
        begin: ^\s*(\>)(\s+.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown}
          2:
            name: markup.quote.markdown
            patterns: [include: '#markdown']
        name: markup.quote.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown
            patterns: [include: '#markdown']

      unordered-list:
        comment: '- unordered list'
        begin: ^\s*(\-)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.unnumbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown
            patterns: [include: '#markdown']

      ordered-list:
        comment: '+ ordered list'
        begin: ^\s*(\+)(?!>)\s+(.*)\n*
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown}
          2:
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']
        name: markup.list.numbered.markdown
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown
            patterns: [include: '#markdown']

      evaluated-code:
        applyEndPatternLast: true
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.protea}
        patterns:
          - include: '$self'

      executed-code:
        applyEndPatternLast: true
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.protea}
        patterns:
          - include: '$self'

      html-tag:
        comment: <Tags
        applyEndPatternLast: true
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.protea
        captures:
          1: {name: punctuation.definition.tag.protea}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
            captures:
              1: {name: entity.name.tag.protea, patterns: *html-tag-names}
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.id.protea
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.class.protea
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.protea}
            patterns:
          - include: '$self'
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.protea}
            patterns:
              - include: '#style-properties'
              - include: $self
          - begin: (\()\s*
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.protea}
            patterns:
              - include: '#tag-attributes'
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.protea
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.protea
            end: \s*((\1)(?!'+))
            captures:
              1: {name: punctuation.definition.string.protea}
            patterns: [include: '#markdown']
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.protea
            end: \s*((\1)(?!"+))
            captures:
              1: {name: punctuation.definition.string.protea}
            patterns: [include: '#markdown']
          - include: '#regexps'

      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*)\n*
        beginCaptures:
          1: {name: storage.type.style.protea}
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.protea}
              - include: '#comments'
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#block-entities'
              - match: *entity-name
                name: entity.name.style.protea
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: '#style-properties']

  # Special code blocks

  html-properties:
    patterns:
      - include: '#line-continuation'
      - include: source.yaml#flow-sequence
      - include: '#brackets'
      - include: '#literals'
      - include: '#css-value-names'
      - include: '#hex-colors'
      - include: '#type-variables'
      - include: '#embedded-expression'
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional

  hex-colors:
    match: (#)\b(?:\h{3,4}|\h{6}|\h{8})\b
    name: constant.other.color.rgb-value.hex.css
    captures:
      1: {name: punctuation.definition.constant.css}

  tag-names:
    match: \s*\b([\p{Pc}\p{L}][\w\p{Pd}]*\b(?:(?:\.|::?)[\p{Pc}\p{L}][\w\p{Pd}]*)*)\b\s*
    name: entity.name.tag.protea
    captures:
      1:
        name: entity.name.tag.protea
        patterns: *html-tag-names

  style-block:
    begin: \s*(\{)\s*
    end: \s*(\})\s*
    captures:
      1: {name: punctuation.section.property-list.protea}
    patterns: [include: '#style-properties']

  style-pair:
    applyEndPatternLast: true
    begin: '\s*([\p{Pd}\w]+)\b(:)\s*'
    end: (?=)|$
    name: string.unquoted.protea
    beginCaptures:
      1:
        name: support.type.property-name.protea
        patterns: [include: '#css-property-names']
      2:
        name: punctuation.separator.key-value.protea
    patterns:
      - include: '#html-properties'
      - match: \s+
        name: meta.var.expr.protea

  style-properties:
    patterns:
      - include: '#embedded'
      - include: '#clauses'
      - include: '#declarations'
      - include: '#keywords'
      - include: '#style-pair'
      - include: '#style-rules'
      - include: '#style-block'
      - include: $self

  style-rules:
    patterns:
      - include: '#calls'
      - comment: CSS operators
        match: \s*(?:(\+)|(\-)|(\*)|(/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: {name: keyword.operator.sum.protea}
          2: {name: keyword.operator.difference.protea}
          3: {name: keyword.operator.product.protea}
          4: {name: keyword.operator.quotient.protea}
          5: {name: keyword.operator.remainder.protea}
          6: {name: keyword.operator.only.protea}
          7: {name: keyword.operator.maybe.protea}
          8: {name: keyword.operator.intersection.protea}
          9: {name: keyword.operator.union.protea}
          10: {name: keyword.operator.symmetric.protea}
          11: {name: keyword.operator.negation.protea}
          12: {name: keyword.operator.macro.dollar.protea}
          13: {name: keyword.operator.private.protea}
          14: {name: keyword.operator.class.protea}
      - begin: \s*(\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#style-pair'
          - include: '#parameter-variables'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.protea}
        patterns:
          - include: '#attribute-selectors'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.protea
      - include: '#style-selectors'
      - include: '#format-syntax'
      - include: '#tag-names'

  style-selectors:
    patterns:
      - match: \s*(\@|\#|\&|\*|\.|\:|::)(?=[\w$])
        name: punctuation.definition.entity.protea
      - match: \s*(?<=@)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: keyword.control.at-rule.protea
      - match: \s*(?<=#)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: entity.other.attribute-name.id.protea
      - match: \s*(?<=&)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: entity.name.type.anchor.protea
      - match: \s*(?<=\*)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: entity.name.type.alias.protea
      - match: \s*(?<=\.)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: entity.other.attribute-name.class.protea
      - match: \s*(?<=::?)[\p{Pc}\p{L}][\w\p{Pd}]*\s*
        name: entity.other.attribute-name.pseudo-component.protea

  # Comments

  comments:
    patterns:
      - include: '#block-comments'
      - include: '#line-comments'
      - include: '#nested-comments'

  block-comments:
    patterns:
      - begin: \s*(/\*\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
          - include: '#nested-jsdoc'
      - begin: \s*(/\*)(?=\s+|\s*$)
        end: \s*(\*/)
        name: comment.block.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline
          - include: '#nested-block'

  line-comments:
    patterns:
      - begin: \s*(///)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.documentation.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: '#jsdoc'
          - include: text.html.markdown#inline
      - begin: \s*(//)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.number-sign.protea
        captures:
          1: {name: punctuation.definition.comment.protea}
        patterns:
          - include: text.html.markdown#inline

  nested-jsdoc:
    begin: (/\*\*?)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.documentation.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested-jsdoc'

  nested-block:
    begin: (/\*)(?=\s+|\s*$)
    end: \s*(\*/)
    name: comment.block.nested.protea
    captures:
      1: {name: punctuation.definition.comment.protea}
    patterns:
      - include: text.html.markdown#inline
      - include: '#nested-block'

  # JSDoc

  jsdoc:
    patterns:
      - include: '#jsdoc-inline-tags'
      - include: '#jsdoc-access'
      - include: '#jsdoc-as-name-path'
      - include: '#jsdoc-simple'
      - include: '#jsdoc-simple-name-path'
      - include: '#jsdoc-module'
      - include: '#jsdoc-type-name'
      - include: '#jsdoc-type-no-name'
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc

  jsdoc-access:
    comment: '@tag protected....'
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}

  jsdoc-module:
    comment: '@tag {optional type} module:file'
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}

  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-name-path-scopes'

  jsdoc-simple:
    comment: '@tag'
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}

  jsdoc-simple-name-path:
    comment: '@tag {opt type} Class#xxx or Class#Event:aaaa etc'
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-path-scopes'

  jsdoc-type-name:
    comment: '@tag {optional type} name'
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|fn|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'
      - include: '#jsdoc-name-scopes'

  jsdoc-type-no-name:
    comment: '@tag {types}'
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>(?:[^\\{}]|\\.)+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-scopes'

  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}

  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}

  jsdoc-typedef-obj:
    comment: typedef object
    begin: '{'
    end: '}|^'
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: '#jsdoc-typedef-primitives'
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: '#jsdoc-name-path-scopes'
      - include: '#jsdoc-typedef-obj'

  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'

  jsdoc-name-path-scopes:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: true
        patterns:
          - include: '#jsdoc-string'

  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - name: meta.function.call.protea
        match: |
          (?x)
          (?<=
            \s* # opening
            (?:\|{1,3}> | \+>) # operator
            \s*
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|from|where|with
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|label
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b |
          (?<! # ignore qualified names
            \b (?: [?!]?\.=? | [?!:]:=?) (?: \b | ['"`\\({\[])
          )
          (?<=
            (?:
              # beginning of line
              ^
            | # or before a delimiter
              [,;({\[] \s*
            | # or before a sigil
              [$:] \s* \b
            | # key-value separator
              ['"`(){}\[\]\w]: \s
            | # operator
              (?:^ | ['"`(){}\[\]\s\w] | \\.) # anchor
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            | # open/close bracket
              (?:['"`(){}\[\]] | \\.)
              (?: [?!]?\.=? | [?!:]:=?) # accessors
            | # command syntax
              //? \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
            | (?:
                (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
                \b
                  (?: # keywords
                    in|of|as|is|new
                    |to|til|thru|by|del
                    |unset|ref|and|or|xor|not
                    |var|val|func|proc|type
                    |class|data|enum|module
                    |iter|macro|inter|object
                    |trait|style|elem|prop
                    |go|defer|do|from|where|with
                    |if|elif|else|then|def
                    |for|each|loop|while
                    |try|throw|catch|after
                    |match|case|pass|fail|goto
                    |break|next|redo|retry
                    |return|yield|await|label
                    |use|show|hide|route
                    |debug|assert|check
                  )
                \b
                (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
              )
            ) \s* # before a space
          )
          \b
          (
            # ignore all keywords
            (?!
              (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|from|where|with
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|label
                |use|show|hide|route
                |debug|assert|check
              )
              (?!\B|\p{Pd}+\b)
            )
            (?:
              \b
              [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
              \b
              (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
            )*
            [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
          )
          \b
          (?=
            \s+
            (?:
                # prefix operator literal
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
                ['"`({\[]
              | # array literal
                \[
              | # command literal
                 //? \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
              | # ignore orphaned qualified name
                (?!
                  (?: [?!]?\.=? | [?!:]:=?)
                  ['"`\\({\[\w]
                )
                # prefix operator
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*
                (?:
                  # ignore all keywords
                  (?!
                    (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
                    (?: # keywords
                      in|of|as|is|new
                      |to|til|thru|by|del
                      |unset|ref|and|or|xor|not
                      |var|val|func|proc|type
                      |class|data|enum|module
                      |iter|macro|inter|object
                      |trait|style|elem|prop
                      |go|defer|do|from|where|with
                      |if|elif|else|then|def
                      |for|each|loop|while
                      |try|throw|catch|after
                      |match|case|pass|fail|goto
                      |break|next|redo|retry
                      |return|yield|await|label
                      |use|show|hide|route
                      |debug|assert|check
                    )
                    (?!\B|\p{Pd}+\b)
                  )
                  (?:
                    \b
                    [\p{Pc}\p{L}][\w\p{Pd}]* # identifier
                    \b
                    (?: [!?]?\.=? | [?!:]:=?) # qualified name separator
                  )*
                  [\p{Pc}\p{L}][\w\p{Pd}]* # last part of identifier
                )
                (?: # closing bracket
                    [,;'"`(){}\[\]\s]
                  | # operator
                    [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
                  | # end of line
                    $
                )
            )
            | \s* # optional space
            (?: # command or string literal
                (?: \\ )
              | # function application, composition and piping
                (?: \$ | \s \. | <\|{1,3}| <\+) [\s\w]
              | # no-argument call
                \b! (?:[,;'"`)}\]\s] | $)
              | # C-style function call
                (?:[!?]\.=?|\.=)? \#?\(
              | # generics
                (?:[!?]\.=?|\.=)? < ['"`\\({\[\w]
              | # string literal or expression
                ['"`(]
            )
          )
        captures:
          1: {patterns: [include: '#function-names']}
          2: {patterns: [include: '#function-names']}

  embedded-calls:
    patterns:
      - &function-names
        name: meta.function.name.protea
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? \( ) # opening bracket
            |
            (?<= ^ # beginning of line
              | ['"`(){}\[\]\s\w] # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?= \#? \( ) # opening bracket
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.protea
          2:
            patterns: *builtin-names
            name: entity.name.tag.protea support.class.component.protea
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.protea
          4:
            patterns: *builtin-names
            name: entity.name.function.method.protea
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.protea
          6:
            patterns: *builtin-names
            name: entity.name.type.protea
          7:
            patterns: *builtin-names
            name: entity.name.class.protea
          8:
            patterns: *builtin-names
            name: entity.name.function.protea

  function-names:
    patterns:
      - &function-names
        name: meta.function.name.protea
        match: |
          (?x)
          (?:
            (?<=[!?]?\.=?|[?!:]:=?) (?<! \.\.+) \b
              (?: # Properties
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | ![:.]=? | [!$] | \s\.
                  )?
                  ['"`(){}\[\]\s\w]
              )
            |
            (?<=
              (?: ^ | [,;'"`(){}\[\]\s\w] | \\. ) # literal
              (?: # operators
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
              )?
            ) \b
              (?: # Regular variables
                # Leading underscore
                (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
              | # Train case
                ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
              | # Pascal case
                ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
              | # Camel or kebab case
                ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
            \b
              (?=
                  $ # end of line
                | (?: # operators
                    [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
                    <\|{1,3} | <\+ | \|{1,3}> | \+> | ![:.]=? | [!$] | \s\.
                  )?
                  ['"`(){}\[\]\s\w]
              )
          )
        captures:
          1:
            patterns: &builtin-names
              - include: '#type-names'
              - include: '#support-functions'
            name: entity.name.tag.protea
          2:
            patterns: *builtin-names
            name: entity.name.tag.protea support.class.component.protea
          3:
            patterns: *builtin-names
            name: entity.name.class.builtin.protea
          4:
            patterns: *builtin-names
            name: entity.name.function.method.protea
          5:
            patterns: *builtin-names
            name: entity.name.function.tagged-template.protea
          6:
            patterns: *builtin-names
            name: entity.name.type.protea
          7:
            patterns: *builtin-names
            name: entity.name.class.protea
          8:
            patterns: *builtin-names
            name: entity.name.function.protea
      - include: '#variables'
      - include: '#infix-operators'

  # Variables

  parameter-variables:
    patterns:
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            \? # optional
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
            \s*
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.optional.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            \* # spread
            \?? # optional
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.spread.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            //? # named
            \?? # optional
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.name.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            \& # reference
            \?? # optional
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.reference.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            \% # other
            \?? # optional
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.other.protea
      - match: |
          (?x)
          (?<=
            ^ # SOL
            | (?:^ | [^|]) \| # open pipe
            | [({\[] # open bracket
            | [;,] # separator
            | [(|]\. \s # uncurried function
            | (?:^ | \s) \b as \b \s # as keyword
          )
            \s*
            \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
          (?=
            $ # EOL
            | # close bracket or pipe
              \s* [)}\]] | \s* \|:? [\w\s'"`\\({\[]
            | # separator
              \s* [;,]
            | # as keyword (aliasing)
              \s+ \b as \b \s
            | # type specifier and assignment
              (?::|[?:]?=) \s* [\w'"`\\({\[]
            | \s+ (?::|[?:]?=) \s+ [\w'"`\\({\[]
          )
        name: variable.parameter.protea

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.protea
      - match: (?i)\s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.protea
      - match: (?i)\s*//?\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.protea
      - match: (?i)\s*&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.protea
      - match: (?i)\s*%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.protea
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.protea

  variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \b

      (?:
        (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
        (?: # Properties
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
      )\b
    captures:
      1: {name: variable.other.index.protea}
      2: {name: variable.other.constant.property.protea}
      3: {name: variable.other.property.static.protea}
      4: {name: variable.other.property.protea}
      5: {name: variable.other.global.protea}
      6: {name: variable.other.constant.object.protea}
      7: {name: variable.other.conditional.protea}
      8: {name: variable.other.object.protea}
      9: {name: variable.other.dollar.protea}
      10: {name: variable.other.constant.protea}
      11: {name: variable.other.class.protea}
      12: {name: variable.other.readwrite.protea}

  # Operators

  operators:
    patterns:
      - include: '#primary-operators'
      - include: '#special-operators'
      - include: '#infix-operators'
      - include: '#suffix-operators'
      - include: '#prefix-operators'

  special-operators:
    patterns:
      - begin: (?<=^|[\s({\[])(\?)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\?)(?=['"`\\({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`\\({\[\w])
        captures:
          1: {name: keyword.operator.conditional.protea}
          2: {name: keyword.operator.conditional.protea}
        patterns: [include: $self]
      - begin: (?<=^|[\s({\[])(\!)(?=['"`\\({\[\w])|(?<=['"`)}\]\w]|\\.)(\!)(?=['"`\\({\[\w])
        end: (?<=^|[\s({\[])(\:)(?=$|[)}\]\s])|(?<=['"`)}\]\w]|\\.)(\:)(?=['"`\\({\[\w])
        captures:
          1: {name: keyword.operator.ternary.protea}
          2: {name: keyword.operator.ternary.protea}
        patterns: [include: $self]

  infix-operators:
    patterns:
      - name: keyword.operator.infix.protea
        match: |
          (?xi)
          (?<=^|[\s({\[]) # opening
          (?:
            ( # 1: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`(){}\[\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 2: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 3: string / regex
              \+\+ | --
            ) |
            ( # 4: logical operator
              \&\& | \|\| | \^\^ | !
            ) |
            ( # 5: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 6: bitwise shift
              <<<? | >>>?
            ) |
            ( # 7: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 8: composition
              <\+ | \+>
            ) |
            ( # 9: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 10: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 11: equality
              == | != | === | !==
            ) |
            ( # 12: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 13: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 14: null coalescing
              \?+
            ) |
            ( # 15: non null coalescing
              !+
            ) |
            ( # 16: falsy coalescing
              \?:
            ) |
            ( # 17: truthy coalescing
              !:
            ) |
            ( # 18: function application
              [.$]
            ) |
            ( # 19: assignment
              :?=
            ) |
            ( # 20: range
              [>.]\.[.<]
            ) |
            ( # 21: fat arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 22: skinny arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 23: wavy arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 24: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 25: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 26: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 27: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 28: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 29: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 30: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 31: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 32: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 33: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 34: catch all
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            )
          )
          (?=$|[)}\]\s]) # closing
        captures:
          1: {name: keyword.operator.assignment.augmented.protea}
          2: {name: keyword.operator.arithmetic.protea}
          3: {name: keyword.operator.successor.protea}
          4: {name: keyword.operator.logical.protea}
          5: {name: keyword.operator.bitwise.protea}
          6: {name: keyword.operator.bitwise.shift.protea}
          7: {name: keyword.operator.pipeline.protea}
          8: {name: keyword.operator.compose.protea}
          9: {name: keyword.operator.class.protea}
          10: {name: keyword.operator.relational.protea}
          11: {name: keyword.operator.comparison.protea}
          12: {name: keyword.operator.similarity.protea}
          13: {name: keyword.operator.function.protea}
          14: {name: keyword.operator.null-coalescing.protea}
          15: {name: keyword.operator.coalescing.protea}
          16: {name: keyword.operator.conditional.protea}
          17: {name: keyword.operator.ternary.protea}
          18: {name: keyword.operator.macro.protea}
          19: {name: keyword.operator.assignment.protea}
          20: {name: keyword.operator.range.protea}
          21: {name: keyword.operator.arrow.fat.protea}
          22: {name: keyword.operator.arrow.skinny.protea}
          23: {name: keyword.operator.arrow.wavy.protea}
          24: {name: keyword.operator.logical.custom.protea}
          25: {name: keyword.operator.arithmetic.custom.protea}
          26: {name: keyword.operator.prototype.custom.protea}
          27: {name: keyword.operator.accessor.custom.protea}
          28: {name: keyword.operator.comparison.custom.protea}
          29: {name: keyword.operator.relational.custom.protea}
          30: {name: keyword.operator.private.custom.protea}
          31: {name: keyword.operator.math.custom.protea}
          32: {name: keyword.operator.currency.custom.protea}
          33: {name: keyword.operator.ascii.custom.protea}
          34: {name: keyword.operator.infix.protea}

  primary-operators:
    patterns:
      - name: keyword.operator.primary.protea
        match: |
          (?x)
          (?<=['"`)}\]\w]|\\.) # closing
          (?:
            ( # 1: optional accessor
            \?[.:]=?
            ) |
            ( # 2: assertion/call operator
              ![.:]=?
            ) |
            ( # 3: accessor operator
              (?:::|\.)=?
            ) |
            ( # 4: compound assignment operators
              # all operators except ~ < = > . : !
              [\p{S}\p{P}&&[^~<=>.,:;!'"`(){}\[\]\p{Pc}]]
              # operator character
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*
              = # ending equal sign
            ) |
            ( # 5: arithmetic operator
              \+ | - | \*{1,3} | //? | %%?
            ) |
            ( # 6: string / regex
              \+\+ | --
            ) |
            ( # 7: logical operator
              \&\& | \|\| | \^\^ | !
            ) |
            ( # 8: bitwise and set
              \& | \| | \^ | ~
            ) |
            ( # 9: bitwise shift
              <<<? | >>>?
            ) |
            ( # 10: pipeline
              <\|{1,3} | \|{1,3}>
            ) |
            ( # 11: composition
              <\+ | \+>
            ) |
            ( # 12: membership
              [<>][:!] | [:!][<>]
            ) |
            ( # 13: comparison
              < | > | <= | >= | <> | <=>
            ) |
            ( # 14: equality
              == | != | === | !==
            ) |
            ( # 15: similarity
              ~[=!] | [=!]~ | =<
            ) |
            ( # 16: functional
              <[/*|+$:]> | [/*|+$:]> | <[/*|+$:]
            ) |
            ( # 17: null coalescing
              \?+
            ) |
            ( # 18: non null coalescing
              !+
            ) |
            ( # 19: falsy coalescing
              \?:
            ) |
            ( # 20: truthy coalescing
              !:
            ) |
            ( # 21: function application
              [.$]
            ) |
            ( # 22: assignment
              :?=
            ) |
            ( # 23: range
              [>.]\.[.<]
            ) |
            ( # 24: fat arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* => # right side
              | <= [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 25: skinny arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* -> # right side
              | <- [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 26: wavy arrow
                [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* ~> # right side
              | <~ [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]* # left side
            ) |
            ( # 27: custom logical
              [&|^~] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 28: custom arithmetic
              [-+*/%] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 29: custom prototype
              [@:] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 30: custom accessor
              [.] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 31: custom comparison
              [=!] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 32: custom relational
              [<>] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 33: custom private
              [?\#] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 34: custom math
              \p{Sm} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 35: custom currency
              \p{Sc} # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 36: custom ascii
              [\p{S}\p{P}&&[\x80-\xFF]] # leading chars
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            ) |
            ( # 37: catch all
              [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
            )
          )
          (?=['"`\\({\[\w]) # opening
        captures:
          1: {name: keyword.operator.optional.protea}
          2: {name: keyword.operator.assert.protea}
          3: {name: keyword.operator.accessor.protea}
          4: {name: keyword.operator.assignment.augmented.protea}
          5: {name: keyword.operator.arithmetic.protea}
          6: {name: keyword.operator.successor.protea}
          7: {name: keyword.operator.logical.protea}
          8: {name: keyword.operator.bitwise.protea}
          9: {name: keyword.operator.bitwise.shift.protea}
          10: {name: keyword.operator.pipeline.protea}
          11: {name: keyword.operator.compose.protea}
          12: {name: keyword.operator.class.protea}
          13: {name: keyword.operator.relational.protea}
          14: {name: keyword.operator.comparison.protea}
          15: {name: keyword.operator.similarity.protea}
          16: {name: keyword.operator.function.protea}
          17: {name: keyword.operator.null-coalescing.protea}
          18: {name: keyword.operator.coalescing.protea}
          19: {name: keyword.operator.conditional.protea}
          20: {name: keyword.operator.ternary.protea}
          21: {name: keyword.operator.macro.protea}
          22: {name: keyword.operator.assignment.protea}
          23: {name: keyword.operator.range.protea}
          24: {name: keyword.operator.arrow.fat.protea}
          25: {name: keyword.operator.arrow.skinny.protea}
          26: {name: keyword.operator.arrow.wavy.protea}
          27: {name: keyword.operator.logical.custom.protea}
          28: {name: keyword.operator.arithmetic.custom.protea}
          29: {name: keyword.operator.prototype.custom.protea}
          30: {name: keyword.operator.accessor.custom.protea}
          31: {name: keyword.operator.comparison.custom.protea}
          32: {name: keyword.operator.relational.custom.protea}
          33: {name: keyword.operator.private.custom.protea}
          34: {name: keyword.operator.math.custom.protea}
          35: {name: keyword.operator.currency.custom.protea}
          36: {name: keyword.operator.ascii.custom.protea}
          37: {name: keyword.operator.primary.protea}

  prefix-operators:
    comment: Prefix operators
    match: |
      (?x)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]
      ) # 15
      (?=[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*
      ['"`\\({\[\w])
    name: keyword.operator.prefix.protea
    captures:
      1: {name: keyword.operator.module.all.protea}
      2: {name: keyword.operator.increment.protea}
      3: {name: keyword.operator.decrement.protea}
      4: {name: keyword.operator.intersection.protea}
      5: {name: keyword.operator.union.protea}
      6: {name: keyword.operator.symmetric.protea}
      7: {name: keyword.operator.logical.protea}
      8: {name: keyword.operator.private.protea}
      9: {name: keyword.operator.decorator.protea}
      10: {name: keyword.operator.bitwise.not.protea}
      11: {name: keyword.operator.existential.protea}
      12: {name: keyword.operator.assignment.protea}
      13: {name: keyword.operator.pipeline.protea}
      14: {name: keyword.operator.private.protea}
      15: {name: keyword.operator.prefix.protea}

  suffix-operators:
    comment: Suffix operators
    match: |
      (?x)
      (?<=(?:['"`)}\]\w]|\\.)
        [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*)
      (?:
        ([*/]) # 1
        |(\+) # 2
        |(\-) # 3
        |(\&) # 4
        |(\|) # 5
        |(\^) # 6
        |(\!) # 7
        |(\$) # 8
        |(\@) # 9
        |(\~) # 10
        |(\?) # 11
        |(\=) # 12
        |(\$) # 13
        |(\#) # 14
        |[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]
      ) # 15
    name: keyword.operator.suffix.protea
    captures:
      1: {name: keyword.operator.module.all.protea}
      2: {name: keyword.operator.increment.protea}
      3: {name: keyword.operator.decrement.protea}
      4: {name: keyword.operator.intersection.protea}
      5: {name: keyword.operator.union.protea}
      6: {name: keyword.operator.symmetric.protea}
      7: {name: keyword.operator.assert.protea}
      8: {name: keyword.operator.private.protea}
      9: {name: keyword.operator.decorator.protea}
      10: {name: keyword.operator.bitwise.protea}
      11: {name: keyword.operator.optional.protea}
      12: {name: keyword.operator.assignment.protea}
      13: {name: keyword.operator.pipeline.protea}
      14: {name: keyword.operator.private.protea}
      15: {name: keyword.operator.suffix.protea}

  # Types

  types:
    patterns:
      - include: '#line-continuation'
      - include: '#params-clause'
      - include: '#angle-brackets'
      - include: '#type-keywords'
      - include: '#type-names'
      - include: '#type-strings'
      - include: '#literals'
      - include: '#type-variables'
      - include: '#type-operators'
      - include: '#type-brackets'
      - match: \s+
        name: meta.type.protea

  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x) \b

      (?!
        (?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?: # keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|inter|object
          |trait|style|elem|prop
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|pass|fail|goto
          |break|next|redo|retry
          |return|yield|await|label
          |use|show|hide|route
          |debug|assert|check
        )
        (?!\B|\p{Pd}+\b)
      )

      (?:
        (?<= [!?]?\.=? | [?!:]:=?) (?<! \.\.+)
        (?: # Properties
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        |
        (?: # Objects
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
        (?! \.\.+) (?= [!?]?\.=? | [?!:]:=? | \#?\[)
        |
        (?: # Regular variables
            # Leading underscore
            (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*\b(?!\p{Pc}+))
          | # Train case
            ([\p{L}&&\P{Ll}]\w*\p{Pd}[\w\p{Pd}]*)
          | # Pascal case
            ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)
          | # Camel or kebab case
            ([\p{Pc}\p{L}][\w\p{Pd}]*)
        )
      )\b
    captures: &type-variables
      1: {name: entity.name.module.protea}
      2: {name: entity.name.tag.protea}
      3: {name: entity.name.namespace.protea}
      4: {name: entity.name.interface.protea}
      5: {name: entity.name.tag.block.protea}
      6: {name: entity.name.tag.script.protea}
      7: {name: entity.name.tag.style.protea}
      8: {name: entity.name.tag.inline.protea}
      9: {name: entity.name.label.protea}
      10: {name: entity.name.project.protea}
      11: {name: entity.name.class.protea}
      12: {name: entity.name.type.protea}

  type-signature:
    applyEndPatternLast: true
    name: meta.type.protea
    begin: (:)(?=$|[\w\s'"`({\[])
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.protea}
    patterns:
      - include: '#types'
      - match: \s+
        name: meta.type.protea

  type-embedded-expression:
    begin: (\${)\s*
    end: \s*(})
    name: entity.quasi.component.protea
    captures:
      1: {name: punctuation.section.embedded.protea}
    patterns:
      - include: '#types'
      - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: '#type-embedded-verbatim'
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.protea
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - match: "''"
            name: constant.character.escape.protea
          - include: '#type-embedded-verbatim'
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: '#string-escapes'
          - include: '#type-embedded'
      - comment: double quoted standard string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.protea
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.protea}
        patterns:
          - include: '#string-escapes'
          - include: '#type-embedded'

  type-embedded:
    patterns:
      - include: '#format-clause'
      - include: '#embedded-placeholder'
      - include: '#type-embedded-expression'

  type-embedded-verbatim:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.protea
      - include: '#format-clause'
      - include: '#embedded-placeholder'
      - include: '#type-embedded-expression'

  type-brackets:
    patterns:
      - include: '#type-curly-brackets'
      - include: '#type-square-brackets'
      - include: '#type-round-brackets'

  type-curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*):(?=['"`\\({\[\w\s]|$)
            name: punctuation.separator.key-value.protea
          - match: (?<=^\s*|[,;{]\s*)(?:[-+*]\s+)*[-+*](?=\s|$)
            name: punctuation.definition.block.sequence.item.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.typeparameters.protea}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: '$self'
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: '#types'
          - include: '$self'
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;(){}\[\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;(){}\[\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self

  type-round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea
    patterns:
      - begin: \s*(?<=[\w'"`)}\]>]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: '#punctuation'
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#parameter-variables'
          - include: '#types'
          - include: self
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.protea}
        patterns:
          - include: '#labels'
          - include: '#types'
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - include: '#types'
          - include: $self

  type-square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
    patterns:
      - begin: \s*(?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.protea}
        patterns:
          - include: '#punctuation'
          - include: '#types'
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: '#types'
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: '#types'
          - include: $self

  type-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.extends.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.implements.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(infer|as|is)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type|name|size|key)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1of.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inst)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.instanceof.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(val)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.valueof.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(attr)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.attributeof.protea

  type-operators:
    patterns:
      - match: \s*(--?>|~~?>)
        name: keyword.operator.type.function.protea
      - match: \s*(<--?|<~~?)
        name: keyword.operator.type.channel.protea
      - comment: Function types
        match: (?:^|\s+)(?:(\|)|(>))(?=['"`({\[\w])|(?<=['"`)}\]\w])(?:(\|)|(<))(?:$|\s+)
        captures:
          1: {name: keyword.operator.type.function.protea}
          2: {name: keyword.operator.type.channel.protea}
          3: {name: keyword.operator.type.function.protea}
          4: {name: keyword.operator.type.channel.protea}
      - &primary-operators
        comment: Primary binary operators
        match: (?<=['"`)}\]\w])(?:([>.]\.[.<])|(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=['"`\\({\[\w])
        captures:
          1: {name: keyword.operator.range.protea}
          2: {name: keyword.operator.optional.protea}
          3: {name: keyword.operator.assert.protea}
          4: {name: keyword.operator.accessor.protea}
      - comment: type operators
        match: \s*(?:(\+)|(\-)|(\*)|(\/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|([<>]))(?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.protea}
          2: {name: keyword.operator.difference.protea}
          3: {name: keyword.operator.product.protea}
          4: {name: keyword.operator.quotient.protea}
          5: {name: keyword.operator.remainder.protea}
          6: {name: keyword.operator.only.protea}
          7: {name: keyword.operator.maybe.protea}
          8: {name: keyword.operator.intersection.protea}
          9: {name: keyword.operator.union.protea}
          10: {name: keyword.operator.symmetric.protea}
          11: {name: keyword.operator.negation.protea}
          12: {name: keyword.operator.macro.dollar.protea}
          13: {name: keyword.operator.class.protea}

  # Clauses and Keywords

  block-entities:
    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
        name: entity.name.namespace.protea
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.implements.protea}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.namespace.protea
          - match: *entity-name
            name: entity.name.trait.protea
          - include: '#comments'
          - include: '#comma'
          - include: '#line-continuation'
      - applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.protea}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.protea
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.module.protea
          - match: *entity-name
            name: entity.name.interface.protea
          - include: '#comments'
          - include: '#comma'
          - include: '#line-continuation'
      - include: '#comments'
      - include: '#comma'
      - include: '#line-continuation'
      - include: '#type-keywords'
      - include: '#type-square-brackets'
      - include: '#parameter-brackets'
      - include: '#type-signature'
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.protea
      - include: '#regexps'
      - include: '#strings'
      - include: '#symbols'
      - include: '#constants'

      - applyEndPatternLast: true
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]))
        end: (?=)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.protea}
        patterns: [include: '#types']
      - match: '\.|::'
        name: punctuation.separator.namespace.protea
      - match: \s+
        name: meta.block.protea

  modifier-keywords:
    match: |
      (?x)
      (
        (?:
          (?:
            \s*
            (?<!(?:(?<!\.)\.|[?!:]:)=?)
            \b
              (?:
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
            )
            (?!\B|\p{Pd}+\b)
          \s*
        )*
      )
      (?=
        \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
        (?:
          var|val|func|proc|type
          |class|data|enum|module
          |iter|macro|inter|object
          |trait|style|elem|prop
        )
        (?!\B|\p{Pd}+\b)
      )
    captures:
      1:
        patterns:
          - include: '#modifiers'

  modifiers:
    patterns:
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            pub|priv|prot|final|immut|mut|over
            |global|local|intern|extern|imply|exply
            |post|[gs]et|rem
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.modifier.protea
      - comment: Visibility modifiers
        match: |
          (?x) \s*
          \b
          (?:
            seal|abst|impure|pure|early|late
            |covar|contra|a?sync|stat|dyn|lazy
            |eager|bound|free|uniq|struct
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.type.accessor.protea
      - comment: Functional modifiers
        match: |
          (?x) \s*
          \b
          (?:
            rec|oper|curry|inline
            |prefix|suffix|infix|binary|unary|left|right
          )
          (?!\B|\p{Pd}+\b)
          \s*
        name: storage.type.property.protea

  declaration-keywords:
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl|def)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.declare.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.style.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.function.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.procedure.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.class.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.data.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.enum.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.module.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.iterator.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.macro.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.structure.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.object.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.trait.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.component.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.property.protea

  general-keywords:
    comment: general keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif|else)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.conditional.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|loop|while)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.loop.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|throw|catch|after)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.trycatch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|case|fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.switch.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.flow.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(use|show|hide|route)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.module.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then|do|from|ref|go|defer)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|assert|check|where)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.$1.protea

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.delete.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.range.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.void.protea
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(and|or|xor|not)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.logical.protea

  keywords:
    patterns:
      - include: '#validation-expression'
      - include: '#module-expression'
      - include: '#control-expression'
      - include: '#query-expression'
      - include: '#modifier-keywords'
      - include: '#declaration-keywords'
      - include: '#expression-keywords'
      - include: '#general-keywords'

    repository:
      control-expression:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.flow.protea}
        patterns:
          - match: *entity-name
            name: constant.other.label.protea

      module-expression:
        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(use|show|hide|route)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.module.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.module.protea
              - include: '#type-keywords'
              - include: '#declarations'
              - include: '#strings'
              - include: '#symbols'
              - include: '#type-operators'
              - match: ','
                name: punctuation.separator.comma.protea
              - match: *entity-name
                name: variable.other.readwrite.alias.protea

      validation-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.validate.protea}
        end: (?=[,;)}\]])
        patterns:
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.protea
          - include: $self

      query-expression:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.query.protea}
        end: (?=[,;)}\]])
        patterns:
          - include: '#query-body'
          - include: $self

      query-body:
        patterns:
          - include: '#in-clause'
          - include: '#where-clause'
          - include: '#join-clause'
          - include: '#sort-clause'
          - include: '#select-clause'
          - include: '#group-clause'
          - include: '#limit-clause'
          - include: '#reduce-clause'

        repository:
          in-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          join-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:full|part|self|cross)?(?!\B|\p{Pd}+\b)\s*\b(?:inner|outer|left|right)?(?!\B|\p{Pd}+\b)\s*\bjoin)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b([io]nto|equal)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          where-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having|filter|reject)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          sort-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:sort|order)(?!\B|\p{Pd}+\b)\s*\b(?:asc|desc)?(?!\B|\p{Pd}+\b)\s*\b(?:by|with)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - include: '#query-body'
              - include: $self

          select-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:select|map)(?!\B|\p{Pd}+\b)\s*\b(?:unique|any|all)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          limit-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit|offset)(?!\B|\p{Pd}+\b)\s*\b(?:first|last|head|tail)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          reduce-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?!\B|\p{Pd}+\b)\s*\b(?:left|right)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

          group-clause:
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.protea}
            end: (?=[,;)}\]])
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.protea
              - include: '#query-body'
              - include: $self

  declarations:
    patterns:
      - include: '#variable'
      - include: '#declare'
      - include: '#style'
      - include: '#markup'
      - include: '#function'
      - include: '#procedure'
      - include: '#class'
      - include: '#data'
      - include: '#enum'
      - include: '#module'
      - include: '#iterator'
      - include: '#macro'
      - include: '#structure'
      - include: '#object'
      - include: '#trait'
      - include: '#component'
      - include: '#property'

    repository:
      style:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.style.protea}
        name: meta.style.protea
        patterns:
          - include: '#style-rules'
          - include: '#style-pair'
          - include: '#style-block'
          - applyEndPatternLast: true
            name: meta.style.protea
            begin: \s*([?:]?=)\s*
            captures:
              1: {name: keyword.operator.assignment.protea}
            end: (?=)|$
            patterns:
              - include: '#style-pair'
              - include: '#style-rules'
              - include: '#style-block'
              - include: '#block-entities'
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.style.protea

      component:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.component.protea
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.protea}

      declare:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.protea}

      function:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(func)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.function.protea

      procedure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.procedure.protea

      class:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.class.protea

      data:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.data.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.data.protea

      enum:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.enum.protea

      module:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.module.protea

      iterator:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.iterator.protea

      macro:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.macro.protea

      structure:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.structure.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.structure.protea

      object:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.object.protea

      trait:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.trait.protea

      property:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.property.protea}
        patterns:
          - include: '#block-entities'
          - match: *entity-name
            name: entity.name.property.protea

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: '#modifier-keywords']}
      - begin: |
          (?x)

          (?<=[?!:]:|\b\.|[?!]\.)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)
        end: (?<=^|['"`)}\]\w\s]|\\.)(\|)(?=:?(?:[\w\s'"`({\[])|$)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.method.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: '#modifier-keywords']}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: [include: '#param-bracket-content']
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: '#modifier-keywords']}
      - begin: |
          (?x)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+

          # Assignment operator
          (:?=)\s+

          \s*

          (
            (?:
              \s*
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \s*
            )*
          )

          \s*
          (\|)(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)
        end: (?<=^|['"`)}\]\w\s]|\\.)(\|)(?=:?(?:[\w\s'"`({\[])|$)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: keyword.operator.assignment.protea}
          3: {patterns: [include: '#modifier-keywords']}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: [include: '#param-bracket-content']

  params-clause:
    begin: |
      (?x)
      (?<=
        (?:
          # beginning of line
          ^
        | # or before a delimiter
          [,;({\[]
        | # or before a sigil
          [$:] \s* \b
        | # key-value separator
          ['"`(){}\[\]\w]: \s
        | # operator
          (?:^ | ['"`(){}\[\]\s\w] | \\.) # anchor
          [\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+
        | # open/close bracket
          (?:['"`(){}\[\]] | \\.)
          (?: [?!]?\.=? | [?!:]:=?) # accessors
        | # command syntax
          //? \b [\p{Pc}\p{L}][\w\p{Pd}]* \b
        | (?:
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
                |var|val|func|proc|type
                |class|data|enum|module
                |iter|macro|inter|object
                |trait|style|elem|prop
                |go|defer|do|from|where|with
                |if|elif|else|then|def
                |for|each|loop|while
                |try|throw|catch|after
                |match|case|pass|fail|goto
                |break|next|redo|retry
                |return|yield|await|label
                |use|show|hide|route
                |debug|assert|check
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
          )
        )
      ) \s* # before a space
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.protea}
    end: (?<=^|['"`)}\]\w\s]|\\.)(\|)(?=:?(?:[\w\s'"`({\[])|$)
    patterns: [include: '#param-bracket-content']

  clauses:
    patterns:
      - include: '#for-clause'
      - include: '#if-clause'
      - include: '#match-clause'
      - include: '#catch-clause'
      - include: '#with-clause'
      - include: '#do-clause'
      - include: '#type-clause'
      - include: '#new-clause'

  closures:
    patterns:
      - begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        captures:
          1: {name: keyword.control.match.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - include: '#params-clause'
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.match.protea}
            patterns:
              - include: '#types'
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(var|val)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.protea
          - include: '#type-keywords'
          - include: $self
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.match.protea

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: '#parameter-variables'

      new-clause:
        applyEndPatternLast: true
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)(?!\B|\p{Pd}+\b)
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.protea}
        patterns:
          - match: *entity-name
            name: entity.name.instance.protea
          - include: '#type-keywords'
          - include: '#type-square-brackets'
          - include: '#parameter-brackets'
          - include: '#round-brackets'

      type-clause:
        repository:
          punctuation:
            patterns:
              - match: ','
                name: punctuation.separator.mapping.protea
              - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*):(?=['"`\\({\[\w\s]|$)
                name: punctuation.separator.key-value.protea
              - match: (?<=^\s*|[,;{]\s*)(?:[-+*]\s+)*[-+*](?=\s|$)
                name: punctuation.definition.block.sequence.item.protea

          type-records:
            patterns:
              - begin: \s*(\#\{)\s*
                end: \s*(\})
                captures:
                  1: {name: punctuation.section.mapping.protea}
                patterns:
                  - include: '#labels'
                  - include: '#punctuation'
                  - include: '#types'
                  - include: $self
              - begin: \s*(\{)\s*
                end: \s*(\})
                captures:
                  1: {name: punctuation.definition.dictionary.protea}
                patterns:
                  - include: '#labels'
                  - include: '#punctuation'
                  - include: '#types'
                  - include: $self

        patterns:
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.protea}
            patterns: [include: '#types']
          - applyEndPatternLast: true
            begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.protea}
            patterns:
              - include: '#type-records'
              - include: '#types'
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.protea}

      catch-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(catch)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.catch.protea
        captures:
          1: {name: keyword.control.error.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.protea
              - include: $self
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.error.protea
          - include: $self

      for-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|while)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.for.protea
        captures:
          1: {name: keyword.control.loop.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - &for-clause-keywords
            match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.loop.protea
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - *for-clause-keywords
              - include: $self
          - include: $self

      if-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|elif)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.if.protea
        captures:
          1: {name: keyword.control.conditional.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - include: '$self'

      match-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.switch.protea
        captures:
          1: {name: keyword.control.match.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - include: '$self'

      with-clause:
        begin: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.with.protea
        captures:
          1: {name: keyword.control.with.protea}
          2: {name: punctuation.separator.colon.protea}
        patterns:
          - &with-clause-keywords
            match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.with.protea
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.protea}
            patterns:
              - *with-clause-keywords
              - include: $self
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^ | [{;,] \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)\s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \b
              \s*
            )*
          )

          (?=
            \s*
            \b
            (?: # Function types
              iter|func|proc|macro
            )
            \b
          )
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {patterns: [include: '#modifier-keywords']}
      - begin: |
          (?x)
          (?<=^ | [{;,] \s*)

          \s*

          # Label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          # Key value separator
          (:)

          \s*

          (
            (?:
              \s*
              \b
              (?: # Modifier keywords
                pub|priv|prot|final|immut|mut|over
                |global|local|intern|extern|imply|exply
                |post|[gs]et|rem

                |seal|abst|impure|pure|early|late
                |covar|contra|a?sync|stat|dyn|lazy
                |eager|bound|free|uniq|struct

                |rec|oper|curry|inline
                |prefix|suffix|infix|binary|unary|left|right
              )
              \b
              \s*
            )*
          )

          \s*
          (\|)(?![\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]+)
        end: (?<=^|['"`)}\]\w\s]|\\.)(\|)(?=:?(?:[\w\s'"`({\[])|$)
        name: meta.object-literal.key.protea
        captures:
          1: {name: entity.name.function.protea}
          2: {name: punctuation.separator.key-value.protea}
          3: {patterns: [include: '#modifier-keywords']}
          4: {name: punctuation.separator.arguments.protea}
        endCaptures:
          1: {name: punctuation.separator.arguments.protea}
        patterns: [include: '#param-bracket-content']
      - match: |
          (?x)
          (?<=^ | [{;,] \s*)

          \s*

          # label
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)

          (?=: ['"`\\(){}\[\]\s\w])
        name: meta.object-literal.key.protea
        captures:
          1:
            name: constant.other.object.key.protea
            patterns:
              - include: '#constants'
              - include: '#numbers'
              - include: '#symbols'
              - include: '#string-content'

  # Punctuation

  punctuation:
    patterns:
      - include: '#line-continuation'
      - include: '#comma'
      - include: '#semicolon'

  line-continuation:
    begin: \s*(\\)\s*(?=/[/*]\s|$)
    end: ^\s*
    captures:
      1: {name: punctuation.separator.continuation.line.protea}
    patterns: [include: '#comments']
  comma:
    match: \s*(,)
    name: punctuation.separator.comma.protea
  double-semicolon:
    match: \s*(;;)
    name: punctuation.terminator.expression.protea
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.protea

  brackets:
    patterns:
      - include: '#curly-brackets'
      - include: '#square-brackets'
      - include: '#round-brackets'
      - include: '#angle-brackets'

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments
        begin: (?<=^|['"`)}\]\s\w])(<)(?=['"`({\[\w])
        end: (?<=^|['"`)}\]>\w])(>)
        captures:
          1: {name: punctuation.type.arguments.protea}
        patterns:
          - include: '#punctuation'
          - include: '#brackets'
          - include: '#types'

  parameter-brackets:
    begin: (\()\s*
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.protea}
    patterns:
      - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.protea
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.protea
      - include: '#clauses'
      - include: '#constants'
      - include: '#declarations'
      - include: '#expression-keywords'
      - include: '#parameter-variables'
      - include: $self

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.mapping.protea
          - match: (?<=(?:['"`)}\]\w]|\\.)[\p{S}\p{P}&&[^,;'"`\\(){}\[\]\p{Pc}]]*):(?=['"`\\({\[\w\s]|$)
            name: punctuation.separator.key-value.protea
          - match: (?<=^\s*|[,;{]\s*)(?:[-+*]\s+)*[-+*](?=\s|$)
            name: punctuation.definition.block.sequence.item.protea

    patterns:
      - begin: |
          (?x)
          (?<=
              [\w'"`)}\]] | \\. # literal
            | [^.]\.=?|[?!:]:=?
          )
          (\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.typeparameters.protea}
        patterns:
          - include: '#types'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # destructuring keywords
                var|val
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:^|[,;'"`(){}\[\]\s]|\\.) # beside a delimiter or space
            \b
              (?: # expression keywords
                in|of|as|is|new
                |to|til|thru|by|del
                |unset|ref|and|or|xor|not
              )
            \b
            (?:$|[,;'"`(){}\[\]\\\s]) # beside a delimiter or space
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: '$self'
      - begin: |
          (?x)
          (?<=
            (?:
                (?:^|[\s\p{P}\p{S}]): \|\s+\|
              | (?:^|['"`)}\]\w]|\\.)\|
              | ^\s*\|
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: '$self'
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;(){}\[\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+
            )
            \s*
          )
          (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: |
          (?x)
          (?<=
            (?:
                ^
              | [,;({\[]
              | (?:^|[,;(){}\[\]\w'"`]|\\.):\s*
              | [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+
            )
            \s*
          )
          (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.protea}
        patterns:
          - include: '$self'
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.protea}
        patterns:
          - include: '$self'

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.arguments.protea
          - match: \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.protea
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.protea
    patterns:
      - begin: (?<=[\w'"`)}\]>]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.protea}
        patterns:
          - include: '#punctuation'
          - include: '#clauses'
          - include: '#constants'
          - include: '#declarations'
          - include: '#expression-keywords'
          - include: '#parameter-variables'
          - include: $self
      - begin: (?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.protea}
        patterns:
          - include: '#labels'
          - include: $self
      - begin: (\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.protea}
        patterns:
          - include: '$self'

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
    patterns:
      - begin: (?<=\b(?:var|val|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.protea}
        patterns:
          - include: '#labels'
          - include: '#punctuation'
          - include: $self
      - begin: (?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.protea}
        patterns:
          - include: '#punctuation'
          - include: $self
      - begin: (\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.protea}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: $self
      - begin: (\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.protea}
        patterns:
          - match: ','
            name: punctuation.separator.sequence.protea
          - include: $self

  # Support

  css-property-names:
    patterns:
      - match: |
          (?x)\b(
            # Standard CSS
            additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration
            |animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backdrop-filter
            |backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image
            |background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border
            |border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color
            |border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius
            |border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image
            |border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end
            |border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color
            |border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width
            |border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius
            |border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style
            |border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side
            |caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|column-count|column-fill|column-gap
            |column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|content|counter-increment
            |counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis
            |flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family
            |font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch
            |font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures
            |font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical
            |grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start
            |grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows
            |hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align
            |inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation
            |justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style
            |list-style-image|list-style-position|list-style-type|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start
            |margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset
            |mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode
            |mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width
            |max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position
            |offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans
            |outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline
            |overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]
            |pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left
            |padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin
            |place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align
            |ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start
            |scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right
            |scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom
            |scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right
            |scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type
            |scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size
            |speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit
            |stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright
            |text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style
            |text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation
            |text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-position|top|touch-action|transform
            |transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function
            |translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change
            |word-break|word-spacing|word-wrap|writing-mode|z-index|zoom

            # SVG attributes
            |alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile
            |color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity
            |glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid
            |marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap
            |stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y

            # Not listed on MDN; presumably deprecated
            |adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break
            |balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length
            |bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction
            |box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column
            |column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break
            |delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust
            |drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position
            |flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before
            |hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust
            |initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count
            |justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift
            |line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed
            |marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group
            |orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range
            |play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim
            |radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness
            |right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color
            |rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral
            |speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch
            |string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height
            |text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style
            |top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range
            |voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap

            # Standard CSS
            |additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration
            |animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter
            |backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage
            |backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border
            |borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor
            |borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius
            |borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage
            |borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd
            |borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor
            |borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth
            |borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius
            |borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle
            |borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide
            |caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap
            |columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement
            |counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis
            |flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily
            |fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch
            |fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures
            |fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical
            |grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart
            |gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows
            |hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign
            |inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation
            |justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle
            |listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart
            |marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset
            |maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode
            |maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth
            |maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition
            |offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans
            |outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline
            |overflowWrap|overflow[XY]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior[XY]
            |pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft
            |paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin
            |placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign
            |rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart
            |scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight
            |scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom
            |scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight
            |scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType
            |scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size
            |speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit
            |strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright
            |textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle
            |textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation
            |textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform
            |transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction
            |translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange
            |wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom

            # SVG attributes
            |alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile
            |colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity
            |glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid
            |markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap
            |strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y

            # Not listed on MDN; presumably deprecated
            |adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak
            |balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength
            |bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection
            |boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column
            |columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak
            |delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust
            |dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition
            |flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore
            |hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust
            |initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount
            |justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift
            |lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed
            |marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup
            |orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange
            |playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim
            |radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness
            |rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor
            |ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral
            |speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch
            |stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight
            |textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle
            |topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange
            |voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap
          )(?!\B|\p{Pd}+\b)
        name: support.type.property-name.css.protea

  css-value-names:
    comment: TODO
    patterns:
      - match: |
          (?x)\b(
            aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow
          )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-standard-color-name.css.protea
      - match: |
          (?x)\b(
            aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood
            |cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan
            |darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange
            |darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise
            |darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen
            |gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki
            |lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow
            |lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray
            |lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue
            |mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise
            |mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered
            |orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum
            |powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell
            |sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato
            |transparent|turquoise|violet|wheat|whitesmoke|yellowgreen
          )(?!\B|\p{Pd}+\b)
        name: support.constant.color.w3c-extended-color-name.css.protea
      - match: \b(currentColor)(?!\B|\p{Pd}+\b)
        name: support.constant.color.current.css.protea
      - match: |
          (?x)\b(
            ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow
            |ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption
            |InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow
            |ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText
          )(?!\B|\p{Pd}+\b)
        name: support.constant.color.system.css.protea
      - match: |
          (?x)\b(
            above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse
            |always|antialiased|auto|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel
            |bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn
            |color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover
            |crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures
            |distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in
            |ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded
            |fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|free|uniq|structze
            |from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide
            |historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space
            |ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start
            |inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83
            |jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB
            |lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent
            |match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize
            |nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures
            |no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize
            |oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line
            |pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]
            |reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text
            |ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate
            |sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller
            |smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap
            |step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table
            |table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl
            |text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle
            |ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical
            |vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out

            |above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse
            |always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel
            |bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets
            |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn
            |colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover
            |crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures
            |distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn
            |easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded
            |fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|free|uniq|structze
            |fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide
            |historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace
            |ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart
            |inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83
            |jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB
            |liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent
            |matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize
            |nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures
            |noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize
            |oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
            |paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine
            |preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat[xy]
            |resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText
            |rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate
            |sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller
            |smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap
            |stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table
            |tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl
            |text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle
            |ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical
            |verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy
            |weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut
          )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.css.protea
      - match: |
          (?x)\s*\b(
            arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic
            |decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am
            |ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew
            |hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer
            |korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek
            |lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal
            |square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian
            |upper-latin|upper-roman|urdu

            |arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic
            |decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm
            |ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew
            |hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer
            |koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek
            |lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal
            |square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian
            |upperLatin|upperRoman|urdu
          )(?!\B|\p{Pd}+\b)
        name: support.constant.property-value.list-style-type.css.protea
      - match: |
          (?x)\s*\b(
            arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma
            |times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif
            |monospace
            |arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma
            |times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif
            |monospace
          )(?!\B|\p{Pd}+\b)
        name: support.constant.font-name.css.protea

  html-tag-names:
    patterns:
      - match: |
          (?x)\b(?:
            (all|print|screen|speech)
            |(aural|braille|embossed|handheld|projection|tty|tv)
          )(?!\B|\p{Pd}+\b)
        name: support.constant.media.css.protea
      - match: |
          (?x)\b(

            # HTML
            a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound
            |big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command
            |content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset
            |figcaption|figure|font|footer|form|frame|frameset|h(?:0|[1-9]\d*)|head|header|hgroup|hr|html|i
            |iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark
            |marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript
            |object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc
            |ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong
            |style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr
            |track|tt|u|ul|var|video|wbr|xmp

            # SVG
            |altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform
            |circle|clipPath|colorProfile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix
            |feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap
            |feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur
            |feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting
            |feSpotLight|feTile|feTurbulence|filter|fontFace|fontFaceFormat|fontFaceName
            |fontFaceSrc|fontFaceUri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern
            |line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata
            |missingGlyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor
            |stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern

            # MathML
            |annotation|annotationXml|maction|maligngroup|malignmark|math|menclose|merror|mfenced
            |mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot
            |mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup
            |msup|mtable|mtd|mtext|mtr|munder|munderover|semantics
          )(?!\B|\p{Pd}+\b)
        name: entity.name.tag.css.protea

  entities:
    patterns:
      - include: '#function-names'
      - include: '#constant-names'
      - include: '#type-names'
      - include: '#variable-names'

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)
            |Imag|Comp|Char|Rune|Str|Sym
            |(U?Int|[UI])(8|16|32|64|128)
            |([CI]?Float|[CI]?F)(16|32|64|128)
            # lower flat case
            |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)
            |imag|comp|char|rune|str|sym
            |(u?int|[ui])(8|16|32|64|128)
            |([ci]?float|[ci]?f)(16|32|64|128)
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.primitive.protea
      - comment: Data structure classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            Array|Tuple|List|Set|Hash|Seq|Str|Dict|Iter
            |Proc|Range|Stack|Heap|Queue|Tree|Trie|Rec
            |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
            # lower flat case
            |array|tuple|list|set|hash|seq|str|dict|iter
            |proc|range|stack|heap|queue|tree|trie|rec
            |future|stream|regexp?|func|buf|strbuf|bytes
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.protea
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<![?!]?\.|[?!:]:)\b(
            True|False|Null|Void|NaN|Infin|Empty|Unit|Obj
            |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const
            # lower flat case
            |true|false|null|void|nan|infin|empty|unit|obj
            |any|mixed|just|some|none|never|(im)?pure|const
          )(?!\B|\p{Pd}+\b)
        name: support.type.primitive.protea
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)(?!\B|\p{Pd}+\b)
        name: support.class.error.protea
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.interface.protea
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.namespace.protea
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able(?!\B|\p{Pd}+\b)
        name: support.class.trait.protea

  support-functions:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: Python and Perl 6/Raku built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)
          (
            # Python
            import|abs|all|any|ascii|bin|breakpoint|callable|chr|compile
            |copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter
            |format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance
            |issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct
            |open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted
            |sum|vars|zip|file|reduce|intern|rawInput|unicode|cmp|basestring|execfile
            |long|xrange|bool|bytearray|bytes|classmethod|complex|dict|float|frozenset
            |int|list|object|property|set|slice|staticmethod|str|tuple|type

            # JavaScript
            |isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI
            |decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|require
            |(?:clear|set)(?:Interval|Timeout)

            # Go
            |append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println
            |real|recover

            # Lua
            |coroutine|create|resume|running|status|wrap|yield|string|byte|char|dump|find
            |format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper|table|concat|insert
            |maxn|remove|sort|math|abs|acos|asin|atan2?|ceil|cosh?|deg|exp|floor|fmod|frexp
            |ldexp|log|log10|max|min|modf|pow|rad|random|randomseed|sinh?|sqrt|tanh?
            |io|close|flush|input|lines|open|output|popen|read|tmpfile|type|write
            |os|clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname
            |package|cpath|loaded|loadlib|path|preload|seeall|debug|debug|[gs]etfenv
            |[gs]ethook|getinfo|[gs]etlocal|[gs]etmetatable|getregistry|[gs]etupvalue
            |traceback|assert|collectgarbage|dofile|error|getfenv|getmetatable|ipairs
            |loadfile|loadstring|module|next|pairs|pcall|print|rawequal|rawget|rawset
            |require|select|setfenv|setmetatable|tonumber|tostring|type|unpack|xpcall

            # Perl
            |eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints|chmod|split|reduce
            |min|max|reverse|truncate|zip|cat|roundrobin|classify|first|sum|keys|values|pairs
            |defined|delete|exists|elems|end|kv|any|all|one|wrap|shape|key|value|name|pop|push
            |shift|splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt|sin|cos|tan
            |round|strand|roots|cis|unpolar|polar|atan2|pick|chop|p5chop|chomp|p5chomp|lc
            |lcfirst|uc|ucfirst|capitalize|normalize|pack|unpack|quotemeta|comb|samecase
            |sameaccent|chars|nfd|nfc|nfkd|nfkc|printf|sprintf|caller|evalfile|run|runinstead
            |nothing|want|bless|chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin
            |getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print|open|read|write
            |readline|say|seek|close|opendir|readdir|slurp|spurt|shell|run|pos|fmt|vec|link
            |unlink|symlink|uniq|pair|asin|atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh
            |tanh|asinh|done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh|asech|ok
            |nok|planOk|diesOk|livesOk|skip|todo|pass|flunk|forceTodo|useOk|isaOk|diag|isDeeply
            |isnt|like|skipRest|unlike|cmpOk|evalDiesOk|nokError|evalLivesOk|approx|isApprox
            |throwsOk|versionLt|plan|eval|succ|pred|times|nonce|once|signature|new|connect
            |operator|undef|undefine|sleep|from|to|infix|postfix|prefix|circumfix|postcircumfix
            |minmax|lazy|count|unwrap|getc|pi|e|context|void|quasi|body|each|contains|rewinddir
            |subst|can|isa|flush|arity|assuming|rewind|callwith|callsame|nextwith|nextsame|attr
            |evalElsewhere|none|srand|trim|trimStart|trimEnd|lastcall|what|where|how|which|var
            |who|whence|accepts|rejects|not|true|iterator|by|re|im|invert|flip|gist|flat|tree
            |isPrime|throwsLike|trans
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.protea
      - comment: JavaScript StdLib functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
            scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
            sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|
            Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
            Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
            savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
            contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
            createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
            test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
            untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins|refresh|paddings|parse|
            print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
            fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
            forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
            abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
            releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
            Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
            Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
            moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.protea
      - comment: Python magic functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)
          (
            \p{Pc}+ (?:
              abs|add|aenter|aexit|aiter|and|anext|await|bool|call|ceil|cmp|coerce|complex
              |contains|copy|deepcopy|del|delattr|delete|delitem|delslice|dir|div|divmod|enter
              |eq|exit|float|floor|floordiv|format|ge|get|getattr|getattribute|getinitargs
              |getitem|getnewargs|getslice|getstate|gt|hash|hex|iadd|iand|idiv|ifloordiv|ilshift
              |imod|imul|index|init|instancecheck|int|invert|ior|ipow|irshift|isub|iter|itruediv
              |ixor|le|len|long|lshift|lt|missing|mod|mul|ne|neg|new|next|nonzero|oct|or|pos|pow
              |radd|rand|rdiv|rdivmod|reduce|reduceEx|repr|reversed|rfloordiv|rlshift|rmod|rmul
              |ror|round|rpow|rrshift|rshift|rsub|rtruediv|rxor|set|setattr|setitem|setslice
              |setstate|sizeof|str|sub|subclasscheck|truediv|trunc|unicode|xor|matmul|rmatmul
              |imatmul|initSubclass|setName|fspath|bytes|prepare|all|bases|builtins|class
              |classGetitem|code|debug|defaults|dict|doc|file|fn|kwdefaults|members|metaclass
              |methods|module|mro|mroEntries|name|qualname|postInit|self|signature|slots
              |subclasses|version|weakref|wrapped|annotations|classcell|spec|path|package
              |future|traceback
            ) \p{Pc}+
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea
      - comment: CSS, LESS and SASS functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            abs|acos|alpha|argb|asin|atan|average|blue|calc|ceil
            |color|contrast|convert|convert|cos|darken|data-uri
            |desaturate|difference|e|escape|exclusion|extract
            |fade|fadein|fadeout|floor|format|green|greyscale
            |hardlight|hsl|hsla|hsv|hsva|hsvhue|hsvsaturation
            |hsvvalue|hue|length|lighten|lightness|luma|max|min
            |mix|mod|multiply|negation|overlay|percentage|pi|pow
            |red|replace|round|saturate|saturation|screen|sin
            |softlight|spin|sqrt|tan|unit
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea
      - comment: Ruby kernel functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            # Ruby builtin functions
            abort|atExit|autoload|binding|callcc|caller|callerLocations
            |chomp|chop|eval|exec|exit|exit|fork|format|gets
            |globalVariables|gsub|lambda|load|localVariables|open
            |p|print|printf|proc|putc|puts|rand|readline|readlines
            |select|setTraceFunc|sleep|spawn|sprintf|srand|sub
            |syscall|system|test|traceVar|trap|untraceVar|warn

            # C StdLib
            |abort|abs|acos|asctime|asctimeR|asin|assert|atan|atan2|atexit|atof|atoi|atol|bsearch|btowc|calloc
            |catclose6|catgets6|catopen6|ceil|clearerr|clock|cos|cosh|ctime|ctime64|ctimeR|ctime64R|difftime
            |difftime64|div|erf|erfc|exit|exp|fabs|fclose|fdopen5|feof|ferror|fflush1|fgetc1|fgetpos1|fgets1
            |fgetwc6|fgetws6|fileno5|floor|fmod|fopen|fprintf|fputc1|fputs1|fputwc6|fputws6|fread|free|uniq|struct|freopen
            |frexp|fscanf|fseek1|fsetpos1|ftell1|fwide6|fwprintf6|fwrite|fwscanf6|gamma|getc1|getchar1|getenv
            |gets|getwc6|getwchar6|gmtime|gmtime64|gmtimeR|gmtime64R|hypot|isalnum|isalpha|isascii4|isblank
            |iscntrl|isdigit|isgraph|islower|isprint|ispunct|isspace|isupper|iswalnum4|iswalpha4|iswblank4
            |iswcntrl4|iswctype4|iswdigit4|iswgraph4|iswlower4|iswprint4|iswpunct4|iswspace4|iswupper4|iswxdigit4
            |isxdigit4|j0|j1|jn|labs|ldexp|ldiv|localeconv|localtime|localtime64|localtimeR|localtime64R
            |log|log10|longjmp|malloc|mblen|mbrlen4|mbrtowc4|mbsinit4|mbsrtowcs4|mbstowcs|mbtowc|memchr|memcmp
            |memcpy|memmove|memset|mktime|mktime64|modf|nextafter|nextafterl|nexttoward|nexttowardl
            |nlLanginfo4|perror|pow|printf|putc1|putchar1|putenv|puts|putwc6|putwchar6|qsort|quantexpd32
            |quantexpd64|quantexpd128|quantized32|quantized64|quantized128|samequantumd32|samequantumd64
            |samequantumd128|raise|rand|randR|realloc|regcomp|regerror|regexec|regfree|remove|rename|rewind1
            |scanf|setbuf|setjmp|setlocale|setvbuf|signal|sin|sinh|snprintf|sprintf|sqrt|srand|sscanf
            |strcasecmp|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strfmon4|strftime|strlen
            |strncasecmp|strncat|strncmp|strncpy|strpbrk|strptime4|strrchr|strspn|strstr|strtod|strtod32
            |strtod64|strtod128|strtof|strtok|strtokR|strtol|strtold|strtoul|strxfrm|swprintf|swscanf|system
            |tan|tanh|time|time64|tmpfile|tmpnam|toascii|tolower|toupper|towctrans|towlower4|towupper4|ungetc1
            |ungetwc6|vaArg|vaCopy|vaEnd|vaStart|vfprintf|vfscanf|vfwprintf6|vfwscanf|vprintf|vscanf|vsprintf
            |vsnprintf|vsscanf|vswprintf|vswscanf|vwprintf6|vwscanf|wcrtomb4|wcscat|wcschr|wcscmp|wcscoll4|wcscpy
            |wcscspn|wcsftime|wcslen|wcslocaleconv|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsptime|wcsrchr|wcsrtombs4
            |wcsspn|wcsstr|wcstod|wcstod32|wcstod64|wcstod128|wcstof|wcstok|wcstol|wcstold|wcstombs|wcstoul
            |wcsxfrm4|wctob|wctomb|wctrans|wctype4|wcwidth|wmemchr|wmemcmp|wmemcpy|wmemmove|wmemset|wprintf6
            |wscanf6|y0|y1|yn
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.kernel.protea
      - comment: Event handler functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            on(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
            Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
            Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|
            Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
            Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
            Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
            Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
            Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.event-handler.protea
      - comment: DOM functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
            appendChild|appendData|before|blur|canPlayType|captureStream|
            caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
            cloneContents|cloneNode|cloneRange|close|closest|collapse|
            compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
            convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
            createAttributeNS|createCaption|createCDATASection|createComment|
            createContextualFragment|createDocument|createDocumentFragment|
            createDocumentType|createElement|createElementNS|createEntityReference|
            createEvent|createExpression|createHTMLDocument|createNodeIterator|
            createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
            createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
            deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
            deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
            enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
            exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
            getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
            getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
            getClientRects|getContext|getDestinationInsertionPoints|getElementById|
            getElementsByClassName|getElementsByName|getElementsByTagName|
            getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
            getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
            hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
            insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
            insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
            isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
            lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
            moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
            parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
            previousSibling|probablySupportsContext|queryCommandEnabled|
            queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
            querySelector|querySelectorAll|registerContentHandler|registerElement|
            registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
            removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
            removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
            requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
            scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
            setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
            setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
            setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
            slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
            submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
            toDataURL|toggle|toString|values|write|writeln
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.dom.protea
      - comment: Bash and Batch built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt
            |bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil
            |change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher
            |clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert
            |copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd
            |dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf
            |diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd
            |dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal
            |eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract
            |fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|free|uniq|structdisk
            |fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate
            |graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig
            |ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd
            |ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manageBde|mapadmin|md
            |mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt
            |msg|msiexec|msinfo32|mstsc|nbtstat|net|netcfg|netdiag|netdom|netsh|netstat
            |nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt
            |ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin
            |pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershellIse
            |print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd
            |pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta
            |rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32
            |relog|ren|rename|rendom|repadmin|repairBde|replace|reset|rxec|risetup
            |rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks
            |scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn
            |setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|sshAdd|sshAgent
            |sshKeygen|sshKeyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo
            |takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title
            |tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp
            |tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier
            |verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where
            |whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy
            |alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown
            |echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill
            |let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source
            |suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait
            |alias|apropos|apt|aptGet|aptitude|aspell|at|awk|basename|base32|base64
            |bash|bc|bg|bind|break|builtin|bzip2|cal|caller|when|cat|cd|cfdisk|chattr
            |chgrp|chmod|chown|chpasswd|chroot|chkconfig|cksum|clear|cmp|comm|command
            |continue|cp|cpio|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|declare
            |df|diff|diff3|dig|dir|dircolors|dirname|dirs|dos2unix|dmesg|dpkg|du|echo
            |egrep|eject|enable|env|ethtool|eval|exec|exit|expect|expand|export|expr
            |false|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|for|format|free|uniq|struct|fsck|ftp
            |function|fuser|gawk|getopts|grep|groupadd|groupdel|groupmod|groups|gzip|hash
            |head|help|history|hostname|htop|iconv|id|if|ifconfig|ifdown|ifup|import|install
            |iostat|ip|jobs|join|kill|killall|less|let|link|ln|local|locate|logname|logout
            |look|lpc|lpr|lprint|lprintd|lprintq|lprm|lsattr|lsblk|ls|lsof|lspci|make|man
            |mapfile|mkdir|mkfifo|mkfile|mkisofs|mknod|mktemp|more|most|mount|mtools|mtr|mv
            |mmv|nc|netstat|nft|nice|nl|nohup|notifySend|nslookup|open|op|passwd|paste
            |pathchk|Perf|ping|pgrep|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd
            |quota|quotacheck|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice
            |remsync|return|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|select|seq|set|sftp
            |shift|shopt|shuf|shutdown|sleep|slocate|sort|source|split|ss|ssh|stat|strace
            |su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|tmux|touch|top
            |tput|traceroute|trap|tr|true|tsort|tty|type|ulimit|umask|umount|unalias|uname
            |unexpand|uniq|units|unix2dos|unrar|unset|unshar|until|uptime|useradd|userdel
            |usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|w|wait|watch|wc|whereis|which
            |while|who|whoami|wget|write|xargs|xdgOpen|xxd|xz|yes|zip
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.system.protea
      - comment: Bash and Batch built-in functions
        match: |
          (?x)
          (?<!\p{Pd}+\b|\B)(
            avg|checksumAgg|count|countBig|grouping|groupingId|max|min|sum|stdev|stdevp|var
            |varp|cumeDist|firstValue|lag|lastValue|lead|percentRank|percentileCont|percentileDisc
            |cast|convert|parse|tryCast|tryConvert|tryParse|cursorStatus|coalesce|nullif|choose
            |iif|sysdatetime|sysdatetimeoffset|sysutcdatetime|currentTime(?:stamp)?|getdate
            |getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts
            |datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts
            |datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate|cursorRows|connections
            |cpuBusy|datefirst|dbts|error|fetchStatus|identity|idle|ioBusy|langid|language
            |lockTimeout|maxConnections|maxPrecision|nestlevel|options|packetErrors|packReceived
            |packSent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks
            |totalErrors|totalRead|totalWrite|trancount|version|abs|acos|asin|atan|atn2|ceiling
            |cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square
            |tan|appName|applockMode|applockTest|assemblyproperty|colLength|colName|columnproperty
            |databasePrincipalId|databasepropertyex|dbId|dbName|fileId|fileIdex|fileName|filegroupId
            |filegroupName|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty
            |indexCol|indexkeyProperty|indexproperty|objectDefinition|objectId|objectName
            |objectSchemaName|objectproperty|objectpropertyex|originalDbName|parsename|schemaId|schemaName
            |scopeIdentity|serverproperty|statsDate|typeId|typeName|typeproperty|rank|denseRank|ntile
            |rowNumber|opendatasource|openrowset|openquery|openxml|certencoded|certprivatekey|currentUser
            |databasePrincipalId|hasPermsByName|isMember|isRolemember|isSrvrolemember|originalLogin|permissions
            |pwdcompare|pwdencrypt|schemaId|schemaName|sessionUser|suserId|suserSid|suserSname|systemUser
            |suserName|userId|userName|ascii|char|charindex|concat|difference|format|left|len|lower|ltrim
            |nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|stringAgg
            |stringEscape|stringSplit|stuff|substring|translate|trim|unicode|upper|patindex|textptr|textvalid
            |binaryChecksum|checksum|compress|connectionproperty|contextInfo|currentRequestId|currentTransactionId
            |decompress|errorLine|errorMessage|errorNumber|errorProcedure|errorSeverity|errorState|formatmessage
            |getFilestreamTransactionContext|getansinull|hostId|hostName|isnull|isnumeric|minActiveRowversion
            |newid|newsequentialid|rowcountBig|sessionContext|sessionId|exactState
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.database.protea
      - comment: predicate functions
        match: \s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+(?!\B|\p{Pd}+\b)\s*
        name: support.function.predicate.protea
      - comment: magic functions
        match: \s*\b\p{Pc}+([\p{Pc}\p{L}][\w\p{Pd}]*)+\p{Pc}+(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.protea

name: Protea
scopeName: source.dart
fileTypes: [dart, pta]
patterns: [include: "#core"]

information for contributors: |
  This is the grammar for the Protea programming language. The grammar
  is about 85% complete though there still need to be some fixes.

  Should any fix or improvements have to be made, or even some general
  constructive feedback, make a pull request or an issue on this repo,
  and I will be very happy to receive it/them.

comment: |
  To-do for the new grammar (circa 2022):
  - Fully support indentation-based syntax as the norm
  - Port all CSS properties as some of them do not highlight properly
  - Revamp numeric literals again
  - Add type-regex literals
  - Document and add uncaught parsing errors

  For the new Markdown syntax, add:
  - Links
  - Inline CSS
  - Selectors and anchors
  - Code blocks
  - Unordered and ordered lists
  - Blockquotes
  - Definition blocks
  - Tables
  - Headings and subheadings
  - Add null end tag syntax `<h1/sample text/` to JSX

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.pta}
    2: {name: punctuation.separator.decimal.period.pta}
    3: {name: punctuation.separator.decimal.fraction.pta}
    4: {name: constant.numeric.other.exponent.pta}
    5: {name: constant.numeric.other.density.pta}
    6: {name: storage.type.numeric.pta}

  class-name: &class-name |
    (?x)\s*\b
    (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|let|func?|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|elem|prop|mark
    |go|defer|do|from|where|with
    |if|elif|else|then|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass|fail
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    |ext|impl
    )(?!\B|\p{Pd}+\b)
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
    \b(?:# keywords
    in|of|as|is|new
    |to|til|thru|by|del
    |unset|ref|and|or|xor|not
    |var|let|func?|proc|type
    |class|data|enum|module
    |iter|macro|struct|object
    |trait|style|elem|prop|mark
    |go|defer|do|from|where|with
    |if|elif|else|then|def
    |for|each|loop|while
    |try|throw|catch|after
    |match|case|goto|pass|fail
    |break|next|redo|retry
    |return|yield|await|label
    |import|export|route
    |debug|assert|check
    )(?!\B|\p{Pd}+\b)
    )
    ([\p{Pc}\p{L}][\w\p{Pd}]*)
    \b

  html-tag-names: &html-tag-names
    - match: "[.:]"
      name: punctuation.separator.namespace.pta
    - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[:.])
      name: entity.name.tag.namespace.pta
    - match: \b((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)\b
      name: support.class.component.pta
    - include: "#html-tag-names"

repository:
  core:
    patterns:
      - include: "#ignore-long-lines"
      - include: "#brackets"
      - include: "#closures"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#comments"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#flag-specifier"
      - include: "#format-specifier"
      - include: "#symbol-strings"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  ignore-long-lines:
    comment: avoid parsing files with long lines of code
    match: ^.{1024,}$

  space:
    match: \s+
    name: meta.var.expr.pta

  embedded-content:
    patterns:
      - include: "#brackets"
      - include: "#closures"
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#symbol-strings"
      - include: "#symbols"
      - include: "#operators"
      - include: "#literals"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  # Function brackets (early here as not to break things)

  function-params:
    patterns:
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.optional.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.spread.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.name.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.reference.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.other.pta
      - match: |
          (?xi)\s*
          (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
          \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
          (?=$|\s*(?:[,;)}\]]|:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
        name: variable.parameter.pta

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))\s*
    captures:
      1: {name: punctuation.definition.parameters.pta}
    patterns: &function-params
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.as.pta
      - match: (?<=[\w\s][(|])\.
        name: punctuation.definition.metadata.pta
      - include: "#clauses"
      - include: "#constants"
      - include: "#declarations"
      - include: "#expression-keywords"
      - include: "#function-params"
      - include: $self

  # Illegal Syntax

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.number.pta
      - match: '[\w]+?'
        name: invalid.illegal.variable.pta
      - match: '[(){}\[\]]+?'
        name: invalid.illegal.missing-bracket.pta
      - match: '[\p{S}\p{P}&&[^,;''"`(){}\[\]\p{Pc}]]+'
        name: invalid.illegal.operator.pta
      - match: \S+?
        name: invalid.illegal.uncaught.pta

  illegal-keywords:
    match: |
      \s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|let|func?|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|elem|prop|mark
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass|fail
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?!\B|\p{Pd}+\b)\s*
    name: invalid.illegal.keyword.pta

  # Literals and Constants

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )(?!\B|\p{Pd}+\b)\s*
        captures:
          1: {name: constant.language.boolean.true.pta}
          2: {name: constant.language.boolean.false.pta}
          3: {name: constant.language.null.pta}
          4: {name: constant.language.undefined.pta}
          5: {name: constant.language.nan.pta}
          6: {name: constant.language.infinity.pta}
      - match: |
          (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(?:
          (it|this|that|self)#1
          |(args)#2
          |(ctor)#3
          |(prot)#4
          |(proto)#5
          )(?!\B|\p{Pd}+\b)\s*
        captures:
          1: {name: variable.language.$1.pta}
          2: {name: variable.language.arguments.pta}
          3: {name: variable.language.constructor.pta}
          4: {name: variable.language.prototype.pta}
          5: {name: variable.language.proto.pta}

  symbols:
    patterns:
      - match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*\b)*\s*
        name: entity.name.class.decorator.pta
      - match: \s*\B(:)(?=['"])
        name: punctuation.definition.symbol.pta
      - match: \s*\B(:)([\p{Pc}\p{L}][\w\p{Pd}]*\b)
        captures:
          1: {name: punctuation.definition.symbol.pta}
          2: {name: constant.other.symbol.pta}
      - applyEndPatternLast: 1
        begin: \s*\B(\\)(?=\$?\w)
        end: (?=[\p{Z}\p{P}\p{S}])|$
        name: string.unquoted.pta
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns: [include: "#string-content"]

  # Numbers

  numbers:
    patterns:
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)#radix
          (?:\d+(?:\p{Pc}*\d+)*)#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (r)(?:\d+(?:\p{Pc}*\d+)*))?|#rep
          (n)(?:\d+(?:\p{Pc}*\d+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)#radix
          (?:\d+(?:\p{Pc}*\d+)*)?#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (r)(?:\d+(?:\p{Pc}*\d+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0b)#radix
          (?:[01]+(?:\p{Pc}*[01]+)*)#int/numer
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:#frac
          (r)(?:[01]+(?:\p{Pc}*[01]+)*))?|#rep
          (n)(?:[01]+(?:\p{Pc}*[01]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.binary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0b)#radix
          (?:[01]+(?:\p{Pc}*[01]+)*)?#int/numer
          (?:
          (\.)(?:[01]+(?:\p{Pc}*[01]+)*)?(?:#frac
          (r)(?:[01]+(?:\p{Pc}*[01]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.binary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0q)#radix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)#int/numer
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:#frac
          (r)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?|#rep
          (n)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0q)#radix
          (?:[0-3]+(?:\p{Pc}*[0-3]+)*)?#int/numer
          (?:
          (\.)(?:[0-3]+(?:\p{Pc}*[0-3]+)*)?(?:#frac
          (r)(?:[0-3]+(?:\p{Pc}*[0-3]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0s)#radix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)#int/numer
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:#frac
          (r)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?|#rep
          (n)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.senary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0s)#radix
          (?:[0-5]+(?:\p{Pc}*[0-5]+)*)?#int/numer
          (?:
          (\.)(?:[0-5]+(?:\p{Pc}*[0-5]+)*)?(?:#frac
          (r)(?:[0-5]+(?:\p{Pc}*[0-5]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.senary.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0o)#radix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)#int/numer
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:#frac
          (r)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?|#rep
          (n)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.octal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0o)#radix
          (?:[0-7]+(?:\p{Pc}*[0-7]+)*)?#int/numer
          (?:
          (\.)(?:[0-7]+(?:\p{Pc}*[0-7]+)*)?(?:#frac
          (r)(?:[0-7]+(?:\p{Pc}*[0-7]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.octal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0z)#radix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)#int/numer
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:#frac
          (r)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?|#rep
          (n)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0z)#radix
          (?:[\dab]+(?:\p{Pc}*[\dab]+)*)?#int/numer
          (?:
          (\.)(?:[\dab]+(?:\p{Pc}*[\dab]+)*)?(?:#frac
          (r)(?:[\dab]+(?:\p{Pc}*[\dab]+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0x)#radix
          (?:\h+(?:\p{Pc}*\h+)*)#int/numer
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:#frac
          (r)(?:\h+(?:\p{Pc}*\h+)*))?|#rep
          (n)(?:\h+(?:\p{Pc}*\h+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (0x)#radix
          (?:\h+(?:\p{Pc}*\h+)*)?#int/numer
          (?:
          (\.)(?:\h+(?:\p{Pc}*\h+)*)?(?:#frac
          (r)(?:\h+(?:\p{Pc}*\h+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\\[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ()#radix
          (?:\d+(?:\p{Pc}*\d+)*)#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (r)(?:\d+(?:\p{Pc}*\d+)*))?|#rep
          (n)(?:\d+(?:\p{Pc}*\d+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          ()#radix
          (?:\d+(?:\p{Pc}*\d+)*)?#int/numer
          (?:
          (\.)(?:\d+(?:\p{Pc}*\d+)*)?(?:#frac
          (r)(?:\d+(?:\p{Pc}*\d+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))#radix
          (?:\w+(?:\p{Pc}*\w+)*)#int/numer
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:#frac
          (r)(?:\w+(?:\p{Pc}*\w+)*))?|#rep
          (n)(?:\w+(?:\p{Pc}*\w+)*)#denom
          )?
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}
      - match: |
          (?ix)\s*\b
          (\d+(?=\w+))#radix
          (?:\w+(?:\p{Pc}*\w+)*)?#int/numer
          (?:
          (\.)(?:\w+(?:\p{Pc}*\w+)*)?(?:#frac
          (r)(?:\w+(?:\p{Pc}*\w+)*))?#rep
          ()#denom
          )
          ((?:([pe])(?:0|[1-9]\d*))?([pe])[+-]?(?:0|[1-9]\d*))?#exp
          ((t[ds]?)[+-]?(?:0|[1-9]\d*))?#sf
          (\p{Pc}*[\p{Pc}\p{L}][\w\p{Pd}]*(?::[\p{Pc}\p{L}][\w\p{Pd}]*)*)?#type
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.pta}
          1: {name: storage.type.numeric.pta}
          2: {name: punctuation.separator.period.pta}
          3: {name: punctuation.separator.repeating.pta}
          4: {name: punctuation.separator.fraction.pta}
          5: {name: constant.numeric.other.exponent.pta}
          6: {name: punctuation.separator.radix.pta}
          7: {name: punctuation.separator.exponent.pta}
          8: {name: constant.numeric.other.precision.pta}
          9: {name: punctuation.separator.precision.pta}
          10: {name: keyword.other.unit.pta}

  symbol-strings:
    patterns:
      - comment: multi-single quoted string
        begin: (?<=^|\s)(:('''+))
        contentName: string.quoted.single.pta
        end: \s*((\2)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
      - comment: single quoted string
        begin: (?<=^|\s)(:('))
        contentName: string.quoted.single.pta
        end: \s*((\2)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
      - comment: multi-double quoted string
        begin: (?<=^|\s)(:("""+))
        contentName: string.quoted.double.pta
        end: \s*((\2)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"
      - comment: double quoted string
        begin: (?<=^|\s)(:("))
        contentName: string.quoted.double.pta
        end: \s*((\2)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"

  strings:
    patterns:
      - comment: multi-single quoted string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#embedded-raw"
      - comment: single quoted string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
          - include: "#embedded-raw"
      - comment: multi-double quoted string
        begin: (?<!"+)\s*("""+)
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-content"
      - comment: double quoted string
        begin: (?<!"+)\s*(")
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-content"

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  numeric-escapes:
    patterns:
      - comment: Binary escape sequences
        match: (?ix)\\b[01]+
        name: constant.character.escape.binary.pta
      - comment: Binary escape sequences
        begin: (?ix)\\b{
        end: \s*}
        name: constant.character.escape.binary.pta
        patterns:
          - match: \b[01]+\b
            name: constant.character.escape.binary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Quaternary escape sequences
        match: (?ix)\\q[0-3]+
        name: constant.character.escape.quaternary.pta
      - comment: Quaternary escape sequences
        begin: (?ix)\\q{
        end: \s*}
        name: constant.character.escape.quaternary.pta
        patterns:
          - match: \b[0-3]+\b
            name: constant.character.escape.quaternary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Senary escape sequences
        match: (?ix)\\s[0-5]+
        name: constant.character.escape.senary.pta
      - comment: Senary escape sequences
        begin: (?ix)\\s{
        end: \s*}
        name: constant.character.escape.senary.pta
        patterns:
          - match: \b[0-5]+\b
            name: constant.character.escape.senary.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Octal escape sequences
        match: (?ix)\\o[0-7]+
        name: constant.character.escape.octal.pta
      - comment: Octal escape sequences
        begin: (?ix)\\o{
        end: \s*}
        name: constant.character.escape.octal.pta
        patterns:
          - match: \b[0-7]+\b
            name: constant.character.escape.octal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Decimal escape sequences
        match: (?ix)\\d?\d+
        name: constant.character.escape.decimal.pta
      - comment: Decimal escape sequences
        begin: (?ix)\\d{
        end: \s*}
        name: constant.character.escape.decimal.pta
        patterns:
          - match: \b\d+\b
            name: constant.character.escape.decimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Duodecimal escape sequences
        match: (?ix)\\z[\dab]+
        name: constant.character.escape.duodecimal.pta
      - comment: Duodecimal escape sequences
        begin: (?ix)\\z{
        end: \s*}
        name: constant.character.escape.duodecimal.pta
        patterns:
          - match: \b[\dab]+\b
            name: constant.character.escape.duodecimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta
      - comment: Hexadecimal escape sequences
        match: (?ix)\\[ux]\h+
        name: constant.character.escape.hexadecimal.pta
      - comment: Hexadecimal escape sequences
        begin: (?ix)\\[ux]{
        end: \s*}
        name: constant.character.escape.hexadecimal.pta
        patterns:
          - match: \b\h+\b
            name: constant.character.escape.hexadecimal.pta
          - match: \w+
            name: invalid.illegal.unrecognized-string-escape.pta

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.pta
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.pta
        patterns: [include: "#latex-sublanguage"]
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.pta
      - match: (?i)\\[a-z]
        name: constant.character.escape.pta
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.pta
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.pta
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.pta

  embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.section.embedded.pta}
        patterns: [include: $self]
      - comment: Oniguruma supports only 20 levels of recursion
        applyEndPatternLast: 1
        begin: |
          (?x)(?<=^|[\w\s'"`])(\$)
          (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
        end: (?=)|$
        captures:
          1: {name: punctuation.section.embedded.pta}
        patterns:
          - include: "#calls"
          - include: "#variables"
          - include: "#brackets"
          - &embedded-primary-operators
            comment: Primary binary operators
            match: (?x)(?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
            captures:
              1: {name: keyword.operator.optional.pta}
              2: {name: keyword.operator.assert.pta}
              3: {name: keyword.operator.accessor.pta}

  flag-specifier:
    patterns:
      - comment: // for multiple flags at once with single-character aliases
        applyEndPatternLast: 1
        begin: (?x)(?<=^|[\w\s'"`])(//)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.pta}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: {name: keyword.other.flag.pta}
      - comment: / for a single flag, with optional arguments
        applyEndPatternLast: 1
        begin: (?x)(?<=^|[\w\s'"`])(/)\b
        end: (?=)|$
        captures:
          1: {name: punctuation.definition.flag.pta}
        patterns:
          - comment: Format switch without value
            match: ([\p{Pc}\p{L}][\w\p{Pd}]*)
            captures:
              1: {name: keyword.modifier.pta}

  format-specifier:
    comment: Oniguruma supports only 20 levels of recursion
    applyEndPatternLast: 1
    begin: (?x)(?<=^|[\w\s'"`])(%)\b
    end: (?=)|$
    captures:
      1: {name: punctuation.definition.directive.pta}
    patterns: [include: "#format-language"]

  embedded-placeholder:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.pta}
          2: {name: constant.numeric.decimal.pta}
      - match: (\#)((?:[*&%$]\??|\?)?[\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.definition.anchor.pta}
          2: {patterns: [include: "#placeholder-variables"]}
      - begin: (\#{)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.definition.anchor.pta}
        patterns:
          - include: "#function-params"
          - include: $self

  embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"
  embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.pta
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#embedded-expression"

  # Format Specifier Language

  format-language:
    comment: Grammar for Protea's format specifier language, inspired by MS-DOS, Bash and Python's f-strings.
    patterns:
      - comment: type specifier
        match: (?<=[^\\%]%|^%)\w+
        name: entity.other.attribute-name.pta
      - comment: Format switch with value /x:24
        applyEndPatternLast: 1
        begin: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(:)
        beginCaptures:
          1: {name: punctuation.separator.mapping.pta}
          2: {name: entity.other.attribute-name.class.pta}
          3: {name: punctuation.separator.key-value.pta}
        end: (?=)|$
        patterns:
          - include: "#calls"
          - include: "#variables"
          - include: "#brackets"
          - include: "#numbers"
          - &embedded-primary-operators
            comment: Primary binary operators
            match: (?x)(?<=[)}\]\w])(?:(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=[({\[\w])
            captures:
              1: {name: keyword.operator.optional.pta}
              2: {name: keyword.operator.assert.pta}
              3: {name: keyword.operator.accessor.pta}
      - comment: Format switch without value
        match: (?<!\\)(/)([\p{Pc}\p{L}][\w\p{Pd}]*)
        captures:
          1: {name: punctuation.separator.mapping.pta}
          2: {name: entity.other.attribute-name.id.pta}

  # Unicode Named Character Language

  latex-sublanguage:
    comment: Grammar for the Unicode Named Character Mini-Language.
    patterns:
      - include: "#embedded"
      - name: line.separator.math.pta
        match: (\\\\)$
        captures:
          1: {name: punctuation.line.separator.math.pta}
      - name: meta.function.math.pta
        begin: ((\\)([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*))(\{)
        beginCaptures:
          1: {name: storage.type.function.math.pta}
          2: {name: punctuation.definition.function.math.pta}
          3:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: entity.name.namespace.pta
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: entity.name.function.pta
              - match: \b\:\b
                name: punctuation.separator.namespace.pta
              - match: \b\.\b
                name: punctuation.accessor.pta
          4: {name: punctuation.definition.arguments.begin.math.pta}
        end: \}
        endCaptures:
          0: {name: punctuation.definition.arguments.end.math.pta}
        patterns:
          - include: "#latex-sublanguage"
      - match: (\\)\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
        captures:
          1: {name: punctuation.definition.constant.pta}
          2:
            patterns:
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=[.:])
                name: constant.other.character-class.pta
              - match: (?x)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
                name: constant.character.math.pta
              - match: \b\:\b
                name: punctuation.separator.namespace.pta
              - match: \b\.\b
                name: punctuation.accessor.pta
      - match: "[-+*/^]"
        name: punctuation.math.operator.latex
      - include: "#string-escapes"
      - include: "#literals"
      - include: source.yaml#flow-collection
      - match: '[^\\(){}\[\]]+?'
        name: string.unquoted.plain.in.pta

  # Regular expressions

  regexps:
    patterns:
      - comment: Replacement section
        begin: (?<=`+)\s*(```+|`)
        end: \s*(?:(\1)(?!`+))(\p{Alnum}*)
        contentName: string.replace.regexp.pta
        captures:
          1: {name: punctuation.section.regexp.end.pta}
          2: {name: keyword.other.flag.pta}
        patterns:
          - include: "#back-references"
          - include: "#string-content"
      - comment: Pattern section
        begin: \s*(\p{Alnum}*)(?<!`+)(```+|`)
        end: \s*(?:(\2)(?!`+))(\p{Alnum}*)
        contentName: string.pattern.regexp.pta
        beginCaptures:
          1: {name: keyword.modifier.pta}
          2: {name: punctuation.section.regexp.begin.pta}
        endCaptures:
          1: {name: punctuation.section.regexp.end.pta}
          2: {name: keyword.other.flag.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
  back-references:
    patterns:
      - match: \$(\d+[+-]?|[+-]\d*|&)
        name: keyword.other.back-reference.pta
      - begin: (\$<)\s*
        end: \s*(>)
        name: keyword.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: &regex-back-references
          - include: "#variables"
          - include: "#numbers"
          - include: "#operators"
          - include: "#string-content"
      - begin: (\$(['"]))\s*
        end: \s*(\2)
        name: keyword.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
  regexp-patterns:
    patterns:
      - match: \p{Z}+
        name: meta.space.pta
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings"
      - match: \|
        name: keyword.operator.or.pta
      - match: \&
        name: keyword.operator.compose.pta
      - match: \.
        name: constant.character.all.pta
      - match: \\[bB]({[\w\s]+})?
        name: keyword.control.anchor.pta
      - match: \$|\\[yYzZ]({[\w\s]+})?
        name: keyword.control.end.pta}
      - match: \^|\\[AmM]({[\w\s]+})?
        name: keyword.control.begin.pta
      - match: \\K
        name: keyword.control.keepout.pta
      - match: \\G
        name: keyword.control.search.pta
      - match: \\R
        name: constant.character.control.pta
      - match: \\[XO]
        name: constant.character.unicode.pta
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.pta}
          2: {name: keyword.operator.quantifier.lazy.pta}
          3: {name: keyword.operator.quantifier.eager.pta}
          4: {name: keyword.operator.quantifier.greedy.pta}
      - match: \\\d+
        name: keyword.other.back-reference.pta
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.pta
      - begin: (\\k<)
        end: \s*(>)
        name: constant.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
      - begin: (\\g<)
        end: \s*(>)
        name: constant.other.subroutine.pta
        captures:
          1: {name: keyword.other.subroutine.pta}
        patterns: *regex-back-references
      - begin: (\\k('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.back-reference.pta
        captures:
          1: {name: keyword.other.back-reference.pta}
        patterns: *regex-back-references
      - begin: (\\g('''+|"""+|['"]))
        end: \s*(\2)
        name: constant.other.subroutine.pta
        captures:
          1: {name: keyword.other.subroutine.pta}
        patterns: *regex-back-references
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.pta}
          2: {name: keyword.operator.modifier.eager.pta}
          3: {name: keyword.operator.modifier.greedy.pta}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.pta}
          2: {name: keyword.operator.quantifier.eager.pta}
          3: {name: keyword.operator.quantifier.greedy.pta}
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: \\.
        name: constant.character.escape.other.pta
  regexp-groups:
    patterns:
      - comment: Embedded expression
        begin: \(\??([*+])
        end: \s*(\))\s*
        name: constant.other.pcre.pta
        captures:
          0: {name: punctuation.section.expression.pta}
        patterns: [include: $self]
      - comment: Block comment
        begin: (\()(\?#)
        contentName: comment.block.regexp.pta
        end: \s*(\))\s*
        name: comment.block.regexp.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - match: \\.
            name: comment.block.regexp.pta
      - comment: Lookahead assertion
        begin: (\(\?=)
        end: \s*(\))\s*
        name: meta.group.look-ahead.pta
        captures:
          1: {name: punctuation.definition.group.look-ahead.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Lookbehind assertion
        begin: (\(\?<=)
        end: \s*(\))\s*
        name: meta.group.look-behind.pta
        captures:
          1: {name: punctuation.definition.group.look-behind.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookahead assertion
        begin: (\(\?!)
        end: \s*(\))\s*
        name: meta.group.negative-look-ahead.pta
        captures:
          1: {name: punctuation.definition.group.negative-look-ahead.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Negative lookbehind assertion
        begin: (\(\?<!)
        end: \s*(\))\s*
        name: meta.group.negative-look-behind.pta
        captures:
          1: {name: punctuation.definition.group.negative-look-behind.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Match directive Oniguruma supports only 20 levels of recursion
        begin: |
          (?x)(\(\?%)
          (
          (?<ident>\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (
          (?<sw>
          /\g<ident>
          (?<value>:
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?\B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          (\w+[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)*
          (?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
          )*
          )?
          )*
          )
          )
        captures:
          1: {name: punctuation.definition.directive.pta}
          2:
            name: storage.type.format.pta
            patterns:
              - include: "#format-language"
              - match: .+
                name: string.other.format.pta
        end: \s*(\))\s*
        name: meta.group.directive.pta
        patterns: [include: "#regexp-patterns"]
      - comment: Longest match
        begin: (\(\?/=?)
        end: \s*(\))\s*
        name: meta.group.longest.pta
        captures:
          1: {name: punctuation.definition.group.longest.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Flag modifier group
        begin: (\(\?\^?(?:([+-]?\d+?)|((?:[+-]\p{Lu}+)+|\p{Lu}+(?:[+-]\p{Lu}+)*)|((?:[+-]\p{Ll}+)+|\p{Ll}+(?:[+-]\p{Ll}+)*)))\s*(:)?
        end: \s*(\))\s*
        name: meta.group.flag.pta
        captures:
          0: {name: punctuation.definition.group.flag.pta}
          1: {name: punctuation.definition.group.flag.pta}
          2: {name: constant.numeric.index.pta}
          3: {name: keyword.control.recursion.pta}
          4: {name: keyword.other.flag.pta}
          5: {name: punctuation.separator.colon.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Callouts
        begin: (\(\?)(?={)
        end: \s*(\))\s*
        name: meta.group.call-out.pta
        captures:
          1: {name: punctuation.definition.group.call-out.pta}
        patterns:
          - begin: (?<=\(\?)({)
            end: \s*(\})\s*([<*>])?(?:(\[)(.*?)(\]))?
            name: punctuation.definition.group.call-out.pta
            captures:
              1: {name: punctuation.definition.group.call-out.pta}
              2: {name: keyword.operator.range.pta}
              3: {name: punctuation.definition.tag.pta}
              4: {patterns: [include: "#function-names"]}
              5: {name: punctuation.definition.tag.pta}
            patterns: [include: $self]
          - include: "#regexp-patterns"
      - comment: Atomic groups
        begin: (\(\?>)
        end: \s*(\))\s*
        name: meta.group.atomic.pta
        captures:
          1: {name: punctuation.definition.group.atomic.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Non-capturing groups
        begin: (\(\?:)
        end: \s*(\))\s*
        name: meta.group.non-capturing.pta
        captures:
          1: {name: punctuation.definition.group.non-capturing.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Branch groups
        begin: (\(\?)(?=[(|])
        end: \s*(\))\s*
        name: meta.group.branch.pta
        captures:
          1: {name: punctuation.definition.group.branch.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Atomic groups
        begin: (\(\?~)
        end: \s*(\))\s*
        name: meta.group.absent.pta
        captures:
          1: {name: punctuation.definition.group.absent.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Back-reference groups
        begin: \((\?&(?:([+-]?\d+)|([\p{Pc}\p{L}][\w\p{Pd}]*)))(:)?
        end: \s*\)
        name: meta.group.back-reference.pta
        captures:
          0: {name: punctuation.definition.group.back-reference.pta}
          1: {name: punctuation.definition.group.back-reference.pta}
          2: {name: constant.numeric.index.pta}
          3: {patterns: [include: "#variables"]}
          4: {name: punctuation.separator.colon.pta}
        patterns: [include: "#regexp-patterns"]
      - comment: Named groups (angle-brackets)
        begin: \(\?(?=<(?![!=]))
        end: \s*(\))\s*
        name: meta.group.named.pta
        captures:
          0: {name: punctuation.definition.group.named.pta}
        patterns:
          - begin: (?<=\(\?)(<)
            end: \s*(>)
            name: constant.other.group.pta
            captures:
              1: {name: punctuation.definition.group.named.pta}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Named groups (single or double-quotes)
        begin: \(\?(?=['"])
        end: \s*(\))\s*
        name: meta.group.named.pta
        captures:
          0: {name: punctuation.definition.group.named.pta}
        patterns:
          - begin: (?<=\(\?)('''+|"""+|['"])
            end: \s*(\1)
            name: constant.other.group.pta
            captures:
              1: {name: punctuation.definition.group.named.pta}
            patterns: *regex-back-references
          - include: "#regexp-patterns"
      - comment: Unnamed groups
        begin: (\()
        end: (\s*\))
        name: meta.group.pta
        captures:
          1: {name: punctuation.definition.group.pta}
        patterns: [include: "#regexp-patterns"]
  regexp-char-class:
    patterns:
      - include: "#embedded"
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.pta
      - begin: (?i)\\p{
        end: \s*}
        name: constant.other.character-class.unicode.pta
        patterns:
          - include: "#attribute-selectors"
      - begin: \\j{
        end: \s*}
        name: constant.character.entity.named.pta
        patterns: [include: "#latex-sublanguage"]
      - include: "#numeric-escapes"
      - match: (?i)\\([cm][a-z])
        name: constant.character.control.pta
      - match: (?i)\\p(\w\w?)
        name: constant.other.character-class.unicode.pta
      - match: (?i)\\[ci]({\w+})?
        name: constant.other.character-class.xml.pta
      - match: (?x)\\[a-z]
        name: constant.other.character-class.pta
      - match: (?x)\\[A-Z]
        name: constant.other.character-class.negated.pta
      - match: (?i)\\n{[\w\s\p{Pd}]+}
        name: constant.character.escape.unicode.name.pta
      - match: (?i)\\[\p{L}\p{N}]
        name: constant.character.escape.pta
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.pta
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.pta
      - match: (?x)\\\p{C}
        name: invalid.illegal.unknown-escape.pta
  regexp-char-ops:
    patterns:
      - match: (?<!\|)\|\|(?!\|)
        name: keyword.operator.union.pta
      - match: (?<!&)&&(?!&)
        name: keyword.operator.intersection.pta
      - match: (?<!\^)\^\^(?!\^)
        name: keyword.operator.symmetric.pta
      - match: (?<!~)~~(?!~)
        name: keyword.operator.negation.pta
      - match: (?<!-)--(?!-)
        name: keyword.operator.difference.pta
      - match: (?<![^\\][\\\[])-(?![-\[\]])
        name: keyword.operator.range.pta
      - match: ([^-\\\[\]]|\\.)(?<!-+)(?=(?<!\\)-)
        name: constant.other.character-class.range.from.pta
      - match: (?<=[^\\]-)(?!-+)([^-\\\[\]]|\\.)
        name: constant.other.character-class.range.to.pta
      - match: \\.
        name: constant.character.escape.other.pta
  regexp-char-set:
    patterns:
      - begin: (\[[:])
        end: (\])
        name: constant.other.character-class.posix.pta
        captures:
          1: {name: punctuation.definition.character-class.posix.pta}
        patterns: [include: "#attribute-selectors"]
      - begin: (\[[!^])
        end: (\])
        name: constant.other.character-class.negated.pta
        captures:
          1: {name: punctuation.definition.character-class.negated.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"
      - begin: (\[)
        end: (\])
        name: constant.other.character-class.pta
        captures:
          1: {name: punctuation.definition.character-class.pta}
        patterns:
          - include: "#comments"
          - include: "#regexp-char-class"
          - include: "#regexp-char-ops"
          - include: "#regexp-char-set"

  attribute-selectors:
    patterns:
      - match: ","
        name: punctuation.separator.sequence.pta
      - include: "#comments"
      - include: "#strings"
      - match: (?xi)\b[is]\b(?=[)}\]]|&&|\|\||\^\^)
        name: storage.modifier.ignore-when.pta
      - include: "#string-escapes"
      - match: "[:!=</>.^$%?*+|&~]?="
        name: keyword.operator.pattern.pta
      - match: ([&|^])\1|!
        name: keyword.operator.logical.pta
      - match: \b(i[ns])\b
        name: keyword.operator.expression.$1.pta
      - begin: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b([:!=</>.^$%?*+|&~]?=)
        beginCaptures:
          1: {name: entity.other.attribute-name.pta}
          2: {name: keyword.operator.pattern.pta}
        end: (?=&&|\|\||\^\^|[\s,:;'"`(){}\[\]])
        name: string.unquoted.attribute-name.pta
        patterns: [include: "#html-properties"]
      - comment: Attribute names
        match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
        captures:
          1: {name: entity.other.attribute-name.pta}
          2: {name: keyword.operator.pattern.pta}
      - include: "#operators"

  # Markdown

  inline-markdown:
    patterns:
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#bold"
      - include: "#italic"
      - include: "#raw"
      - include: "#escape"
      - include: "#image-inline"
      - include: "#image-ref"
      - include: "#link-email"
      - include: "#link-inet"
      - include: "#link-inline"
      - include: "#link-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref-shortcut"
  ampersand:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: "&(?!([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+);)"
    name: meta.other.valid-ampersand.markdown
  bold:
    begin: |
      (?x) (?<open>(\*\*(?=\w)|(?<!\w)\*\*|(?<!\w)\b__))(?=\S) (?=
      (
      <[^>]*+> # HTML tags
      | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
      # Raw
      | \\[\\`*_{}\[\]()#.!+\->]?+ # Escapes
      | \[
      (
      (?<square> # Named group
      [^\[\]\\] # Match most chars
      | \\. # Escaped chars
      | \[ \g<square>*+ \] # Nested brackets
      )*+
      \]
      (
      ( # Reference Link
      [ ]? # Optional space
      \[[^\]]*+\] # Ref name
      )
      | ( # Inline Link
      \( # Opening paren
      [ \t]*+ # Optional whitespace
      <?(.*?)>? # URL
      [ \t]*+ # Optional whitespace
      ( # Optional Title
      (?<title>['"])
      (.*?)
      \k<title>
      )?
      \)
      )
      )
      )
      | (?!(?<=\S)\k<open>). # Everything besides
      # style closer
      )++
      (?<=\S)(?=__\b|\*\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.bold.markdown}
    end: (?<=\S)(\1)
    name: markup.bold.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#italic"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  bracket:
    comment: Markdown will convert this for us. We match it so that the HTML grammar will not mark it up as invalid.
    match: <(?![a-zA-Z/?\$!])
    name: meta.other.valid-bracket.markdown

  escape:
    match: \\[-`*_#+.!(){}\[\]\\>]
    name: constant.character.escape.markdown

  image-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.image.markdown}
      8: {name: punctuation.definition.link.markdown}
      9: {name: string.other.link.description.title.markdown}
      10: {name: punctuation.definition.string.markdown}
      11: {name: punctuation.definition.string.markdown}
      12: {name: string.other.link.description.title.markdown}
      13: {name: punctuation.definition.string.markdown}
      14: {name: punctuation.definition.string.markdown}
      15: {name: string.other.link.description.title.markdown}
      16: {name: punctuation.definition.string.markdown}
      17: {name: punctuation.definition.string.markdown}
      18: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
      (<?)(\S+?)(>?) # The url
      [ \t]* # Optional whitespace
      (?:
      ((\().+?(\))) # Match title in parens…
      | ((").+?(")) # or in double quotes…
      | ((').+?(')) # or in single quotes.
      )? # Title is optional
      \s* # Optional whitespace
      (\))
    name: meta.image.inline.markdown

  image-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.description.markdown}
      4: {name: punctuation.definition.string.begin.markdown}
      5: {name: punctuation.definition.constant.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.markdown}
    match: (\!\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(.*?)(\])
    name: meta.image.reference.markdown
    patterns: [include: "#string-content"]

  italic:
    begin: |
      (?x) (?<open>(\*(?=\w)|(?<!\w)\*|(?<!\w)\b_))(?=\S) # Open
      (?=
      (
      <[^>]*+> # HTML tags
      | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*+\k<raw>
      # Raw
      | \\[\\`*_{}\[\]()#.!+\->]?+ # Escapes
      | \[
      (
      (?<square> # Named group
      [^\[\]\\] # Match most chars
      | \\. # Escaped chars
      | \[ \g<square>*+ \] # Nested brackets
      )*+
      \]
      (
      ( # Reference Link
      [ ]? # Optional space
      \[[^\]]*+\] # Ref name
      )
      | ( # Inline Link
      \( # Opening paren
      [ \t]*+ # Optional whtiespace
      <?(.*?)>? # URL
      [ \t]*+ # Optional whtiespace
      ( # Optional Title
      (?<title>['"])
      (.*?)
      \k<title>
      )?
      \)
      )
      )
      )
      | \k<open>\k<open> # Must be bold closer
      | (?!(?<=\S)\k<open>). # Everything besides
      # style closer
      )++
      (?<=\S)(?=_\b|\*)\k<open> # Close
      )
    captures:
      1: {name: punctuation.definition.italic.markdown}
    end: (?<=\S)(\1)((?!\1)|(?=\1\1))
    name: markup.italic.markdown
    patterns:
      - include: "#string-content"
      - include: "#escape"
      - include: "#ampersand"
      - include: "#bracket"
      - include: "#raw"
      - include: "#bold"
      - include: "#image-inline"
      - include: "#link-inline"
      - include: "#link-inet"
      - include: "#link-email"
      - include: "#image-ref"
      - include: "#link-ref-literal"
      - include: "#link-ref"
      - include: "#link-ref-shortcut"

  link-email:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      4: {name: punctuation.definition.link.markdown}
    match: (<)((?:mailto:)?[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*)(>)
    name: meta.link.email.lt-gt.markdown
    patterns: [include: "#string-content"]

  link-inet:
    captures:
      1: {name: punctuation.definition.link.markdown}
      2: {name: markup.underline.link.markdown}
      3: {name: punctuation.definition.link.markdown}
    match: (<)((?:https?|ftp)://.*?)(>)
    name: meta.link.inet.markdown
    patterns: [include: "#string-content"]

  link-inline:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.metadata.markdown}
      6: {name: punctuation.definition.link.markdown}
      7: {name: markup.underline.link.markdown}
      9: {name: punctuation.definition.link.markdown}
      10: {name: string.other.link.description.title.markdown}
      11: {name: punctuation.definition.string.begin.markdown}
      12: {name: punctuation.definition.string.end.markdown}
      13: {name: string.other.link.description.title.markdown}
      14: {name: punctuation.definition.string.begin.markdown}
      15: {name: punctuation.definition.string.end.markdown}
      16: {name: string.other.link.description.title.markdown}
      17: {name: punctuation.definition.string.begin.markdown}
      18: {name: punctuation.definition.string.end.markdown}
      19: {name: punctuation.definition.metadata.markdown}
    match: |
      (?x)
      (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])
      # Match the link text.
      (\() # Opening paren for url
      (<?)((?<url>(?>[^\s()]+)|\(\g<url>*\))*)(>?) # The url
      [ \t]* # Optional whitespace
      (?:
      ((\().+?(\))) # Match title in parens…
      | ((").+?(")) # or in double quotes…
      | ((').+?(')) # or in single quotes.
      )? # Title is optional
      \s* # Optional whitespace
      (\))
    name: meta.link.inline.markdown
    patterns: [include: "#string-content"]

  link-ref:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: constant.other.reference.link.markdown}
      7: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])(\[)([^\]]*+)(\])
    name: meta.link.reference.markdown
    patterns: [include: "#string-content"]

  link-ref-literal:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      4: {name: punctuation.definition.string.end.markdown}
      5: {name: punctuation.definition.constant.begin.markdown}
      6: {name: punctuation.definition.constant.end.markdown}
    match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*+\])*+)(\])[ ]?(\[)(\])
    name: meta.link.reference.literal.markdown
    patterns: [include: "#string-content"]

  link-ref-shortcut:
    captures:
      1: {name: punctuation.definition.string.begin.markdown}
      2: {name: string.other.link.title.markdown}
      3: {name: punctuation.definition.string.end.markdown}
    match: (\[)(\S+?)(\])
    name: meta.link.reference.markdown
    patterns: [include: "#string-content"]

  raw:
    captures:
      1: {name: punctuation.definition.raw.markdown}
      2: {patterns: [include: "#string-content"]}
      3: {name: punctuation.definition.raw.markdown}
    match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*+(\1)
    name: markup.inline.raw.string.markdown
    patterns: [include: "#string-content"]

  markdown:
    patterns:
      - include: "#comments"
      - include: "#jsx-entities"
      - include: "#html-tag"
      - include: "#string-content"
      - include: "#evaluated-code"
      - include: "#executed-code"
      - include: "#inline-styles"
      - include: "#blockquote"
      - include: "#unordered-list"
      - include: "#ordered-list"
      - include: "#inline-markdown"
    repository:
      blockquote:
        comment: "> blockquote"
        begin: ^\s*(\>)(\s+.*\n?)
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.quote.begin.markdown.pta}
          2:
            name: markup.quote.markdown.pta
            patterns: [include: "#markdown"]
        name: markup.quote.markdown.pta
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.quote.markdown.pta
            patterns: [include: "#markdown"]
      unordered-list:
        comment: "- unordered list"
        begin: ^\s*(\-)(?!>)\s+(.*\n?)
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown.pta}
          2:
            name: markup.list.unnumbered.markdown.pta
            patterns: [include: "#markdown"]
        name: markup.list.unnumbered.markdown.pta
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.unnumbered.markdown.pta
            patterns: [include: "#markdown"]
      ordered-list:
        comment: "+ ordered list"
        begin: ^\s*(\+)(?!>)\s+(.*\n?)
        end: ^(?=\S)|(?!\G)
        beginCaptures:
          1: {name: punctuation.definition.list.begin.markdown.pta}
          2:
            name: markup.list.numbered.markdown.pta
            patterns: [include: "#markdown"]
        name: markup.list.numbered.markdown.pta
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: markup.list.numbered.markdown.pta
            patterns: [include: "#markdown"]
      evaluated-code:
        applyEndPatternLast: 1
        comment: Evaluated code
        begin: (?<=^|[\w\s'"`])(=>)
        end: (?=|$)
        captures:
          1: {name: storage.type.method.pta}
        patterns: [include: $self]
      executed-code:
        applyEndPatternLast: 1
        comment: Executed code
        begin: (?<=^|[\w\s'"`])(->)
        end: (?=|$)
        captures:
          1: {name: storage.type.subroutine.pta}
        patterns: [include: $self]
      html-tag:
        comment: <Tags
        applyEndPatternLast: 1
        begin: (?<=^|[\w\s'"`])(<)\b
        end: (<?>?=?)|(?=)|$
        name: meta.tag.pta
        captures:
          1: {name: punctuation.definition.tag.pta}
        patterns:
          - comment: Tag name
            match: (?<=<)\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b
            captures:
              1: {name: entity.name.tag.pta, patterns: *html-tag-names}
          - comment: ID
            match: (?<=#)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.id.pta
          - comment: Class
            match: (?<=\.)\b([\p{Pc}\p{L}][\w\p{Pd}]*)\b
            name: entity.other.attribute-name.class.pta
          - begin: (\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.directive.pta}
            patterns: [include: $self]
          - begin: (\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.pta}
            patterns:
              - include: "#style-properties"
              - include: $self
          - begin: (\()\s*
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.parameters.pta}
            patterns:
              - include: "#tag-attributes"
              - include: $self
          - match: \s*([.#])(?=[\w$])
            name: punctuation.definition.entity.pta
          - comment: inline markup
            begin: (?<!'+)\s*('''+|')
            contentName: string.quoted.single.pta
            end: \s*((\1)(?!'+))
            captures:
              1: {name: punctuation.definition.string.pta}
            patterns: [include: "#markdown"]
          - comment: inline markup
            begin: (?<!"+)\s*("""+|")
            contentName: string.quoted.double.pta
            end: \s*((\1)(?!"+))
            captures:
              1: {name: punctuation.definition.string.pta}
            patterns: [include: "#markdown"]
          - include: "#regexps"
      inline-styles:
        begin: (?<=^|[\w\s'"`])(\+>)(.*\n?)
        beginCaptures:
          1: {name: storage.type.style.pta}
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.pta}
              - include: "#comments"
              - include: "#style-pair"
              - include: "#style-rules"
              - include: "#block-entities"
              - match: *entity-name
                name: entity.name.style.pta
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: "#style-properties"]

  # Special code blocks

  html-properties:
    patterns:
      - include: source.yaml#flow-sequence
      - include: "#brackets"
      - include: "#literals"
      - include: "#css-value-names"
      - include: source.css.scss#constant_functions
      - include: source.css.scss#constant_sass_functions
      - include: source.css.scss#constant_important
      - include: source.css.scss#constant_default
      - include: source.css.scss#constant_optional
      - include: "#tag-names"
      - include: "#embedded"
  tag-names:
    match: \s*\b([\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*)\b\s*
    name: entity.name.tag.pta
    captures:
      1:
        name: entity.name.tag.pta
        patterns: *html-tag-names
  style-pair:
    applyEndPatternLast: 1
    begin: |
      (?x)
      \s*
      (
      [\p{Pd}$]?
      (?:
      # Recursive brackets
      \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
      (?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      \B(?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
      (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Rest of identifier characters
      \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
      )+
      )
      (:)\s+
    beginCaptures:
      1:
        name: support.type.property-name.pta
        patterns: &embedded-brackets
          - include: "#css-property-names"
          - include: "#embedded"
          - include: "#brackets"
      8: {name: punctuation.separator.key-value.pta}
    end: (?=)|$
    name: string.unquoted.pta
    patterns:
      - include: "#html-properties"
      - match: \s+
        name: meta.var.expr.pta
  style-properties:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#style-pair"
      - include: "#style-rules"
      - include: $self
  style-rules:
    patterns:
      - include: "#calls"
      - comment: CSS operators
        match: (?x)\s*(?:(\+)|(\-)|(\*)|(\/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))\s*
        captures:
          1: {name: keyword.operator.sum.pta}
          2: {name: keyword.operator.difference.pta}
          3: {name: keyword.operator.product.pta}
          4: {name: keyword.operator.quotient.pta}
          5: {name: keyword.operator.remainder.pta}
          6: {name: keyword.operator.only.pta}
          7: {name: keyword.operator.maybe.pta}
          8: {name: keyword.operator.intersection.pta}
          9: {name: keyword.operator.union.pta}
          10: {name: keyword.operator.symmetric.pta}
          11: {name: keyword.operator.negation.pta}
          12: {name: keyword.operator.macro.dollar.pta}
          13: {name: keyword.operator.private.pta}
          14: {name: keyword.operator.class.pta}
      - begin: \s*(\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.pta
          - include: "#clauses"
          - include: "#constants"
          - include: "#declarations"
          - include: "#expression-keywords"
          - include: "#style-pair"
          - include: "#function-params"
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.selector.pta}
        patterns:
          - include: "#attribute-selectors"
          - include: $self
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.pta
      - include: "#style-selectors"
      - include: "#format-language"
      - include: "#tag-names"
  style-selectors:
    patterns:
      - match: \s*(\@|\#|\&|\*|\.|\:|::)(?=[\w$])
        name: punctuation.definition.entity.pta
      - match: |
          (?x)
          \s*(?<=[^*]\*)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.name.type.alias.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^&]\&)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.name.type.anchor.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^@]\@)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: keyword.control.at-rule.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^\#]\#)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.id.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^.]\.)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.class.pta
            patterns: *embedded-brackets
      - match: |
          (?x)
          \s*(?<=[^:]::?)
          (
          [\p{Pd}$]?
          (?:
          # Recursive brackets
          \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
          (?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          \B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )+
          )\s*
        captures:
          1:
            name: entity.other.attribute-name.pseudo-component.pta
            patterns: *embedded-brackets

  # JSX

  jsx:
    applyEndPatternLast: 1
    comment: Only after opening brackets, commas, semicolons, keywords, and operators. In addition, < > starts a JSX fragment.
    begin: |
      (?x)
      (?<=
      (?:
      (?:^|[,;]|\#?[({\[])\s*|
      \b[\p{Pc}\p{L}][\w\p{Pd}]*\b|
      (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+
      )\s*
      )
      (?=<[\p{Pc}\p{L}]|<\s+>)
    end: (?=)|$
    patterns: [include: "#tag-component-name"]
  tag-component-name:
    patterns:
      - comment: JSX Fragment
        contentName: invalid.illegal.invalid-prop.pta
        begin: \s*(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.pta}
        endCaptures:
          1: {name: punctuation.definition.tag.pta}
        patterns:
          - include: "#tag-termination"
      - comment: Tags that end > are trapped in tag-termination
        contentName: invalid.illegal.invalid-prop.pta
        begin: |
          (?x)\s*+(<)#start tag begin
          (\b[\p{Pc}\p{L}][\w\p{Pd}]*(?:[:.][\p{Pc}\p{L}][\w\p{Pd}]*)*\b)#tag name
          (?=[\/>\s])(?![:])(?<!\.|:)
        end: \s*(?:(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>)
        beginCaptures:
          1: {name: punctuation.definition.tag.pta}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.pta}
          3: {name: punctuation.definition.tag.pta}
          4: {name: invalid.illegal.termination.pta}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"
  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: string.unquoted.html.pta
    name: string.unquoted.html.pta
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.pta}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-component-name"
      - include: "#string-content"
      - include: text.html.markdown#inline
  tag-attributes:
    patterns:
      - include: "#comma"
      - include: "#semicolon"
      - applyEndPatternLast: 1
        begin: \s*(=)\s*
        beginCaptures:
          1: {name: punctuation.separator.key-value.pta}
        end: (?=)|$
        name: string.unquoted.pta
        patterns:
          - include: "#html-properties"
          - match: \s+
            name: meta.space.pta
      - include: "#style-selectors"
      - include: "#attributes"
      - include: "#comments"
  attributes:
    match: |
      (?x)
      \s*
      (
      [\p{Pd}$]?
      (?:
      # Recursive brackets
      \$\{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}|
      (?<b>
      \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
      \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
      \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
      )|
      \B(?<s>
      # Strings
      (?<q3>'''+|"""+|```+).*\g<q3>|
      (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
      (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
      (?<q1>')(?:[^']|'')*\g<q1>
      )|
      # Rest of identifier characters
      \$?[\p{Pc}\p{L}][\p{Pd}\w]*\b
      )+
      )\s*
    captures:
      1:
        name: entity.other.attribute-name.${1:/downcase}.pta
        patterns:
          - include: "#css-property-names"
          - include: "#embedded"
          - include: "#brackets"
    name: string.unquoted.pta
  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.pta
  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.pta}
          2: {name: punctuation.definition.entity.pta}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.pta
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.pta
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.pta
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.pta
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.pta
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.pta
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.pta
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.pta
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.pta
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.pta

  # Comments

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"
      - include: "#nested-comments"
  block-comments:
    patterns:
      - begin: \s*(#\+)(?=\s+|\s*$)
        end: \s*(\+#)
        name: comment.block.documentation.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-jsdoc"
      - begin: \s*(#=)(?=\s+|\s*$)
        end: \s*(=#)
        name: comment.block.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"
  line-comments:
    patterns:
      - begin: \s*(#:)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.documentation.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*(#)(?=\s+|\s*$)
        end: \s*$
        name: comment.line.number-sign.pta
        captures:
          1: {name: punctuation.definition.comment.pta}
        patterns:
          - include: text.html.markdown#inline
  nested-jsdoc:
    begin: (#\+)(?=\s+|\s*$)
    end: \s*(\+#)
    name: comment.block.documentation.nested.pta
    captures:
      1: {name: punctuation.definition.comment.pta}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-jsdoc"
  nested-block:
    begin: (#=)(?=\s+|\s*$)
    end: \s*(=#)
    name: comment.block.nested.pta
    captures:
      1: {name: punctuation.definition.comment.pta}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"
  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|object|template|uses|xtype)\b
        name: storage.type.class.jsdoc
  jsdoc-access:
    comment: "@tag protected...."
    match: (@(access))\s*(private|protected|public)?(?=\s|$)
    captures:
      1: {name: storage.type.class.jsdoc}
      3: {name: storage.modifier.jsdoc}
  jsdoc-module:
    comment: "@tag {optional type} module:file"
    begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
    end: ^|(?=\*/)|(?=\5$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - match: (?:(module)(:))?(((?!\*/)\S)+)
        captures:
          1: {name: keyword.module.jsdoc}
          2: {name: punctuation.jsdoc}
          3: {name: string.modulename.jsdoc}
  jsdoc-as-name-path:
    comment: to terminate the block
    begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
    end: ^|(?=\*/)|(?=\3$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-name-path-scopes"
  jsdoc-simple:
    comment: "@tag"
    match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
    captures:
      1: {name: storage.type.class.jsdoc}
  jsdoc-simple-name-path:
    comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
    begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-path-scopes"
  jsdoc-type-name:
    comment: "@tag {optional type} name"
    begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
    end: ^|(?=\*/)|(?=\7$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
      - include: "#jsdoc-name-scopes"
  jsdoc-type-no-name:
    comment: "@tag {types}"
    begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
    end: ^|(?=\*/)|(?=\4$)
    beginCaptures:
      1: {name: storage.type.class.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-scopes"
  jsdoc-inline-tags:
    name: meta.tag.inline.jsdoc
    begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
    end: \s*(})
    beginCaptures:
      1: {name: string.linktext.jsdoc}
      2: {name: meta.brace.curly.jsdoc}
    endCaptures:
      1: {name: meta.brace.curly.jsdoc}
    patterns:
      - match: (@(link|tutorial))\b([^}]*)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: string.jsdoc}
  jsdoc-typedef-scopes:
    name: entity.name.type.instance.jsdoc
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-typedef-primitives:
    match: \b(null|undefined|boolean|string|number)\b
    captures:
      1: {name: support.type.builtin.primitive.jsdoc}
  jsdoc-typedef-obj:
    comment: typedef object
    begin: "{"
    end: "}|^"
    captures:
      0: {name: meta.brace.curly.jsdoc}
    patterns:
      - include: "#jsdoc-typedef-primitives"
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\s*(:)
        captures:
          1: {name: variable.other.readwrite.jsdoc}
      - include: "#jsdoc-name-path-scopes"
      - include: "#jsdoc-typedef-obj"
  jsdoc-name-scopes:
    patterns:
      - match: ((?!\*/)[\S&&[^\[\]"']])+
        captures:
          0: {name: variable.other.jsdoc}
      - name: variable.other.jsdoc
        begin: \[
        end: \]|^
        patterns:
          - include: "#jsdoc-string"
          - include: "#jsdoc-name-scopes"
  jsdoc-name-path-scopes:
    patterns:
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*(?=[\p{Pc}\p{L}])
        captures:
          1: {name: keyword.as.jsdoc}
      - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}][\w\p{Pd}]*))(?=[\s\-~.#]|$)
        captures:
          1: {name: entity.name.class.jsdoc}
          2: {name: entity.name.function.jsdoc}
      - match: (\.)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.static.jsdoc}
      - match: (\#)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.instance.jsdoc}
      - match: (~|-)([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\s|$|\")
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: entity.name.function.method.inner.jsdoc}
      - match: (\#)(event)(:)
        captures:
          1: {name: keyword.operator.accessor.jsdoc}
          2: {name: keyword.event.jsdoc}
          3: {name: keyword.operator.jsdoc}
      - name: string.method.jsdoc
        begin: \.(?="|')
        end: (?=.)
        applyEndPatternLast: 1
        patterns:
          - include: "#jsdoc-string"
  jsdoc-string:
    name: string.jsdoc
    match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  # Function and method calls

  calls:
    patterns:
      - comment: |
          Function calls (with spacing)
        match: |
          (?x)\s*
          (?<=
          ^|[,;(){}\[\]]|['"`(){}\[\]](?:[?!]?\.|[?!:]:=?)|
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+\s+|
          //?[\p{Pc}\p{L}][\w\p{Pd}]*|
          @\b[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\b|
          (?:
          (?:^|[,;'"`(){}\[\]\s])\b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )\b(?:[,;'"`(){}\[\]\s]|$)
          )
          )
          \s*\b
          (
          (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:[?!]?\.|[?!:]:=?)[\p{Pc}\p{L}][\w\p{Pd}]*)*
          )
          \b\s+
          (?=
          (?:\\|//?)\b|<\|{1,3}\s+|<\+\s+
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          (
          (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          \w+
          )
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+['"`({\[]
          )
        captures:
          1: {patterns: [include: "#function-names"]}
      - comment: |
          Function calls (optional spacing)
        match: |
          (?x)\s*
          (?<=
          ^|[,;(){}\[\]]|['"`(){}\[\]](?:[?!]?\.|[?!:]:=?)|
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+\s+|
          //?[\p{Pc}\p{L}][\w\p{Pd}]*|
          @\b[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\b|
          (?:
          (?:^|[,;'"`(){}\[\]\s])\b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )\b(?:[,;'"`(){}\[\]\s]|$)
          )
          )
          \s*\b
          (
          (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:[?!]?\.|[?!:]:=?)[\p{Pc}\p{L}][\w\p{Pd}]*)*
          )
          \b
          (?=
          \s+['"\\({\[]|\b!(?:\s|$)|
          (?:[!?]\.=?|\.=)?\#?\(|
          (?:[!?]\.=?|\.=)?<(?:['"`\\({\[\w])
          )
        captures:
          1: {patterns: [include: "#function-names"]}

  # Variables

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.optional.pta
      - match: (?i)\s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.spread.pta
      - match: (?i)\s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.name.pta
      - match: (?i)\s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.reference.pta
      - match: (?i)\s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.other.pta
      - match: (?i)\s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
        name: variable.parameter.pta

  variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\b
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )
      \b
    captures:
      1: {name: variable.other.index.pta}
      2: {name: variable.other.constant.property.pta}
      3: {name: variable.other.property.static.pta}
      4: {name: variable.other.property.pta}
      5: {name: variable.other.global.pta}
      6: {name: variable.other.constant.object.pta}
      7: {name: variable.other.conditional.pta}
      8: {name: variable.other.object.pta}
      9: {name: variable.other.dollar.pta}
      10: {name: variable.other.constant.pta}
      11: {name: variable.other.class.pta}
      12: {name: variable.other.readwrite.pta}

  # Operators

  operators:
    patterns:
      - include: "#pipeline-operator"
      - include: "#unary-ops"
      - include: "#binary-ops"
  special-operators:
    patterns:
      - begin: (?<=^|\s)(\?)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.conditional.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\!)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.ternary.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            patterns:
              - include: "#constants"
              - include: "#variables"
          - include: $self
      - begin: (?<=^|\s)(\$)(?=\s|$)
        end: (?<=^|\s)(:)(?=\s|$)
        captures:
          1: {name: keyword.operator.macro.dollar.pta}
        patterns:
          - begin: \s*(?=([\p{Pc}\p{L}][\w\p{Pd}]*)\s*:)
            end: \s*(?=:\s|$)
            name: entity.name.function.pta
          - include: $self
  binary-ops:
    patterns:
      - comment: augmented assignment += -= *= /= etc
        match: (?<=^|[\s'"`({\[])([\p{S}\p{P}&&[^~<=>.,:;!'"`(){}\[\]\p{Pc}]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=)(?=$|[\s'"`)}\]])
        name: keyword.operator.assignment.augmented.pta
      - comment: |
          BUILT-IN OPERATORS

          1: assignment : :=
          2: arithmetic + - * ** *** / // /// % %% *> <*
          3: increment/decrement ++ --
          4: logical && || ^^ !& !| !^ &| &!
          5: bitwise & | ^ ~
          6: bitwise shift << >> <<< >>>
          7: function pipeline <| |> <|| ||> <||| |||>
          8: function composition +> <+
          9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
          10: relational < > <= >=
          11: regex =< <> </ /> <$ $> <+> <*> </> <$>
          12: equality == != === !==
          13: wavy operators ~> <~ ~~> <~~
          14: fat arrow-like => ==> <==
          15: skinny arrow-like -> --> <- <--
          16: null-coalescing ??
          17: non-null coalescing !!
          18: compact ternary operator ?:
          19: inverse ternary operator !:
          20: infix function call $:
        captures:
          1: {name: keyword.operator.assignment.pta}
          2: {name: keyword.operator.arithmetic.pta}
          3: {name: keyword.operator.successor.pta}
          4: {name: keyword.operator.logical.pta}
          5: {name: keyword.operator.bitwise.pta}
          6: {name: keyword.operator.bitwise.shift.pta}
          7: {name: keyword.operator.pipeline.pta}
          8: {name: keyword.operator.compose.pta}
          9: {name: keyword.operator.class.pta}
          10: {name: keyword.operator.relational.pta}
          11: {name: keyword.operator.regexp.pta}
          12: {name: keyword.operator.comparison.pta}
          13: {name: keyword.operator.similarity.pta}
          14: {name: keyword.operator.arrow.fat.pta}
          15: {name: keyword.operator.arrow.skinny.pta}
          16: {name: keyword.operator.null-coalescing.pta}
          17: {name: keyword.operator.coalescing.pta}
          18: {name: keyword.operator.conditional.pta}
          19: {name: keyword.operator.ternary.pta}
          20: {name: keyword.operator.macro.dollar.pta}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          (:?=)#1
          |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
          |(\+\+|--)#3
          |(&&|\|\||\^\^)#4
          |([&|^~])#5
          |(<<<?|>>>?)#6
          |(\|{1,3}>|<\|{1,3})#7
          |(\+>|<\+)#8
          |([<>][!:]|[!:][<>])#9
          |([<>]=?|<=?>)#10
          |(=<|<?[/*|+$:]>?)#11
          |([!=]==?|[!=]~|~[!=])#12
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*~>|
          <~[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#13
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*=>|
          <=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#14
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*->|
          <-[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)#15
          |(\?\?)#16
          |(!!)#17
          |(\?:)#18
          |(!:)#19
          |(\$:)#20
          )
          (?=$|[\s'"`)}\]])# closing
      - comment: |
          CUSTOM OPERATORS

          1: custom bitwise (& | ^ ~)
          2: custom arithmetic (+ - * / %)
          3: custom prototype (:)
          4: custom accessor (.)
          5: custom equality (= !)
          6: custom comparison (< >)
          7: custom private (? #)
          8: custom mathematical (Unicode Sm)
          9: custom currency (Unicode Sc)
          10: custom ASCII (between \x80 and \xff)
          11: custom infix operators (all other chars)
        captures:
          1: {name: keyword.operator.bitwise.custom.pta}
          2: {name: keyword.operator.arithmetic.custom.pta}
          3: {name: keyword.operator.prototype.custom.pta}
          4: {name: keyword.operator.accessor.custom.pta}
          5: {name: keyword.operator.comparison.custom.pta}
          6: {name: keyword.operator.relational.custom.pta}
          7: {name: keyword.operator.private.custom.pta}
          8: {name: keyword.operator.math.custom.pta}
          9: {name: keyword.operator.currency.custom.pta}
          10: {name: keyword.operator.ascii.custom.pta}
          11: {name: keyword.operator.infix.custom.pta}
        match: |
          (?x)
          (?<=^|[\s'"`({\[])# opening
          (?:
          ([&|^~][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#1
          |([+\-*/%][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#2
          |([@:][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |(\.[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#3
          |([!=][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#4
          |([<>][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          |([?\#][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#6
          |(\p{Sm}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#7
          |(\p{Sc}[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#8
          |([\p{S}\p{P}&&[\x80-\xFF]][\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#9
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#10
          )
          (?=$|[\s'"`)}\]])# closing
  unary-ops:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: |
          (?x)(?<=\b|['"`)}\]])# closing
          (?:
          ([>.]\.[.<])#1
          |(\?[.:]=?)#2
          |(![.:]=?)#3
          |((?:::|\.)=?)#4
          |([\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)#5
          )
          (?=\b|['"`({\[])# opening
        captures:
          1: {name: keyword.operator.range.pta}
          2: {name: keyword.operator.optional.pta}
          3: {name: keyword.operator.assert.pta}
          4: {name: keyword.operator.accessor.pta}
          5: {name: keyword.operator.primary.pta}
      - &prefix-operators
        comment: Prefix operators
        match: |
          (?x)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
          (?=[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*
          [\w({\['"`])
        name: keyword.operator.prefix.pta
        captures:
          1: {name: keyword.operator.module.all.pta}
          2: {name: keyword.operator.increment.pta}
          3: {name: keyword.operator.decrement.pta}
          4: {name: keyword.operator.intersection.pta}
          5: {name: keyword.operator.union.pta}
          6: {name: keyword.operator.symmetric.pta}
          7: {name: keyword.operator.logical.pta}
          8: {name: keyword.operator.private.pta}
          9: {name: keyword.operator.decorator.pta}
          10: {name: keyword.operator.bitwise.not.pta}
          11: {name: keyword.operator.existential.pta}
          12: {name: keyword.operator.assignment.pta}
          13: {name: keyword.operator.pipeline.pta}
          14: {name: keyword.operator.private.pta}
          15: {name: keyword.operator.prefix.pta}
      - &suffix-operators
        comment: Suffix operators
        match: |
          (?x)
          (?<=[)}\]\w'"`]
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*)
          (?:([*/])#1
          |(\+)#2
          |(\-)#3
          |(\&)#4
          |(\|)#5
          |(\^)#6
          |(\!)#7
          |(\$)#8
          |(\@)#9
          |(\~)#10
          |(\?)#11
          |(\=)#12
          |(\$)#13
          |(\#)#14
          |[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]])#15
        name: keyword.operator.suffix.pta
        captures:
          1: {name: keyword.operator.module.all.pta}
          2: {name: keyword.operator.increment.pta}
          3: {name: keyword.operator.decrement.pta}
          4: {name: keyword.operator.intersection.pta}
          5: {name: keyword.operator.union.pta}
          6: {name: keyword.operator.symmetric.pta}
          7: {name: keyword.operator.assert.pta}
          8: {name: keyword.operator.private.pta}
          9: {name: keyword.operator.decorator.pta}
          10: {name: keyword.operator.bitwise.pta}
          11: {name: keyword.operator.optional.pta}
          12: {name: keyword.operator.assignment.pta}
          13: {name: keyword.operator.pipeline.pta}
          14: {name: keyword.operator.private.pta}
          15: {name: keyword.operator.suffix.pta}
  pipeline-operator:
    patterns:
      - applyEndPatternLast: 1
        begin: |
          (?x)\s*(?:(\+>)|(\|{1,3}>))(?=\s*(
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# prefix
          (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
          \b(?:# keywords
          in|of|as|is|new
          |to|til|thru|by|del
          |unset|ref|and|or|xor|not
          |var|let|func?|proc|type
          |class|data|enum|module
          |iter|macro|struct|object
          |trait|style|elem|prop|mark
          |go|defer|do|from|where|with
          |if|elif|else|then|def
          |for|each|loop|while
          |try|throw|catch|after
          |match|case|goto|pass|fail
          |break|next|redo|retry
          |return|yield|await|label
          |import|export|route
          |debug|assert|check
          )(?!\B|\p{Pd}+\b)
          )
          [\w]+
          (?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# primary
          [\w]+)*
          [\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]*# suffix
          )\s*([^(]|$|;))
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.compose.pta}
          2: {name: keyword.operator.pipeline.pta}
        patterns:
          - match: |
              (?x)\s*\b
              (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
              \b(?:# keywords
              in|of|as|is|new
              |to|til|thru|by|del
              |unset|ref|and|or|xor|not
              |var|let|func?|proc|type
              |class|data|enum|module
              |iter|macro|struct|object
              |trait|style|elem|prop|mark
              |go|defer|do|from|where|with
              |if|elif|else|then|def
              |for|each|loop|while
              |try|throw|catch|after
              |match|case|goto|pass|fail
              |break|next|redo|retry
              |return|yield|await|label
              |import|export|route
              |debug|assert|check
              )(?!\B|\p{Pd}+\b)
              )
              (?:
              (?:# Objects
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
              |
              (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
              (?:# Properties
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              |
              (?:# Regular variables
              (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
              ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
              ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
              ([\p{Pc}\p{L}][\w\p{Pd}]*)
              )
              )\b
            captures:
              1: {name: variable.other.global.pta}
              2: {name: variable.other.constant.object.pta}
              3: {name: variable.other.conditional.pta}
              4: {name: variable.other.object.pta}
              5: {name: entity.name.tag.pta}
              6: {name: entity.name.tag.pta support.class.component.pta}
              7: {name: entity.name.class.builtin.pta}
              8: {name: entity.name.function.method.pta}
              9: {name: entity.name.function.tagged-template.pta}
              10: {name: entity.name.type.pta}
              11: {name: entity.name.class.pta}
              12: {name: entity.name.function.pta}
          - *primary-operators

  # Types

  types:
    patterns:
      - match: \s*(==?>|--?>|~~?>)
        name: keyword.operator.type.function.pta
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.pta
      - include: "#params-clause"
      - include: "#angle-brackets"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#type-variables"
      - include: "#type-brackets"
      - include: "#type-operators"
      - include: "#type-strings"
      - include: "#literals"
  type-variables:
    comment: |
      Four types of variables:
      - _lead_underscore
      - UPPERCASE
      - PascalCase
      - camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?:^|[^.])\.|[?!:]:)=?)
      \b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|let|func?|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|elem|prop|mark
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass|fail
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )(?!\B|\p{Pd}+\b)
      )
      (?:
      (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      |
      (?:# Objects
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
      ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}][\w\p{Pd}]*)
      )
      )\b
    captures: &type-variables
      1: {name: entity.name.module.pta}
      2: {name: entity.name.tag.pta}
      3: {name: entity.name.namespace.pta}
      4: {name: entity.name.interface.pta}
      5: {name: entity.name.tag.block.pta}
      6: {name: entity.name.tag.script.pta}
      7: {name: entity.name.tag.style.pta}
      8: {name: entity.name.tag.inline.pta}
      9: {name: entity.name.label.pta}
      10: {name: entity.name.project.pta}
      11: {name: entity.name.class.pta}
      12: {name: entity.name.type.pta}
  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.pta}
    patterns:
      - include: "#types"
  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.pta
              - match: (?<!\s):(?=[\s,;}]|$)
                name: punctuation.separator.key-value.pta
              - match: (?<=^\s*|[,;{]\s*)(?:[-+*]\s+)*[-+*](?=\s|$)
                name: punctuation.definition.block.sequence.item.pta
        patterns:
          - begin: \s*(?<=\b(?:var|let|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
            end: \s*(})
            captures:
              1: {name: punctuation.definition.binding-pattern.object.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.mapping.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.dictionary.pta}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=(?:^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+)\s*\|\s*\||^\s*\|)\s*(\#\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.section.class.pta}
            patterns: [include: $self]
          - begin: \s*(?<=(?:^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+)\s*\|\s*\||^\s*\|)\s*(\{)\s*
            end: \s*(\})\s*
            captures:
              1: {name: punctuation.definition.block.pta}
            patterns: [include: $self]
      round-brackets: &type-round-brackets
        repository:
          function-params:
            patterns:
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\?[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.optional.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\*\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.spread.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\%\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.name.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\&\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.reference.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\$\??[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.other.pta
              - match: |
                  (?xi)\s*
                  (?<=^|(?:^|[^|])\||[({\[;,]|[(|]\.\s+|\s*\bas\b\s+)
                  \s*\b[\p{Pc}\p{L}][\w\p{Pd}]*\b\s*
                  (?=$|\s*(?:\b:\s+|\|(?!\|))|\s+[?:]?=\s+|\s+\bas\b\s+)
                name: variable.parameter.pta
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.pta
        patterns:
          - begin: \s*(\#?\()\s*
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - include: "#punctuation"
              - include: "#function-params"
              - include: "#types"
              - include: $self
      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
                captures:
                  1: {name: punctuation.separator.slice.pta}
              - match: ","
                name: punctuation.separator.sequence.pta
        patterns:
          - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.attribute-selector.pta}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.sequence.pta}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.pta
              - include: "#types"
              - include: $self
          - begin: \s*(\[)\s*
            end: \s*(\])\s*
            captures:
              1: {name: punctuation.definition.array.pta}
            patterns:
              - match: ","
                name: punctuation.separator.sequence.pta
              - include: "#types"
              - include: $self

  type-strings:
    comment: coming soon
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#type-embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.pta
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - match: "''"
            name: constant.character.escape.pta
          - include: "#type-embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.pta
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"
      - applyEndPatternLast: 1
        begin: \s*\B(\\)(?=\$?\w)
        end: (?=[\p{Z}\p{P}\p{S}])|$
        name: string.unquoted.pta
        captures:
          1: {name: punctuation.definition.string.pta}
        patterns:
          - include: "#string-escapes"
          - include: "#type-embedded"

  type-embedded-expression:
    patterns:
      - begin: (\${)\s*
        end: \s*(})
        name: entity.quasi.component.pta
        captures:
          1: {name: punctuation.section.embedded.pta}
        patterns: [include: "types", include: $self]
      - match: |
          (?x)(\$)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b
          (?<expr>
          # Recursive brackets
          ([?!]?\.|[?!:]:)?(?<b>
          \((?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\)|
          \[(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\]|
          \{(?:[^'"`(){}\[\]]+|\g<s>|\g<b>)*\}
          )|
          ([?!]?\.|[?!:]:)?\B(?<s>
          # Strings
          (?<q3>'''+|"""+|```+).*\g<q3>|
          (?<q2>")(?:[^\\"]|\\.)*\g<q2>|
          (?<bt>`)(?:[^\\`]|\\.)*\g<bt>|
          (?<q1>')(?:[^']|'')*\g<q1>
          )|
          # Rest of identifier characters
          ([?!]?\.|[?!:]:)?[\p{Pc}\p{L}][\p{Pd}\w]*\b
          )*
          )
        captures:
          1: {name: punctuation.section.embedded.pta}
          2: {patterns: [include: "#types", include: "#embedded-content"]}

  type-embedded:
    patterns:
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-embedded-raw:
    patterns:
      - match: \$\$|\%\%|\#\#
        name: constant.character.escape.pta
      - include: "#format-specifier"
      - include: "#embedded-placeholder"
      - include: "#type-embedded-expression"

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(ext)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.extends.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(impl)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.implements.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|attrof|infer|as|is)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(instof)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.instanceof.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(valof)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.valueof.pta

  type-operators:
    patterns:
      - &primary-operators
        comment: Primary binary operators
        match: (?x)(?<=['"`\\)}\]\w])(?:([>.]\.[.<])|(\?[.:]=?)|(![.:]=?)|((?:::|\.)=?))(?=['"`\\({\[\w])
        captures:
          1: {name: keyword.operator.range.pta}
          2: {name: keyword.operator.optional.pta}
          3: {name: keyword.operator.assert.pta}
          4: {name: keyword.operator.accessor.pta}
      - comment: type operators
        match: (?x)\s*(?:(\+)|(\-)|(\*)|(\/)|(\%)|(\!)|(\?)|(\&)|(\|)|(\^)|(\~)|(\$)|(\#)|([<>]))(?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.pta}
          2: {name: keyword.operator.difference.pta}
          3: {name: keyword.operator.product.pta}
          4: {name: keyword.operator.quotient.pta}
          5: {name: keyword.operator.remainder.pta}
          6: {name: keyword.operator.only.pta}
          7: {name: keyword.operator.maybe.pta}
          8: {name: keyword.operator.intersection.pta}
          9: {name: keyword.operator.union.pta}
          10: {name: keyword.operator.symmetric.pta}
          11: {name: keyword.operator.negation.pta}
          12: {name: keyword.operator.macro.dollar.pta}
          13: {name: keyword.operator.private.pta}
          14: {name: keyword.operator.class.pta}

  # Clauses and Keywords

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
        name: entity.name.namespace.pta
      - applyEndPatternLast: 1
        begin: \s+(impl)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.implements.pta}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.pta
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.namespace.pta
          - match: *class-name
            name: entity.name.trait.pta
          - include: "#comma"
      - applyEndPatternLast: 1
        begin: \s+(ext)\s+
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.pta}
        patterns:
          - match: '\.|::'
            name: punctuation.separator.namespace.pta
          - match: \b([\p{Pc}\p{L}][\w\p{Pd}]*)\b(?=\.|::)
            name: entity.name.module.pta
          - match: *class-name
            name: entity.name.interface.pta
          - include: "#comma"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.pta
      - include: "#regexps"
      - include: "#strings"
      - include: "#symbols"
      - include: "#constants"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]))
        end: (?=)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.pta}
        patterns: [include: "#types"]
      - include: "#comments"
      - include: "#brackets"
      - include: "#comma"
      - match: '\.|::'
        name: punctuation.separator.namespace.pta

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b
      (?:
      # Visibility and mutability
      pub|priv|prot|after|mut|immut
      |glo|loc|early|late|covar|contra
      |seal|abst|inter|exter|imply|exply
      |sub|impure|pure

      # Concurrency/thread
      |sync|async|stat|dyn|lazy|eager|bound|free

      # Function and methods
      |rec|gen|oper|get|set|post|del|curry|inline
      |prefix|suffix|infix|binary|unary|left|right
      )
      )(?!\B|\p{Pd}+\b)\s*
      )*
      )
      (?=
      \s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b
      (?:
      var|let|func?|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|elem|prop|mark
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - &decorators
            match: (?x)\s*@[\p{Pc}\p{L}][\w\p{Pd}]*(?:(?:\.|::)[\p{Pc}\p{L}][\w\p{Pd}]*)*\s*
            name: entity.name.class.decorator.pta
          - &modifiers
            match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|after|mut|immut
              |glo|loc|early|late|covar|contra
              |seal|abst|inter|exter|imply|exply
              |sub|impure|pure
              )|
              (# Function or method modifiers
              sync|async|stat|dyn|lazy|eager|bound|free
              )|
              (# Property modifiers
              rec|gen|oper|get|set|post|del|curry|inline
              |prefix|suffix|infix|binary|unary|left|right
              )
              )(?!\B|\p{Pd}+\b)\s*
            captures:
              1: {name: storage.modifier.pta}
              2: {name: storage.type.accessor.pta}
              3: {name: storage.type.property.pta}
              4: {name: keyword.operator.expression.pta}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(decl|def)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.declare.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(var|let)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.style.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(func?)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.function.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.procedure.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.class.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.data.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.enum.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.module.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.iterator.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.macro.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(struct)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.structure.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.object.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.trait.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.component.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.property.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(mark)(?!\B|\p{Pd}+\b)\s*
        name: storage.type.markup.pta

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(if|elif|else)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.conditional.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(for|loop|while)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.loop.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(try|throw|catch|after)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.trycatch.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(match|case|fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.switch.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(break|next|redo|retry|return|await|label|yield|goto|pass)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.flow.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.module.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(with|then|do|from|ref|go|defer)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.$1.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(debug|assert|check|where)(?!\B|\p{Pd}+\b)\s*
        name: keyword.other.$1.pta

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(in|of|as|is|new)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.$1.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(del)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.delete.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(to|til|till|thru|by)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.range.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(unset)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.void.pta
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(and|or|xor|not)(?!\B|\p{Pd}+\b)\s*
        name: keyword.operator.expression.logical.pta

  keywords:
    patterns:
      - include: "#validation-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(break|next|redo|retry|label|goto|pass)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.control.flow.pta}
        patterns:
          - match: *entity-name
            name: constant.other.label.pta

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(import|export|route)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.module.pta}
            patterns:
              - *modifiers
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.module.pta
              - include: "#type-keywords"
              - include: "#declarations"
              - include: "#strings"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.pta
              - match: *entity-name
                name: variable.other.readwrite.alias.pta

      validation-expression:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(where)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.validate.pta}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(pre|post|need|know|check|test|read|write|till|same)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.pta
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|x?or|not|all|any|some|none)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.validate.pta
          - include: $self

      query-expression:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(from)(?!\B|\p{Pd}+\b)\s*
        beginCaptures:
          1: {name: keyword.control.query.pta}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self
      query-body:
        patterns:
          - include: "#in-clause"
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"
        repository:
          in-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - include: "#query-body"
              - include: $self
          join-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b((?:full|part|self|cross)?(?!\B|\p{Pd}+\b)\s*\b(?:inner|outer|left|right)?(?!\B|\p{Pd}+\b)\s*\bjoin)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
              2: {patterns: [include: $self]}
              3: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(on|equals|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          where-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(where|having|filter|reject)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - include: "#query-body"
              - include: $self
          sort-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b((?:sort|order)(?!\B|\p{Pd}+\b)\s*\b(?:asc|desc)?(?!\B|\p{Pd}+\b)\s*\b(?:by|with)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - include: "#query-body"
              - include: $self
          select-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b((?:select|map)(?!\B|\p{Pd}+\b)\s*\b(?:unique|any|all)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          limit-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b((?:take|drop|limit|offset)(?!\B|\p{Pd}+\b)\s*\b(?:first|last|head|tail)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          reduce-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b((?:fold|reduce|scan)(?!\B|\p{Pd}+\b)\s*\b(?:left|right)?)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(by|while|until|with)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self
          group-clause:
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(group)(?!\B|\p{Pd}+\b)\s*
            beginCaptures:
              1: {name: keyword.control.query.pta}
            end: (?=[,;)}\]])
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(by|into)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.query.pta
              - include: "#query-body"
              - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#declare"
      - include: "#style"
      - include: "#markup"
      - include: "#function"
      - include: "#procedure"
      - include: "#class"
      - include: "#data"
      - include: "#enum"
      - include: "#module"
      - include: "#iterator"
      - include: "#macro"
      - include: "#structure"
      - include: "#object"
      - include: "#trait"
      - include: "#component"
      - include: "#property"

    repository:
      markup:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(mark)(?!\B|\p{Pd}+\b)(.*\n?)
        beginCaptures:
          1: {name: storage.type.markup.pta}
          2:
            name: string.unquoted.block.pta
            patterns: [include: "#markdown"]
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.pta
            patterns: [include: "#markdown"]
      style:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(style)(?!\B|\p{Pd}+\b)(.*\n?)
        beginCaptures:
          1: {name: storage.type.style.pta}
          2:
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.pta}
              - include: "#comments"
              - include: "#style-pair"
              - include: "#style-rules"
              - include: "#block-entities"
              - match: *entity-name
                name: entity.name.style.pta
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(\s+)(?!\s)
            end: ^(?!\1|\s*$)
            name: meta.style.yaml
            patterns: [include: "#style-properties"]

      component:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(elem)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.component.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.component.pta
            patterns: *html-tag-names

      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(var|let)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.variable.pta}
      declare:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(decl)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.other.declare.pta}

      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(func?)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.function.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.pta
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(proc)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.procedure.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.pta
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(class)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.class.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.pta
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(data)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.data.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.pta
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(enum)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.enum.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.pta
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(module)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.module.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.pta
      iterator:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(iter)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.iterator.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.iterator.pta
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(macro)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.macro.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.pta
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(struct)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.structure.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.pta
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(object)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.object.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.pta
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(trait)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.trait.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.pta
      property:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(prop)(?!\B|\p{Pd}+\b)\s*
        end: (?=)|$
        beginCaptures:
          1: {name: storage.type.property.pta}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.property.pta

  function-clause:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          iter|func?|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.method.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (?<=[?!:]:|\b\.|[?!]\.)
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.method.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          iter|func?|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)\s+
          (:?=)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: keyword.operator.assignment.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|[,;]\s*|\#?[({\[]\s*
      |(?:[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s+
      |\b(?:# keywords
      in|of|as|is|new
      |to|til|thru|by|del
      |unset|ref|and|or|xor|not
      |var|let|func?|proc|type
      |class|data|enum|module
      |iter|macro|struct|object
      |trait|style|elem|prop|mark
      |go|defer|do|from|where|with
      |if|elif|else|then|def
      |for|each|loop|while
      |try|throw|catch|after
      |match|case|goto|pass|fail
      |break|next|redo|retry
      |return|yield|await|label
      |import|export|route
      |debug|assert|check
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.pta}
    end: (?<!\|)(\|)(?!\|)
    patterns: *function-params

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#do-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#params-clause"
      - include: "#function-clause"

    repository:
      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - include: "#function-params"
      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(new)(?!\B|\p{Pd}+\b)
        end: (?=)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.pta}
        patterns:
          - match: *entity-name
            name: entity.name.instance.pta
          - include: "#type-keywords"
          - include: "#type-square-brackets"
          - include: "#parameter-brackets"
          - include: "#round-brackets"
      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(is|as)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.pta}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(type)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            captures:
              1: {name: keyword.other.typedef.pta}
            patterns:
              - match: (?<=^|\s)([?:]?=)(?=\s+|$)
                captures:
                  1: {name: keyword.operator.assignment.pta}
              - include: "#types"
      catch-clause:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(catch)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.catch.pta
        captures:
          1: {name: keyword.control.error.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
                name: keyword.control.error.pta
              - include: $self
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.error.pta
          - include: $self
      for-clause:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(for|each|while)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.for.pta
        captures:
          1: {name: keyword.control.loop.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - &for-clause-keywords
            match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(in|of)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.loop.pta
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - *for-clause-keywords
              - include: $self
          - include: $self
      if-clause:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(if|elif)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.if.pta
        captures:
          1: {name: keyword.control.conditional.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns: [include: $self]
      switch-clause:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(match)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.switch.pta
        captures:
          1: {name: keyword.control.match.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns: [include: $self]
      with-clause:
        begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(with)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        name: meta.with.pta
        captures:
          1: {name: keyword.control.with.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.with.pta
          - begin: \s*(\()
            end: \s*(\))\s*
            captures:
              1: {name: punctuation.definition.expression.pta}
            patterns:
              - *with-clause-keywords
              - include: $self
          - include: $self

  # Object labels

  labels:
    patterns:
      - comment: |
          Function def before function keyword
          x = def()
        match: |
          (?x)
          (?<=^|[{;,\s])\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          ((?:
          \s*(?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )
          )
          \s*)*)
          (?=\s*\b
          (?:
          iter|func?|proc|macro
          )\b
          )
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: punctuation.separator.key-value.pta}
          3: {patterns: *modifier-keywords}
      - begin: |
          (?x)
          (?<=^|[{;,\s])\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
          (
          (?:
          (?:# Visibility and mutability
          pub|priv|prot|after|mut|immut
          |glo|loc|early|late|covar|contra
          |seal|abst|inter|exter|imply|exply
          |sub|impure|pure

          # Concurrency/thread
          |sync|async|stat|dyn|lazy|eager|bound|free

          # Function and methods
          |rec|gen|oper|get|set|post|del|curry|inline
          |prefix|suffix|infix|binary|unary|left|right
          )\s*\b)*
          )\s*
          (\|)
          (?!\|)
        end: (?<!\|)(\|)(?!\|)
        name: meta.object-literal.key.pta
        captures:
          1: {name: entity.name.function.pta}
          2: {name: punctuation.separator.key-value.pta}
          3: {patterns: *modifier-keywords}
          4: {name: punctuation.separator.arguments.pta}
        endCaptures:
          1: {name: punctuation.separator.arguments.pta}
        patterns: *function-params
      - match: |
          (?x)
          (?<=^|[{;,\s])\s*
          (\b[\p{Pc}\p{L}][\p{Pd}\w]*\b)
          (:)\s+
        name: meta.object-literal.key.pta
        captures:
          1:
            name: constant.other.object.key.pta
            patterns:
              - include: "#constants"
              - include: "#numbers"
              - include: "#symbols"
              - include: "#string-content"
          2: {name: punctuation.separator.key-value.pta}

  # Punctuation

  punctuation:
    patterns:
      - include: "#comma"
      - include: "#semicolon"

  line-continuation:
    match: \\\n*|(\\)\s*(?=/[/*+]|$)
    name: punctuation.separator.continuation.line.pta
  comma:
    match: \s*(,)
    name: punctuation.separator.comma.pta
  double-semi:
    match: \s*(;;)
    name: punctuation.terminator.expression.pta
  semicolon:
    match: \s*(;)
    name: punctuation.terminator.statement.pta

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"
      - include: "#angle-brackets"

  angle-brackets:
    patterns:
      - comment: Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz
        name: meta.type-arguments.flowtype
        begin: (?<=^|['"`)}\]\s\w])(<)(?=['"`({\[\w])
        end: (?<=['"`)}\]>\w])(>)
        captures:
          1: {name: punctuation.type.arguments.pta}
        patterns:
          - include: "#types"
          - include: "#punctuation"

  closures:
    patterns:
      - begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(case)(?!\B|\p{Pd}+\b)\s*
        end: (?<=;)|(?={)|$|\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(then)(?!\B|\p{Pd}+\b)|(?<=[)}\]\w'"`])(:)(?=\s|$)
        captures:
          1: {name: keyword.control.match.pta}
          2: {name: punctuation.separator.colon.pta}
        patterns:
          - include: "#params-clause"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(is)(?!\B|\p{Pd}+\b)\s*
            end: (?=)|$
            beginCaptures:
              1: {name: keyword.control.match.pta}
            patterns:
              - include: "#types"
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(if|lest|elif|elest|else)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.pta
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(var|let|let|set|get|const)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.pta
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(from|to|thru|but|just|main|only|and|x?or|not|as|all|any|some|none|in|of)(?!\B|\p{Pd}+\b)\s*
            name: keyword.control.match.pta
          - include: "#type-keywords"
          - include: $self
      - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(fail)(?!\B|\p{Pd}+\b)\s*
        name: keyword.control.match.pta

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.pta
          - match: (?<!\s):(?=[\s,;}]|$)
            name: punctuation.separator.key-value.pta
          - match: (?<=^\s*|[,;{]\s*)(?:[-+*]\s+)*[-+*](?=\s|$)
            name: punctuation.definition.block.sequence.item.pta

    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.typeparameters.pta}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:var|let|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.object.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=(?:^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+)\s*\|\s*\||^\s*\|)\s*(\#\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.section.class.pta}
        patterns: [include: $self]
      - begin: \s*(?<=(?:^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+)\s*\|\s*\||^\s*\|)\s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.pta}
        patterns: [include: $self]
      - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\#\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.mapping.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=^|[,;({\[]|(?:^|[,;({\[]|[)}\]\w'"`]):\s+|(?:^|\s)[\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)\s*(\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.dictionary.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: (\#\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.section.class.pta}
        patterns: [include: $self]
      - begin: (\{)\s*
        end: \s*(\})\s*
        captures:
          1: {name: punctuation.definition.block.pta}
        patterns: [include: $self]

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.pta
          - match: (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(as)(?!\B|\p{Pd}+\b)\s*
            name: keyword.operator.expression.as.pta
          - match: (?<=[\w\s][(|])\.
            name: punctuation.definition.metadata.pta
    patterns:
      - begin: \s*(?<=[\w'"`)}\]>]|[^.]\.=?|[?!:]:=?)(\#?\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.parameters.pta}
        patterns:
          - include: "#punctuation"
          - include: "#clauses"
          - include: "#constants"
          - include: "#declarations"
          - include: "#expression-keywords"
          - include: "#function-params"
          - include: $self
      - begin: \s*(?<=\b(?:var|let|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.tuple.pta}
        patterns:
          - include: "#labels"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))\s*
        captures:
          1: {name: punctuation.definition.expression.pta}
        patterns: [include: $self]

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)(:)(?![\p{S}\p{P}&&[^,;'"`(){}\[\]\p{Pc}]]+)
            captures:
              1: {name: punctuation.separator.slice.pta}
          - match: ","
            name: punctuation.separator.sequence.pta
    patterns:
      - begin: \s*(?<=\b(?:var|let|in|of|as|is|new|to|til|thru|by|del|unset|ref|and|or|xor|not)\b\s*)(\#?\{)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.binding-pattern.array.pta}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.=?|[?!:]:=?)(\#?\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.attribute-selector.pta}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.sequence.pta}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.pta
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])\s*
        captures:
          1: {name: punctuation.definition.array.pta}
        patterns:
          - match: ","
            name: punctuation.separator.sequence.pta
          - include: $self

  # Support

  css-property-names:
    patterns:
      - match: |
          (?x)\s*\b(
          # Standard CSS
          additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration
          |animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backdrop-filter
          |backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image
          |background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border
          |border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color
          |border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius
          |border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image
          |border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end
          |border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color
          |border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width
          |border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius
          |border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style
          |border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side
          |caret-color|clear|clip|clip-path|clip-rule|color|color-adjust|color-interpolation-filters|column-count|column-fill|column-gap
          |column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|content|counter-increment
          |counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis
          |flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family
          |font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch
          |font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures
          |font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical
          |grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start
          |grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows
          |hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align
          |inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation
          |justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style
          |list-style-image|list-style-position|list-style-type|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start
          |margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset
          |mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode
          |mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width
          |max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position
          |offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans
          |outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline
          |overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]
          |pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left
          |padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin
          |place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align
          |ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start
          |scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right
          |scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom
          |scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right
          |scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type
          |scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size
          |speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit
          |stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright
          |text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style
          |text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation
          |text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-position|top|touch-action|transform
          |transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function
          |translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change
          |word-break|word-spacing|word-wrap|writing-mode|z-index|zoom

          # SVG attributes
          |alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile
          |color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity
          |glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid
          |marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap
          |stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y

          # Not listed on MDN; presumably deprecated
          |adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break
          |balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length
          |bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction
          |box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column
          |column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break
          |delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust
          |drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position
          |flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before
          |hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust
          |initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count
          |justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift
          |line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed
          |marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group
          |orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range
          |play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim
          |radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness
          |right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color
          |rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral
          |speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch
          |string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height
          |text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style
          |top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range
          |voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap

          # Standard CSS
          |additiveSymbols|alignContent|alignItems|alignSelf|all|animation|animationDelay|animationDirection|animationDuration
          |animationFillMode|animationIterationCount|animationName|animationPlayState|animationTimingFunction|backdropFilter
          |backfaceVisibility|background|backgroundAttachment|backgroundBlendMode|backgroundClip|backgroundColor|backgroundImage
          |backgroundOrigin|backgroundPosition|backgroundPosition[XY]|backgroundRepeat|backgroundSize|bleed|blockSize|border
          |borderBlockEnd|borderBlockEndColor|borderBlockEndStyle|borderBlockEndWidth|borderBlockStart|borderBlockStartColor
          |borderBlockStartStyle|borderBlockStartWidth|borderBottom|borderBottomColor|borderBottomLeftRadius|borderBottomRightRadius
          |borderBottomStyle|borderBottomWidth|borderCollapse|borderColor|borderEndEndRadius|borderEndStartRadius|borderImage
          |borderImageOutset|borderImageRepeat|borderImageSlice|borderImageSource|borderImageWidth|borderInlineEnd
          |borderInlineEndColor|borderInlineEndStyle|borderInlineEndWidth|borderInlineStart|borderInlineStartColor
          |borderInlineStartStyle|borderInlineStartWidth|borderLeft|borderLeftColor|borderLeftStyle|borderLeftWidth
          |borderRadius|borderRight|borderRightColor|borderRightStyle|borderRightWidth|borderSpacing|borderStartEndRadius
          |borderStartStartRadius|borderStyle|borderTop|borderTopColor|borderTopLeftRadius|borderTopRightRadius|borderTopStyle
          |borderTopWidth|borderWidth|bottom|boxDecorationBreak|boxShadow|boxSizing|breakAfter|breakBefore|breakInside|captionSide
          |caretColor|clear|clip|clipPath|clipRule|color|colorAdjust|colorInterpolationFilters|columnCount|columnFill|columnGap
          |columnRule|columnRuleColor|columnRuleStyle|columnRuleWidth|columnSpan|columnWidth|columns|contain|content|counterIncrement
          |counterReset|cursor|direction|display|emptyCells|enableBackground|fallback|fill|fillOpacity|fillRule|filter|flex|flexBasis
          |flexDirection|flexFlow|flexGrow|flexShrink|flexWrap|float|floodColor|floodOpacity|font|fontDisplay|fontFamily
          |fontFeatureSettings|fontKerning|fontLanguageOverride|fontOpticalSizing|fontSize|fontSizeAdjust|fontStretch
          |fontStyle|fontSynthesis|fontVariant|fontVariantAlternates|fontVariantCaps|fontVariantEastAsian|fontVariantLigatures
          |fontVariantNumeric|fontVariantPosition|fontVariationSettings|fontWeight|gap|glyphOrientationHorizontal|glyphOrientationVertical
          |grid|gridArea|gridAutoColumns|gridAutoFlow|gridAutoRows|gridColumn|gridColumnEnd|gridColumnGap|gridColumnStart
          |gridGap|gridRow|gridRowEnd|gridRowGap|gridRowStart|gridTemplate|gridTemplateAreas|gridTemplateColumns|gridTemplateRows
          |hangingPunctuation|height|hyphens|imageOrientation|imageRendering|imageResolution|imeMode|initialLetter|initialLetterAlign
          |inlineSize|inset|insetBlock|insetBlockEnd|insetBlockStart|insetInline|insetInlineEnd|insetInlineStart|isolation
          |justifyContent|justifyItems|justifySelf|kerning|left|letterSpacing|lightingColor|lineBreak|lineClamp|lineHeight|listStyle
          |listStyleImage|listStylePosition|listStyleType|margin|marginBlockEnd|marginBlockStart|marginBottom|marginInlineEnd|marginInlineStart
          |marginLeft|marginRight|marginTop|markerEnd|markerMid|markerStart|marks|mask|maskBorder|maskBorderMode|maskBorderOutset
          |maskBorderRepeat|maskBorderSlice|maskBorderSource|maskBorderWidth|maskClip|maskComposite|maskImage|maskMode
          |maskOrigin|maskPosition|maskRepeat|maskSize|maskType|maxBlockSize|maxHeight|maxInlineSize|maxLines|maxWidth
          |maxZoom|minBlockSize|minHeight|minInlineSize|minWidth|minZoom|mixBlendMode|negative|objectFit|objectPosition
          |offset|offsetAnchor|offsetDistance|offsetPath|offsetPosition|offsetRotation|opacity|order|orientation|orphans
          |outline|outlineColor|outlineOffset|outlineStyle|outlineWidth|overflow|overflowAnchor|overflowBlock|overflowInline
          |overflowWrap|overflow[XY]|overscrollBehavior|overscrollBehaviorBlock|overscrollBehaviorInline|overscrollBehavior[XY]
          |pad|padding|paddingBlockEnd|paddingBlockStart|paddingBottom|paddingInlineEnd|paddingInlineStart|paddingLeft
          |paddingRight|paddingTop|pageBreakAfter|pageBreakBefore|pageBreakInside|paintOrder|perspective|perspectiveOrigin
          |placeContent|placeItems|placeSelf|pointerEvents|position|prefix|quotes|range|resize|right|rotate|rowGap|rubyAlign
          |rubyMerge|rubyPosition|scale|scrollBehavior|scrollMargin|scrollMarginBlock|scrollMarginBlockEnd|scrollMarginBlockStart
          |scrollMarginBottom|scrollMarginInline|scrollMarginInlineEnd|scrollMarginInlineStart|scrollMarginLeft|scrollMarginRight
          |scrollMarginTop|scrollPadding|scrollPaddingBlock|scrollPaddingBlockEnd|scrollPaddingBlockStart|scrollPaddingBottom
          |scrollPaddingInline|scrollPaddingInlineEnd|scrollPaddingInlineStart|scrollPaddingLeft|scrollPaddingRight
          |scrollPaddingTop|scrollSnapAlign|scrollSnapCoordinate|scrollSnapDestination|scrollSnapStop|scrollSnapType
          |scrollbarColor|scrollbarGutter|scrollbarWidth|shapeImageThreshold|shapeMargin|shapeOutside|shapeRendering|size
          |speakAs|src|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit
          |strokeOpacity|strokeWidth|suffix|symbols|system|tabSize|tableLayout|textAlign|textAlignLast|textAnchor|textCombineUpright
          |textDecoration|textDecorationColor|textDecorationLine|textDecorationSkip|textDecorationSkipInk|textDecorationStyle
          |textEmphasis|textEmphasisColor|textEmphasisPosition|textEmphasisStyle|textIndent|textJustify|textOrientation
          |textOverflow|textRendering|textShadow|textSizeAdjust|textTransform|textUnderlinePosition|top|touchAction|transform
          |transformBox|transformOrigin|transformStyle|transition|transitionDelay|transitionDuration|transitionProperty|transitionTimingFunction
          |translate|unicodeBidi|unicodeRange|userSelect|userZoom|verticalAlign|visibility|whiteSpace|widows|width|willChange
          |wordBreak|wordSpacing|wordWrap|writingMode|zIndex|zoom

          # SVG attributes
          |alignmentBaseline|baselineShift|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile
          |colorRendering|cx|cy|dominantBaseline|enableBackground|fill|fillOpacity|fillRule|floodColor|floodOpacity
          |glyphOrientationHorizontal|glyphOrientationVertical|height|kerning|lightingColor|markerEnd|markerMid
          |markerStart|r|rx|ry|shapeRendering|stopColor|stopOpacity|stroke|strokeDasharray|strokeDashoffset|strokeLinecap
          |strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|textAnchor|width|x|y

          # Not listed on MDN; presumably deprecated
          |adjust|after|align|alignLast|alignment|alignmentAdjust|appearance|attachment|azimuth|backgroundBreak
          |balance|baseline|before|bidi|binding|bookmark|bookmarkLabel|bookmarkLevel|bookmarkTarget|borderLength
          |bottomColor|bottomLeftRadius|bottomRightRadius|bottomStyle|bottomWidth|box|boxAlign|boxDirection
          |boxFlex|boxFlexGroup|boxLines|boxOrdinalGroup|boxOrient|boxPack|break|character|collapse|column
          |columnBreakAfter|columnBreakBefore|count|counter|crop|cue|cueAfter|cueBefore|decoration|decorationBreak
          |delay|displayModel|displayRole|down|drop|dropInitialAfterAdjust|dropInitialAfterAlign|dropInitialBeforeAdjust
          |dropInitialBeforeAlign|dropInitialSize|dropInitialValue|duration|elevation|emphasis|family|fit|fitPosition
          |flexGroup|floatOffset|gap|gridColumns|gridRows|hangingPunctuation|header|hyphenate|hyphenateAfter|hyphenateBefore
          |hyphenateCharacter|hyphenateLines|hyphenateResource|icon|image|increment|indent|index|initialAfterAdjust
          |initialAfterAlign|initialBeforeAdjust|initialBeforeAlign|initialSize|initialValue|inlineBoxAlign|iterationCount
          |justify|label|leftColor|leftStyle|leftWidth|length|level|line|lineStacking|lineStackingRuby|lineStackingShift
          |lineStackingStrategy|lines|list|mark|markAfter|markBefore|marks|marquee|marqueeDirection|marqueePlayCount|marqueeSpeed
          |marqueeStyle|max|min|model|moveTo|name|nav|navDown|navIndex|navLeft|navRight|navUp|new|numeral|offset|ordinalGroup
          |orient|origin|overflowStyle|overhang|pack|page|pagePolicy|pause|pauseAfter|pauseBefore|phonemes|pitch|pitchRange
          |playCount|playDuring|playState|point|presentation|presentationLevel|profile|property|punctuation|punctuationTrim
          |radius|rate|renderingIntent|repeat|replace|reset|resolution|resource|respondTo|rest|restAfter|restBefore|richness
          |rightColor|rightStyle|rightWidth|role|rotation|rotationPoint|rows|ruby|rubyOverhang|rubySpan|rule|ruleColor
          |ruleStyle|ruleWidth|shadow|size|sizeAdjust|sizing|space|spaceCollapse|spacing|span|speak|speakHeader|speakNumeral
          |speakPunctuation|speech|speechRate|speed|stacking|stackingRuby|stackingShift|stackingStrategy|stress|stretch
          |stringSet|style|styleImage|stylePosition|styleType|target|targetName|targetNew|targetPosition|text|textHeight
          |textJustify|textOutline|textReplace|textWrap|timingFunction|topColor|topLeftRadius|topRightRadius|topStyle
          |topWidth|trim|unicode|up|userSelect|variant|voice|voiceBalance|voiceDuration|voiceFamily|voicePitch|voicePitchRange
          |voiceRate|voiceStress|voiceVolume|volume|weight|white|whiteSpaceCollapse|word|wrap
          )(?!\B|\p{Pd}+\b)\s*
        name: support.type.property-name.css.pta

  css-value-names:
    comment: TODO
    patterns:
      - match: |
          (?x)\s*\b(
          aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.color.w3c-standard-color-name.css.pta
      - match: |
          (?x)\s*\b(
          aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood
          |cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan
          |darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange
          |darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise
          |darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen
          |gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki
          |lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow
          |lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray
          |lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue
          |mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise
          |mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered
          |orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum
          |powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell
          |sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato
          |transparent|turquoise|violet|wheat|whitesmoke|yellowgreen
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.color.w3c-extended-color-name.css.pta
      - match: (?x)\s*\b(currentColor)(?!\B|\p{Pd}+\b)\s*
        name: support.constant.color.current.css.pta
      - match: |
          (?x)\s*\b
          (ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow
          |ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption
          |InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow
          |ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)
          (?!\B|\p{Pd}+\b)\s*
        name: support.constant.color.system.css.pta
      - match: |
          (?x)\s*\b(
          above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse
          |always|antialiased|auto|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel
          |bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets
          |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn
          |color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover
          |crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures
          |distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in
          |ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded
          |fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|freeze
          |from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide
          |historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space
          |ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start
          |inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83
          |jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB
          |lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent
          |match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize
          |nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures
          |no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize
          |oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
          |padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line
          |pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]
          |reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text
          |ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate
          |sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller
          |smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap
          |step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table
          |table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl
          |text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle
          |ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical
          |vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy
          |weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out

          |above|absolute|active|add|additive|afterEdge|alias|all|allPetiteCaps|allScroll|allSmallCaps|alpha|alphabetic|alternate|alternateReverse
          |always|antialiased|auto|autoPos|available|avoid|avoidColumn|avoidPage|avoidRegion|backwards|balance|baseline|beforeEdge|below|bevel
          |bidiOverride|blink|block|blockAxis|blockStart|blockEnd|bold|bolder|border|borderBox|both|bottom|bottomOutside|breakAll|breakWord|bullets
          |butt|capitalize|caption|cell|center|central|char|circle|clip|clone|closeQuote|closestCorner|closestSide|colResize|collapse|color|colorBurn
          |colorDodge|column|columnReverse|commonLigatures|compact|condensed|contain|content|contentBox|contents|contextMenu|contextual|copy|cover
          |crispEdges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonalFractions|difference|digits|disabled|disc|discretionaryLigatures
          |distribute|distributeAllLines|distributeLetter|distributeSpace|dot|dotted|double|doubleCircle|downleft|downright|eResize|eachLine|ease|easeIn
          |easeInOut|easeOut|economy|ellipse|ellipsis|embed|end|evenodd|ewResize|exact|exclude|exclusion|expanded|extends|extraCondensed|extraExpanded
          |fallback|farthestCorner|farthestSide|fill|fillAvailable|fillBox|filled|fitContent|fixed|flat|flex|flexEnd|flexStart|flip|flowRoot|forwards|freeze
          |fromImage|fullWidth|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hardLight|help|hidden|hide
          |historicalForms|historicalLigatures|horizontal|horizontalTb|hue|icon|ideographAlpha|ideographNumeric|ideographParenthesis|ideographSpace
          |ideographic|inactive|infinite|inherit|initial|inline|inlineAxis|inlineBlock|inlineEnd|inlineFlex|inlineGrid|inlineListItem|inlineStart
          |inlineTable|inset|inside|interCharacter|interIdeograph|interWord|intersect|invert|isolate|isolateOverride|italic|jis04|jis78|jis83
          |jis90|justify|justifyAll|kannada|keepAll|landscape|large|larger|left|lighten|lighter|line|lineEdge|lineThrough|linear|linearRGB
          |liningNums|listItem|local|loose|lowercase|lr|lrTb|ltr|luminance|luminosity|mainSize|mandatory|manipulation|manual|marginBox|matchParent
          |matchSource|mathematical|maxContent|medium|menu|messageBox|middle|minContent|miter|mixed|move|multiply|nResize|narrower|neResize
          |nearestNeighbor|neswResize|newspaper|noChange|noClip|noCloseQuote|noCommonLigatures|noContextual|noDiscretionaryLigatures
          |noDrop|noHistoricalLigatures|noOpenQuote|noRepeat|none|nonzero|normal|notAllowed|nowrap|nsResize|numbers|numeric|nwResize|nwseResize
          |oblique|oldstyleNums|open|openQuote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding
          |paddingBox|page|painted|panDown|panLeft|panRight|panUp|panX|panY|paused|petiteCaps|pixelated|plaintext|pointer|portrait|pre|preLine
          |preWrap|preserve3d|progress|progressive|proportionalNums|proportionalWidth|proximity|radial|recto|region|relative|remove|repeat|repeat[xy]
          |resetSize|reverse|revert|ridge|right|rl|rlTb|round|row|rowResize|rowReverse|rowSeverse|rtl|ruby|rubyBase|rubyBaseContainer|rubyText
          |rubyTextContainer|runIn|running|sResize|saturation|scaleDown|screen|scroll|scrollPosition|seResize|semiCondensed|semiExpanded|separate
          |sesame|show|sideways|sidewaysLeft|sidewaysLr|sidewaysRight|sidewaysRl|simplified|slashedZero|slice|small|smallCaps|smallCaption|smaller
          |smooth|softLight|solid|space|spaceAround|spaceBetween|spaceEvenly|spellOut|square|sRGB|stackedFractions|start|static|statusBar|swap
          |stepEnd|stepStart|sticky|stretch|strict|stroke|strokeBox|style|sub|subgrid|subpixelAntialiased|subtract|super|swResize|symbolic|table
          |tableCaption|tableCell|tableColumn|tableColumnGroup|tableFooterGroup|tableHeaderGroup|tableRow|tableRowGroup|tabularNums|tb|tbRl
          |text|textAfterEdge|textBeforeEdge|textBottom|textTop|thick|thin|titlingCaps|top|topOutside|touch|traditional|transparent|triangle
          |ultraCondensed|ultraExpanded|under|underline|unicase|unset|upleft|uppercase|upright|useGlyphOrientation|useScript|verso|vertical
          |verticalIdeographic|verticalLr|verticalRl|verticalText|viewBox|visible|visibleFill|visiblePainted|visibleStroke|wResize|wait|wavy
          |weight|whitespace|wider|words|wrap|wrapReverse|x|xLarge|xSmall|xxLarge|xxSmall|y|zero|zoomIn|zoomOut
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.property-value.css.pta
      - match: |
          (?x)\s*\b(
          arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic
          |decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am
          |ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew
          |hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer
          |korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek
          |lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal
          |square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian
          |upper-latin|upper-roman|urdu

          |arabicIndic|armenian|bengali|cambodian|circle|cjkDecimal|cjkEarthlyBranch|cjkHeavenlyStem|cjkIdeographic
          |decimal|decimalLeadingZero|devanagari|disc|disclosureClosed|disclosureOpen|ethiopicHalehameAm
          |ethiopicHalehameTiE[rt]|ethiopicNumeric|georgian|gujarati|gurmukhi|hangul|hangulConsonant|hebrew
          |hiragana|hiraganaIroha|japaneseFormal|japaneseInformal|kannada|katakana|katakanaIroha|khmer
          |koreanHangulFormal|koreanHanjaFormal|koreanHanjaInformal|lao|lowerAlpha|lowerArmenian|lowerGreek
          |lowerLatin|lowerRoman|malayalam|mongolian|myanmar|oriya|persian|simpChineseFormal|simpChineseInformal
          |square|tamil|telugu|thai|tibetan|tradChineseFormal|tradChineseInformal|upperAlpha|upperArmenian
          |upperLatin|upperRoman|urdu
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.property-value.list-style-type.css.pta
      - match: |
          (?x)\s*\b(
          arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma
          |times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif
          |monospace

          |arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|systemUi|system|tahoma
          |times|trebuchet|uiMonospace|uiRounded|uiSansSerif|uiSerif|utopia|verdana|webdings|sansSerif|serif
          |monospace
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.font-name.css.pta

  html-tag-names:
    patterns:
      - match: |
          (?x)\s*\b(?:
          (all|print|screen|speech)
          |(aural|braille|embossed|handheld|projection|tty|tv)
          )(?!\B|\p{Pd}+\b)\s*
        name: support.constant.media.css.pta
      - match: |
          (?x)\s*\b(

          # HTML
          a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound
          |big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command
          |content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset
          |figcaption|figure|font|footer|form|frame|frameset|h(?:0|[1-9]\d*)|head|header|hgroup|hr|html|i
          |iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark
          |marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript
          |object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc
          |ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong
          |style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr
          |track|tt|u|ul|var|video|wbr|xmp

          # SVG
          |altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform
          |circle|clipPath|colorProfile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix
          |feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap
          |feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur
          |feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting
          |feSpotLight|feTile|feTurbulence|filter|fontFace|fontFaceFormat|fontFaceName
          |fontFaceSrc|fontFaceUri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern
          |line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata
          |missingGlyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor
          |stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern

          # MathML
          |annotation|annotationXml|maction|maligngroup|malignmark|math|menclose|merror|mfenced
          |mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot
          |mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup
          |msup|mtable|mtd|mtext|mtr|munder|munderover|semantics

          )(?!\B|\p{Pd}+\b)\s*
        name: entity.name.tag.css.pta

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"
  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|[NR]at)
          |Imag|Comp|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          # lowerFlatCase
          |bool|[nr]at|real|num|(big)?(u?int|float|[nr]at)
          |imag|comp|char|rune|str|sym
          |u?int(8|16|32|64|128)
          |[ci]?float(16|32|64|128)
          |[ui](8|16|32|64|128)
          |[ci]?f(16|32|64|128)
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.primitive.pta
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map|Bag|Str)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          # lowerFlatCase
          |array|tuple|(mut)?(list|set|map|bag|str)|dict|func|iter
          |proc|seq|gen|range|stack|heap|queue|tree|trie
          |future|stream|regexp?|func|buf|strbuf|bytes
          )(?!\B|\p{Pd}+\b)
        name: support.type.builtin.pta
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?:^|[^.])\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit|Obj
          |Any|Mixed|Just|Some|None|Never|(Im)?pure|Const
          # lowerFlatCase
          |true|false|null|void|nan|infin|empty|unit|obj
          |any|mixed|just|some|none|never|(im)?pure|const
          )(?!\B|\p{Pd}+\b)
        name: support.type.primitive.pta
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)?(Error|Exception)(?!\B|\p{Pd}+\b)
        name: support.class.error.pta
      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.interface.pta
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)(?!\B|\p{Pd}+\b)
        name: entity.name.namespace.pta
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+)able(?!\B|\p{Pd}+\b)
        name: support.class.trait.pta
  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: Python and Perl 6/Raku built-in functions
        match: |
          (?x)\s*\b(
          # Python
          import|abs|all|any|ascii|bin|breakpoint|callable|chr|compile
          |copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter
          |format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance
          |issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct
          |open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted
          |sum|vars|zip|file|reduce|intern|rawInput|unicode|cmp|basestring|execfile
          |long|xrange|bool|bytearray|bytes|classmethod|complex|dict|float|frozenset
          |int|list|object|property|set|slice|staticmethod|str|tuple|type

          # JavaScript
          |isNaN|isFinite|eval|uneval|parseInt|parseFloat|decodeURI
          |decodeURIComponent|encodeURI|encodeURIComponent|escape|unescape|require
          |(?:clear|set)(?:Interval|Timeout)

          # Perl
          |eager|hyper|substr|index|rindex|grep|map|sort|join|lines|hints
          |chmod|split|reduce|min|max|reverse|truncate|zip|cat|roundrobin
          |classify|first|sum|keys|values|pairs|defined|delete|exists|elems
          |end|kv|any|all|one|wrap|shape|key|value|name|pop|push|shift
          |splice|unshift|floor|ceiling|abs|exp|log|log10|rand|sign|sqrt
          |sin|cos|tan|round|strand|roots|cis|unpolar|polar|atan2|pick|chop
          |p5chop|chomp|p5chomp|lc|lcfirst|uc|ucfirst|capitalize|normalize|pack
          |unpack|quotemeta|comb|samecase|sameaccent|chars|nfd|nfc|nfkd|nfkc
          |printf|sprintf|caller|evalfile|run|runinstead|nothing|want|bless
          |chr|ord|gmtime|time|eof|localtime|gethost|getpw|chroot|getlogin
          |getpeername|kill|fork|wait|perl|graphs|codes|bytes|clone|print
          |open|read|write|readline|say|seek|close|opendir|readdir|slurp
          |spurt|shell|run|pos|fmt|vec|link|unlink|symlink|uniq|pair|asin
          |atan|sec|cosec|cotan|asec|acosec|acotan|sinh|cosh|tanh|asinh
          |done|acos|acosh|atanh|sech|cosech|cotanh|sech|acosech|acotanh
          |asech|ok|nok|planOk|diesOk|livesOk|skip|todo|pass|flunk
          |forceTodo|useOk|isaOk|diag|isDeeply|isnt|like|skipRest
          |unlike|cmpOk|evalDiesOk|nokError|evalLivesOk|approx
          |isApprox|throwsOk|versionLt|plan|eval|succ|pred|times|nonce
          |once|signature|new|connect|operator|undef|undefine|sleep|from
          |to|infix|postfix|prefix|circumfix|postcircumfix|minmax|lazy
          |count|unwrap|getc|pi|e|context|void|quasi|body|each|contains
          |rewinddir|subst|can|isa|flush|arity|assuming|rewind|callwith
          |callsame|nextwith|nextsame|attr|evalElsewhere|none|srand|trim
          |trimStart|trimEnd|lastcall|what|where|how|which|var|who
          |whence|accepts|rejects|not|true|iterator|by|re|im|invert
          |flip|gist|flat|tree|isPrime|throwsLike|trans
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.pta
      - comment: Python magic functions
        match: |
          (?x)\s*\b(
          \p{Pc}+(?:
          abs|add|aenter|aexit|aiter|and|anext|await
          |bool|call|ceil|cmp|coerce|complex|contains
          |copy|deepcopy|del|delattr|delete|delitem
          |delslice|dir|div|divmod|enter|eq|exit|float
          |floor|floordiv|format|ge|get|getattr
          |getattribute|getinitargs|getitem|getnewargs
          |getslice|getstate|gt|hash|hex|iadd|iand|idiv
          |ifloordiv|ilshift|imod|imul|index|init
          |instancecheck|int|invert|ior|ipow|irshift|isub
          |iter|itruediv|ixor|le|len|long|lshift|lt
          |missing|mod|mul|ne|neg|new|next|nonzero|oct|or
          |pos|pow|radd|rand|rdiv|rdivmod|reduce
          |reduceEx|repr|reversed|rfloordiv|rlshift|rmod
          |rmul|ror|round|rpow|rrshift|rshift|rsub
          |rtruediv|rxor|set|setattr|setitem|setslice
          |setstate|sizeof|str|sub|subclasscheck|truediv
          |trunc|unicode|xor|matmul|rmatmul|imatmul
          |initSubclass|setName|fspath|bytes|prepare
          |all|bases|builtins|class|classGetitem|code|debug
          |defaults|dict|doc|file|func|kwdefaults|members
          |metaclass|methods|module|mro|mroEntries|name
          |qualname|postInit|self|signature|slots|subclasses
          |version|weakref|wrapped|annotations|classcell
          |spec|path|package|future|traceback
          )\p{Pc}+
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.pta
      - comment: Ruby kernel functions
        match: |
          (?x)\s*\b(
          # Ruby builtin functions
          abort|atExit|autoload|binding|callcc|caller|callerLocations
          |chomp|chop|eval|exec|exit|exit|fork|format|gets
          |globalVariables|gsub|lambda|load|localVariables|open
          |p|print|printf|proc|putc|puts|rand|readline|readlines
          |select|setTraceFunc|sleep|spawn|sprintf|srand|sub
          |syscall|system|test|traceVar|trap|untraceVar|warn

          # C StdLib
          |abort|abs|acos|asctime|asctimeR|asin|assert|atan|atan2|atexit|atof|atoi|atol|bsearch|btowc|calloc
          |catclose6|catgets6|catopen6|ceil|clearerr|clock|cos|cosh|ctime|ctime64|ctimeR|ctime64R|difftime
          |difftime64|div|erf|erfc|exit|exp|fabs|fclose|fdopen5|feof|ferror|fflush1|fgetc1|fgetpos1|fgets1
          |fgetwc6|fgetws6|fileno5|floor|fmod|fopen|fprintf|fputc1|fputs1|fputwc6|fputws6|fread|free|freopen
          |frexp|fscanf|fseek1|fsetpos1|ftell1|fwide6|fwprintf6|fwrite|fwscanf6|gamma|getc1|getchar1|getenv
          |gets|getwc6|getwchar6|gmtime|gmtime64|gmtimeR|gmtime64R|hypot|isalnum|isalpha|isascii4|isblank
          |iscntrl|isdigit|isgraph|islower|isprint|ispunct|isspace|isupper|iswalnum4|iswalpha4|iswblank4
          |iswcntrl4|iswctype4|iswdigit4|iswgraph4|iswlower4|iswprint4|iswpunct4|iswspace4|iswupper4|iswxdigit4
          |isxdigit4|j0|j1|jn|labs|ldexp|ldiv|localeconv|localtime|localtime64|localtimeR|localtime64R
          |log|log10|longjmp|malloc|mblen|mbrlen4|mbrtowc4|mbsinit4|mbsrtowcs4|mbstowcs|mbtowc|memchr|memcmp
          |memcpy|memmove|memset|mktime|mktime64|modf|nextafter|nextafterl|nexttoward|nexttowardl
          |nlLanginfo4|perror|pow|printf|putc1|putchar1|putenv|puts|putwc6|putwchar6|qsort|quantexpd32
          |quantexpd64|quantexpd128|quantized32|quantized64|quantized128|samequantumd32|samequantumd64
          |samequantumd128|raise|rand|randR|realloc|regcomp|regerror|regexec|regfree|remove|rename|rewind1
          |scanf|setbuf|setjmp|setlocale|setvbuf|signal|sin|sinh|snprintf|sprintf|sqrt|srand|sscanf
          |strcasecmp|strcat|strchr|strcmp|strcoll|strcpy|strcspn|strerror|strfmon4|strftime|strlen
          |strncasecmp|strncat|strncmp|strncpy|strpbrk|strptime4|strrchr|strspn|strstr|strtod|strtod32
          |strtod64|strtod128|strtof|strtok|strtokR|strtol|strtold|strtoul|strxfrm|swprintf|swscanf|system
          |tan|tanh|time|time64|tmpfile|tmpnam|toascii|tolower|toupper|towctrans|towlower4|towupper4|ungetc1
          |ungetwc6|vaArg|vaCopy|vaEnd|vaStart|vfprintf|vfscanf|vfwprintf6|vfwscanf|vprintf|vscanf|vsprintf
          |vsnprintf|vsscanf|vswprintf|vswscanf|vwprintf6|vwscanf|wcrtomb4|wcscat|wcschr|wcscmp|wcscoll4|wcscpy
          |wcscspn|wcsftime|wcslen|wcslocaleconv|wcsncat|wcsncmp|wcsncpy|wcspbrk|wcsptime|wcsrchr|wcsrtombs4
          |wcsspn|wcsstr|wcstod|wcstod32|wcstod64|wcstod128|wcstof|wcstok|wcstol|wcstold|wcstombs|wcstoul
          |wcsxfrm4|wctob|wctomb|wctrans|wctype4|wcwidth|wmemchr|wmemcmp|wmemcpy|wmemmove|wmemset|wprintf6
          |wscanf6|y0|y1|yn
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.kernel.pta
      - comment: Event handler functions
        match: |
          (?x)\s*\b(
          on(Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
          Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
          Before(cut|deactivate|unload|update|paste|print|editfocus|activate)|
          Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
          Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
          Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
          Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
          Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.event-handler.pta
      - comment: JavaScript StdLib functions
        match: |
          (?x)\s*\b(
          shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
          scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
          sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|
          Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
          Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
          savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
          contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
          createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
          test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
          untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|
          print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
          fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
          forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
          abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
          releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
          Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
          Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
          moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.builtin.pta
      - comment: DOM functions
        match: |
          (?x)\s*\b(
          (acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
          appendChild|appendData|before|blur|canPlayType|captureStream|
          caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
          cloneContents|cloneNode|cloneRange|close|closest|collapse|
          compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
          convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
          createAttributeNS|createCaption|createCDATASection|createComment|
          createContextualFragment|createDocument|createDocumentFragment|
          createDocumentType|createElement|createElementNS|createEntityReference|
          createEvent|createExpression|createHTMLDocument|createNodeIterator|
          createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
          createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
          deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
          deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
          enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
          exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
          getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
          getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
          getClientRects|getContext|getDestinationInsertionPoints|getElementById|
          getElementsByClassName|getElementsByName|getElementsByTagName|
          getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
          getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
          hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
          insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
          insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
          isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
          lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
          moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
          parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
          previousSibling|probablySupportsContext|queryCommandEnabled|
          queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
          querySelector|querySelectorAll|registerContentHandler|registerElement|
          registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
          removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
          removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
          requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
          scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
          setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
          setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
          setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
          slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
          submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
          toDataURL|toggle|toString|values|write|writeln)
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.dom.pta
      - comment: Bash and Batch built-in functions
        match: |
          (?x)\s*\b(
          adprep|append|arp|assoc|at|atmadm|attrib|auditpol|autochk|autoconv|autofmt
          |bcdboot|bcdedit|bdehdcfg|bitsadmin|bootcfg|brea|cacls|cd|certreq|certutil
          |change|chcp|chdir|chglogon|chgport|chgusr|chkdsk|chkntfs|choice|cipher
          |clip|cls|clscluadmin|cluster|cmd|cmdkey|cmstp|color|comp|compact|convert
          |copy|cprofile|cscript|csvde|date|dcdiag|dcgpofix|dcpromo|defra|del|dfscmd
          |dfsdiag|dfsrmig|diantz|dir|dirquota|diskcomp|diskcopy|diskpart|diskperf
          |diskraid|diskshadow|dispdiag|doin|dnscmd|doskey|driverquery|dsacls|dsadd
          |dsamain|dsdbutil|dsget|dsmgmt|dsmod|dsmove|dsquery|dsrm|edit|endlocal
          |eraseesentutl|eventcreate|eventquery|eventtriggers|evntcmd|expand|extract
          |fc|filescrn|find|findstr|finger|flattemp|fonde|forfiles|format|freedisk
          |fsutil|ftp|ftype|fveupdate|getmac|gettype|gpfixup|gpresult|gpupdate
          |graftabl|hashgen|hep|helpctr|hostname|icacls|iisreset|inuse|ipconfig
          |ipxroute|irftp|ismserv|jetpack|klist|ksetup|ktmutil|ktpass|label|ldifd
          |ldp|lodctr|logman|logoff|lpq|lpr|macfile|makecab|manageBde|mapadmin|md
          |mkdir|mklink|mmc|mode|more|mount|mountvol|move|mqbup|mqsvc|mqtgsvc|msdt
          |msg|msiexec|msinfo32|mstsc|nbtstat|net|netcfg|netdiag|netdom|netsh|netstat
          |nfsadmin|nfsshare|nfsstat|nlb|nlbmgr|nltest|nslookup|ntackup|ntcmdprompt
          |ntdsutil|ntfrsutl|openfiles|pagefileconfig|path|pathping|pause|pbadmin
          |pentnt|perfmon|ping|pnpunatten|pnputil|popd|powercfg|powershell|powershellIse
          |print|prncnfg|prndrvr|prnjobs|prnmngr|prnport|prnqctl|prompt|pubprn|pushd
          |pushprinterconnections|pwlauncher|qappsrv|qprocess|query|quser|qwinsta
          |rasdial|rcp|rd|rdpsign|regentc|recover|redircmp|redirusr|reg|regini|regsvr32
          |relog|ren|rename|rendom|repadmin|repairBde|replace|reset|rxec|risetup
          |rmdir|robocopy|route|rpcinfo|rpcping|rsh|runas|rundll32|rwinsta|sc|schtasks
          |scp|scwcmd|secedit|serverceipoptin|servrmanagercmd|serverweroptin|setspn
          |setx|sfc|sftp|shadow|shift|showmount|shutdown|sort|ssh|sshAdd|sshAgent
          |sshKeygen|sshKeyscan|start|storrept|subst|sxstrace|ysocmgr|systeminfo
          |takeown|tapicfg|taskkill|tasklist|tcmsetup|telnet|tftp|time|timeout|title
          |tlntadmn|tpmvscmgr|tpmvscmgr|tacerpt|tracert|tree|tscon|tsdiscon|tsecimp
          |tskill|tsprof|type|typeperf|tzutil|uddiconfig|umount|unlodctr|ver|verifier
          |verif|vol|vssadmin|w32tm|waitfor|wbadmin|wdsutil|wecutil|wevtutil|where
          |whoami|winnt|winnt32|winpop|winrm|winrs|winsat|wlbs|wmic|wscript|wsl|xcopy
          |alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown
          |echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill
          |let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source
          |suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait
          |alias|apropos|apt|aptGet|aptitude|aspell|at|awk|basename|base32|base64
          |bash|bc|bg|bind|break|builtin|bzip2|cal|caller|when|cat|cd|cfdisk|chattr
          |chgrp|chmod|chown|chpasswd|chroot|chkconfig|cksum|clear|cmp|comm|command
          |continue|cp|cpio|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|declare
          |df|diff|diff3|dig|dir|dircolors|dirname|dirs|dos2unix|dmesg|dpkg|du|echo
          |egrep|eject|enable|env|ethtool|eval|exec|exit|expect|expand|export|expr
          |false|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|for|format|free|fsck|ftp
          |function|fuser|gawk|getopts|grep|groupadd|groupdel|groupmod|groups|gzip|hash
          |head|help|history|hostname|htop|iconv|id|if|ifconfig|ifdown|ifup|import|install
          |iostat|ip|jobs|join|kill|killall|less|let|link|ln|local|locate|logname|logout
          |look|lpc|lpr|lprint|lprintd|lprintq|lprm|lsattr|lsblk|ls|lsof|lspci|make|man
          |mapfile|mkdir|mkfifo|mkfile|mkisofs|mknod|mktemp|more|most|mount|mtools|mtr|mv
          |mmv|nc|netstat|nft|nice|nl|nohup|notifySend|nslookup|open|op|passwd|paste
          |pathchk|Perf|ping|pgrep|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd
          |quota|quotacheck|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice
          |remsync|return|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|select|seq|set|sftp
          |shift|shopt|shuf|shutdown|sleep|slocate|sort|source|split|ss|ssh|stat|strace
          |su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|tmux|touch|top
          |tput|traceroute|trap|tr|true|tsort|tty|type|ulimit|umask|umount|unalias|uname
          |unexpand|uniq|units|unix2dos|unrar|unset|unshar|until|uptime|useradd|userdel
          |usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|w|wait|watch|wc|whereis|which
          |while|who|whoami|wget|write|xargs|xdgOpen|xxd|xz|yes|zip
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.system.pta
      - comment: Bash and Batch built-in functions
        match: |
          (?x)\s*\b(
          avg|checksumAgg|count|countBig|grouping|groupingId|max|min|sum|stdev|stdevp|var
          |varp|cumeDist|firstValue|lag|lastValue|lead|percentRank|percentileCont|percentileDisc
          |cast|convert|parse|tryCast|tryConvert|tryParse|cursorStatus|coalesce|nullif|choose
          |iif|sysdatetime|sysdatetimeoffset|sysutcdatetime|currentTime(?:stamp)?|getdate
          |getutcdate|datename|datepart|day|month|year|datefromparts|datetime2fromparts
          |datetimefromparts|datetimeoffsetfromparts|smalldatetimefromparts|timefromparts
          |datediff|dateadd|eomonth|switchoffset|todatetimeoffset|isdate|cursorRows|connections
          |cpuBusy|datefirst|dbts|error|fetchStatus|identity|idle|ioBusy|langid|language
          |lockTimeout|maxConnections|maxPrecision|nestlevel|options|packetErrors|packReceived
          |packSent|procid|remserver|rowcount|servername|servicename|spid|textsize|timeticks
          |totalErrors|totalRead|totalWrite|trancount|version|abs|acos|asin|atan|atn2|ceiling
          |cos|cot|degrees|exp|floor|log|log10|pi|power|radians|rand|round|sign|sin|sqrt|square
          |tan|appName|applockMode|applockTest|assemblyproperty|colLength|colName|columnproperty
          |databasePrincipalId|databasepropertyex|dbId|dbName|fileId|fileIdex|fileName|filegroupId
          |filegroupName|filegroupproperty|fileproperty|fulltextcatalogproperty|fulltextserviceproperty
          |indexCol|indexkeyProperty|indexproperty|objectDefinition|objectId|objectName
          |objectSchemaName|objectproperty|objectpropertyex|originalDbName|parsename|schemaId|schemaName
          |scopeIdentity|serverproperty|statsDate|typeId|typeName|typeproperty|rank|denseRank|ntile
          |rowNumber|opendatasource|openrowset|openquery|openxml|certencoded|certprivatekey|currentUser
          |databasePrincipalId|hasPermsByName|isMember|isRolemember|isSrvrolemember|originalLogin|permissions
          |pwdcompare|pwdencrypt|schemaId|schemaName|sessionUser|suserId|suserSid|suserSname|systemUser
          |suserName|userId|userName|ascii|char|charindex|concat|difference|format|left|len|lower|ltrim
          |nchar|nodes|patindex|quotename|replace|replicate|reverse|right|rtrim|soundex|space|str|stringAgg
          |stringEscape|stringSplit|stuff|substring|translate|trim|unicode|upper|patindex|textptr|textvalid
          |binaryChecksum|checksum|compress|connectionproperty|contextInfo|currentRequestId|currentTransactionId
          |decompress|errorLine|errorMessage|errorNumber|errorProcedure|errorSeverity|errorState|formatmessage
          |getFilestreamTransactionContext|getansinull|hostId|hostName|isnull|isnumeric|minActiveRowversion
          |newid|newsequentialid|rowcountBig|sessionContext|sessionId|xactState
          )(?!\B|\p{Pd}+\b)\s*
        name: support.function.database.pta
      - comment: predicate functions
        match: (?x)\s*\bis(\p{Lu}[\w\p{Pd}&&\P{Lu}]*)+(?!\B|\p{Pd}+\b)\s*
        name: support.function.predicate.pta
      - comment: magic functions
        match: (?x)\s*\b\p{Pc}+([\p{Pc}\p{L}][\w\p{Pd}]*)+\p{Pc}+(?!\B|\p{Pd}+\b)\s*
        name: support.function.magic.pta
      - match: |
          (?x)\b(?:
          (?<=[!?]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          (?=\s|$|['"`\\</!({\[])
          |
          (?<=\s|^|['"`)}\]])
          (?:# Objects
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          )
          (?!\.\.+)(?=[!?]?\.=?|[?!:]:=?|\#?\[)
          |
          (?<=\s|^|['"`)}\]])
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}][\w\p{Pd}]*(?!\p{Pc}+))|
          ([\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*\p{Pd}[\w\p{Pd}]*|[\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}][\w\p{Pd}&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\w\p{Pd}]*)
          (?=\s|$|['"`\\</!({\[])
          )
          )\b
        captures:
          1: {name: entity.name.tag.pta}
          2: {name: entity.name.tag.pta support.class.component.pta}
          3: {name: entity.name.class.builtin.pta}
          4: {name: entity.name.function.method.pta}
          5: {name: variable.other.global.pta}
          6: {name: variable.other.constant.object.pta}
          7: {name: variable.other.conditional.pta}
          8: {name: variable.other.object.pta}
          9: {name: entity.name.function.tagged-template.pta}
          10: {name: entity.name.type.pta}
          11: {name: entity.name.class.pta}
          12: {name: entity.name.function.pta}
      - include: $self
  constant-names:
    comment: Names for constants, symbols and static properties
    patterns:
      - comment: Python
      - include: source.python#magic-variable-names
  variable-names:
    comment: Standard Library variable names
    patterns:
      - comment: Python
      - include: source.python#magic-function-names
  property-names:
    comment: Standard Library property names
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties

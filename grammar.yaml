name: Trinity
scopeName: source.dart
fileTypes: [dart, trin]
patterns: [include: "#core"]

Information for Contributors: |
  Trinity is a modern programming language inspired by JavaScript and compiles to JavaScript.
  It's got a great type system, a huge standard library and a unique combination of powerful
  features that support object-oriented, imperative, and functional programming.

  Should you want to provide a fix or improvement, a new grammar feature, or even some constructive
  feedback, head to my repo and make a pull request: https://github.com/nxltm/trinity-lang
  and I will be very happy to receive them.

  This document is always under construction, and there's still a couple of things that
  need to be fix. All this info would be on my Trello which I will be posting very soon.
  I will come back to fix them if I have the time.

  Some parts such as numeric literals, HTML character entities and more are partially
  or entirely generated through code by means of compressed tries and DFA minimization
  (Brzozowski algorithm).

comment: |
  To-Do:

  - Add function labels (map keys)
  - Add keywords for types from SQL
  - Add grammars for Unicode character entities
    - HTML5, AGL and LaTeX
    - Locale and Unicode script codes (done)
    - Transformation directives (%)

  - Add standard library functions, types, classes,
    modules, properties, variables in this order:
    - JavaScript/TypeScript
    - Swift
    - Java, Scala, Kotlin, Flix
    - Haskell, OCaml
    - Go, Rust
    - R
    - Python (names, methods, etc), Perl, Ruby, Lua
    - C, Objective C(++)
    - PHP (needs a bit of cleanup)

  Done:
  - Reworked keywords. Should be enough; added support for decorators too.
  - Syntax changed, mirrors C# now.
  - Oniguruma uses \w to refer to _\d\p{L}\p{M}, use character
    set operations && and ^ to perform set subtractions
  - Added extended JSX syntax (might still need some modifications)

define:
  number-literal: &number-literal
    1: {name: storage.type.numeric.trin}
    2: {name: punctuation.separator.decimal.period.trin}
    3: {name: constant.numeric.other.separator.trin}
    4: {name: constant.numeric.other.exponent.trin}
    5: {name: constant.numeric.other.density.trin}
    6: {name: storage.type.numeric.trin}

  entity-name-clause: &entity-name-clause |
    (?x)\s*\b
    (?<=(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:extends|implements)\b|\s*[<>]\s+)\s*

    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|out|new|infer|unset
    |typeof|nameof|sizeof
    |keyof|valueof|pairof|instof
    |len|del|to|til|till|thru|by

    |var|val|let|set|get|def|fn|fun|func
    |class|enum|module|package|inter|struct|object|record
    |frag|space|data|trait|proto|proc|macro|type|given
    |raw|style|compo|element|decl|ext|impl|sub

    |if|lest|elif|elest|else|then
    |for|each|loop|while|until|from|with
    |do|redo|try|retry|throw|catch|finally
    |switch|case|default|match|when|otherwise
    |unison|series|spawn|kill|fix|lock
    |break|continue|return|await|label|yield|goto
    |import|export|impose|expose|using
    |debug|check|assert|fallthru
    )\b
    )
    ([\p{Pc}\p{L}]\w*)
    \b

  entity-name: &entity-name |
    (?x)\s*\b
    (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
    \b(?:# don't match keywords
    in|of|as|is|out|new|infer|unset
    |typeof|nameof|sizeof
    |keyof|valueof|pairof|instof
    |len|del|to|til|till|thru|by

    |var|val|let|set|get|def|fn|fun|func
    |class|enum|module|package|inter|struct|object|record
    |frag|space|data|trait|proto|proc|macro|type|given
    |raw|style|compo|element|decl|ext|impl|sub

    |if|lest|elif|elest|else|then
    |for|each|loop|while|until|from|with
    |do|redo|try|retry|throw|catch|finally
    |switch|case|default|match|when|otherwise
    |unison|series|spawn|kill|fix|lock
    |break|continue|return|await|label|yield|goto
    |import|export|impose|expose|using
    |debug|check|assert|fallthru
    )\b
    )
    ([\p{Pc}\p{L}]\w*)
    \b

  posix-class: &posix-class |
    (?xi)
    \\o|
    \\p(?:
    # POSIX
    alpha|alnum|ascii|blank|cntrl|x?digit
    |graph|lower|print|punct|space|upper|word
    # Extended-POSIX
    |symbol|open|close|dash|link|start|final|math|money
    |number|letter|title|mark|modify
    |bin|qua|sen|oct|dec|doz|hex
    )

repository:
  core:
    patterns:
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - include: "#jsx"
      - include: "#comments"
      - include: "#brackets"
      - include: "#punctuation"
      - include: "#type-annotation"
      - include: "#literals"
      - include: "#support"
      - include: "#calls"
      - include: "#variables"
      - include: "#operators"
      - include: "#illegal"

  illegal:
    patterns:
      - match: \p{N}[\w.+-/\\]*?
        name: invalid.illegal.numeric.other.trin
      - match: '[\w]+?'
        name: invalid.illegal.variable.other.trin
      - match: '[({\[)}\]]+?'
        name: invalid.illegal.missing-bracket.trin
      - match: \S+?
        name: invalid.illegal.syntax.trin

  placeholder-variables:
    patterns:
      - match: (?i)\s*\?[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.optional.trin
      - match: (?i)\s*\*[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.spread.trin
      - match: (?i)\s*[&~][\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.name.trin
      - match: (?i)\s*\%[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.reference.trin
      - match: (?i)\s*\$[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.other.trin
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*
        name: variable.parameter.trin

  illegal-keywords:
    match: |
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
      in|of|as|is|out|new|infer|unset
      |typeof|nameof|sizeof
      |keyof|valueof|pairof|instof
      |len|del|to|til|till|thru|by

      |var|val|let|set|get|def|fn|fun|func
      |class|enum|module|package|inter|struct|object|record
      |frag|space|data|trait|proto|proc|macro|type|given
      |raw|style|compo|element|decl|ext|impl|sub

      |if|lest|elif|elest|else|then
      |for|each|loop|while|until|from|with
      |do|redo|try|retry|throw|catch|finally
      |switch|case|default|match|when|otherwise
      |unison|series|spawn|kill|fix|lock
      |break|continue|return|await|label|yield|goto
      |import|export|impose|expose|using
      |debug|check|assert|fallthru
      )\b\s*
    name: invalid.illegal.keyword.trin

  unicode-named-chars:
    comment: Support for the Unicode Named Character encoding, inspired
      by LaTeX, HTML, AGL, Unicode and regular expressions.
    repository:
      latex:
      unicode-scripts:
        patterns:
          - begin: (\(@)\s*(\w+(?:[\p{Pc}\p{Pd}]\w+)*)\s*(:)?
            end: \s*(\))
            name: meta.group.locale.trin
            captures:
              1: {name: punctuation.definition.group.flag.trin}
              3: {name: punctuation.separator.colon.trin}
              2:
                patterns:
                  - match: (?i)\b(((yue[\p{Pc}\p{Pd}]Hant|zh[\p{Pc}\p{Pd}]Han[st])[\p{Pc}\p{Pd}]H|pa[\p{Pc}\p{Pd}]Arab[\p{Pc}\p{Pd}]P|ur[\p{Pc}\p{Pd}]P|ta[\p{Pc}\p{Pd}]L|s(k[\p{Pc}\p{Pd}]S|i[\p{Pc}\p{Pd}]L)|mk[\p{Pc}\p{Pd}]M|en[\p{Pc}\p{Pd}]H)K|(tzm[\p{Pc}\p{Pd}]Latn[\p{Pc}\p{Pd}]M|s(hi[\p{Pc}\p{Pd}](Tfng|Latn)[\p{Pc}\p{Pd}]M|r[\p{Pc}\p{Pd}](Latn|Cyrl)[\p{Pc}\p{Pd}]B)|naq[\p{Pc}\p{Pd}]N|zu[\p{Pc}\p{Pd}]Z|uk[\p{Pc}\p{Pd}]U|ru[\p{Pc}\p{Pd}]U|en[\p{Pc}\p{Pd}]C|bs[\p{Pc}\p{Pd}]B)A|ha[\p{Pc}\p{Pd}]Latn[\p{Pc}\p{Pd}]N[EG]|(uz[\p{Pc}\p{Pd}]Arab[\p{Pc}\p{Pd}]A|sg[\p{Pc}\p{Pd}]C|ps[\p{Pc}\p{Pd}]A)F|(sr[\p{Pc}\p{Pd}](Latn|Cyrl)[\p{Pc}\p{Pd}]R|haw[\p{Pc}\p{Pd}]U|is[\p{Pc}\p{Pd}]I)S|(zh[\p{Pc}\p{Pd}]Hans[\p{Pc}\p{Pd}]C|(pa[\p{Pc}\p{Pd}]Guru|k(ok|n)|te|or|m[lr]|hi|gu)[\p{Pc}\p{Pd}]I|vi[\p{Pc}\p{Pd}]V|ur[\p{Pc}\p{Pd}]I|ta[\p{Pc}\p{Pd}]I|ne[\p{Pc}\p{Pd}]I|ms[\p{Pc}\p{Pd}]B|ii[\p{Pc}\p{Pd}]C|f[fr][\p{Pc}\p{Pd}]S|es[\p{Pc}\p{Pd}]H|b(o[\p{Pc}\p{Pd}][CI]|n[\p{Pc}\p{Pd}]I))N|(zh[\p{Pc}\p{Pd}]Hant[\p{Pc}\p{Pd}]T|rw[\p{Pc}\p{Pd}]R|pt[\p{Pc}\p{Pd}]G|sn[\p{Pc}\p{Pd}]Z|nd[\p{Pc}\p{Pd}]Z)W|(zh[\p{Pc}\p{Pd}]Han[st][\p{Pc}\p{Pd}]M|to[\p{Pc}\p{Pd}]T|so[\p{Pc}\p{Pd}]S|ro[\p{Pc}\p{Pd}]R|n[bn][\p{Pc}\p{Pd}]N|fo[\p{Pc}\p{Pd}]F|es[\p{Pc}\p{Pd}][BD])O|(zh[\p{Pc}\p{Pd}]Hans[\p{Pc}\p{Pd}]S|teo[\p{Pc}\p{Pd}]U|(nyn|lg)[\p{Pc}\p{Pd}]U|xog[\p{Pc}\p{Pd}]U|cgg[\p{Pc}\p{Pd}]U|mg[\p{Pc}\p{Pd}]M|yo[\p{Pc}\p{Pd}]N|ig[\p{Pc}\p{Pd}]N|e(n[\p{Pc}\p{Pd}]S|e[\p{Pc}\p{Pd}]T)|bg[\p{Pc}\p{Pd}]B)G|(uz[\p{Pc}\p{Pd}](Latn|Cyrl)[\p{Pc}\p{Pd}]U|k(k[\p{Pc}\p{Pd}]Cyrl[\p{Pc}\p{Pd}]K|ab[\p{Pc}\p{Pd}]D)|seh[\p{Pc}\p{Pd}]M|mas[\p{Pc}\p{Pd}]T|(vun|r(wk|of)|lag|kde|jmc|bez)[\p{Pc}\p{Pd}]T|pt[\p{Pc}\p{Pd}]M|sw[\p{Pc}\p{Pd}]T|cs[\p{Pc}\p{Pd}]C)Z|(s(r[\p{Pc}\p{Pd}](Latn|Cyrl)[\p{Pc}\p{Pd}]M|v[\p{Pc}\p{Pd}]S|o[\p{Pc}\p{Pd}]K)|teo[\p{Pc}\p{Pd}]K|mas[\p{Pc}\p{Pd}]K|(saq|mer|lu[oy]|k(ln|am|i)|guz|ebu)[\p{Pc}\p{Pd}]K|d(av[\p{Pc}\p{Pd}]K|e[\p{Pc}\p{Pd}][BD])|om[\p{Pc}\p{Pd}]K|nl[\p{Pc}\p{Pd}]B|sw[\p{Pc}\p{Pd}]K|ka[\p{Pc}\p{Pd}]G|ga[\p{Pc}\p{Pd}]I|fr[\p{Pc}\p{Pd}]N|e(t[\p{Pc}\p{Pd}]E|s[\p{Pc}\p{Pd}]V))E|(ha[\p{Pc}\p{Pd}]Latn[\p{Pc}\p{Pd}]G|gsw[\p{Pc}\p{Pd}]C|fil[\p{Pc}\p{Pd}]P|th[\p{Pc}\p{Pd}]T|km[\p{Pc}\p{Pd}]K|it[\p{Pc}\p{Pd}]C|rm[\p{Pc}\p{Pd}]C|ee[\p{Pc}\p{Pd}]G|de[\p{Pc}\p{Pd}]C)H|a((z[\p{Pc}\p{Pd}](Latn|Cyrl)[\p{Pc}\p{Pd}]A|sa[\p{Pc}\p{Pd}]T)Z|z([\p{Pc}\p{Pd}](Latn|Cyrl))?|s[\p{Pc}\p{Pd}]IN|r[\p{Pc}\p{Pd}](TN|S[ADY]|OM|L[BY]|KW|JO|IQ|EG|DZ|[AY]E)|m[\p{Pc}\p{Pd}]ET|r[\p{Pc}\p{Pd}]BH|k[\p{Pc}\p{Pd}]GH|r[\p{Pc}\p{Pd}][MQ]A|f([\p{Pc}\p{Pd}][NZ]A)?|sa?|r|m|k)|tzm[\p{Pc}\p{Pd}]Latn|s(hi([\p{Pc}\p{Pd}](Tfng|Latn))?|r([\p{Pc}\p{Pd}](Latn|Cyrl))?|eh|v|q|o|l|k|i|g)|z(h([\p{Pc}\p{Pd}]Han[st])?|u)|u(z([\p{Pc}\p{Pd}](Latn|Cyrl))?|r|k)|uz[\p{Pc}\p{Pd}]Arab|p(a([\p{Pc}\p{Pd}]Arab)?|[lst])|k(k([\p{Pc}\p{Pd}]Cyrl)?|ea|ab?|[lmo])|pa[\p{Pc}\p{Pd}]Guru|h(a([\p{Pc}\p{Pd}]Latn)?|[eiruy])|(mfe[\p{Pc}\p{Pd}]M|ru[\p{Pc}\p{Pd}]R|hu[\p{Pc}\p{Pd}]H)U|(kea[\p{Pc}\p{Pd}]C|lv[\p{Pc}\p{Pd}]L)V|e(s[\p{Pc}\p{Pd}](419|U[SY]|SV|P[AERY]|MX|G[QT]|E[CS]|C[LOR])|s[\p{Pc}\p{Pd}]NI|n[\p{Pc}\p{Pd}](Z[AW]|VI|U[MS]|P[HK]|N[AZ]|M[HPTU]|I[ELN]|G[BU]|B[EWZ]|A[SU])|s[\p{Pc}\p{Pd}]AR|l[\p{Pc}\p{Pd}]GR|o)|c(hr[\p{Pc}\p{Pd}]US|y[\p{Pc}\p{Pd}]GB|a[\p{Pc}\p{Pd}]ES)|(ses|khq)[\p{Pc}\p{Pd}]ML|(bem[\p{Pc}\p{Pd}]Z|my[\p{Pc}\p{Pd}]M|hy[\p{Pc}\p{Pd}]A|fr[\p{Pc}\p{Pd}]K|en[\p{Pc}\p{Pd}]J)M|ti[\p{Pc}\p{Pd}]E[RT]|ne[\p{Pc}\p{Pd}]NP|ja[\p{Pc}\p{Pd}]JP|so[\p{Pc}\p{Pd}]DJ|f(r[\p{Pc}\p{Pd}](T[DG]|R[EW]|M[CFGLQ]|LU|G[ANPQ]|DJ|C[ADF-IM]|B[EFIJL])|a[\p{Pc}\p{Pd}]AF)|(s(v[\p{Pc}\p{Pd}]F|l[\p{Pc}\p{Pd}]S)|fi[\p{Pc}\p{Pd}]F)I|(tr[\p{Pc}\p{Pd}]T|pt[\p{Pc}\p{Pd}]B|ko[\p{Pc}\p{Pd}]K|hr[\p{Pc}\p{Pd}]H|f(r[\p{Pc}\p{Pd}]F|a[\p{Pc}\p{Pd}]I))R|d(e[\p{Pc}\p{Pd}]L[IU]|a[\p{Pc}\p{Pd}]DK)|(kw|gv)[\p{Pc}\p{Pd}]GB|(gl|eu)[\p{Pc}\p{Pd}]ES|(r[ou][\p{Pc}\p{Pd}]M|id[\p{Pc}\p{Pd}]I)D|(sq[\p{Pc}\p{Pd}]A|pl[\p{Pc}\p{Pd}]P|nl[\p{Pc}\p{Pd}]N|kl[\p{Pc}\p{Pd}]G|he[\p{Pc}\p{Pd}]I)L|(ms[\p{Pc}\p{Pd}]M|el[\p{Pc}\p{Pd}]C)Y|b(n[\p{Pc}\p{Pd}]BD|m[\p{Pc}\p{Pd}]ML|e[\p{Pc}\p{Pd}]BY)|(so[\p{Pc}\p{Pd}]E|pt[\p{Pc}\p{Pd}]P|om[\p{Pc}\p{Pd}]E|mt[\p{Pc}\p{Pd}]M|lt[\p{Pc}\p{Pd}]L|it[\p{Pc}\p{Pd}]I|en[\p{Pc}\p{Pd}]T|de[\p{Pc}\p{Pd}]A)T|t(zm|eo?|r|o|i|h|a)|n(aq|[bdeln])|m(fe|as|[gksty])|k(ok|n)|g(sw|u|a)|f(il?|[or]|f|a)|saq|mer|lu[oy]|k(ln|am|i)|guz|ebu|d(av?|e)|haw|nyn|xog|c(hr|gg|[sy]|a)|ses|khq|b(em?|[gm-os])|vun|r(wk|of)|lag|kde|jmc|bez|vi|r[ouw]|om|sn|sw|l[tv]|ja|yo|i[dgist]|or|m[lr]|rm|e[elnst]|kw|gv|lg|gl|eu)\b
                    name: support.type.locale.trin
                  - match: \b\w+([\p{Pc}\p{Pd}]\w+)*\b
                    name: support.type.locale.custom.trin
          - begin: (\($)\s*(\p{L}+)\s*(:)?
            end: \s*(\))
            name: meta.group.script.trin
            captures:
              1: {name: punctuation.definition.group.flag.trin}
              3: {name: punctuation.separator.colon.trin}
              2:
                patterns:
                  - match: (?i)\b(Z(zzz|yyy|sy[em])|Visp|T(ha[ai]|al[eu])|S(yr[cejn]|og[do]|in[dh])|Qa[a-z][a-z]|(Zxx|Xsu)x|Ph(nx|l[ipv])|M(e(r[co]|df)|an[di])|Sar[ab]|L(in[ab]|at[fgn])|(Wol|Osg|Lek)e|(Ran|Mah)j|K(ore|hoj)|(Pau|Mar|Lep)c|Jurc|S(ha|gn)w|H(mn[gp]|luw|an[bgiost])|(Z(mt|in)|Vit|Tir|Ork)h|G(o(th|n[gm])|eo[kr])|Egy[dhp]|(Tam|Kpe|Ita)l|(Tns|Sor|O(sm|ry)|New|Ma[ky]|L(om|an)|K(nd|an)|Jav|War|Hir|Elb)a|D(upl|eva)|Kit[ls]|(P(si|cu)|Moo|Jpa|Gra)n|(Uga|Tak|Sa[mu]|Run|Mym|Kh[am]|H(eb|at)|Guj|Oug|Dog)r|C(yr[ls]|pmn|her)|(S(un|id|hr)|P(lr|iq)|Nan|Men)d|(Xpe|Wch|Tot|S(yl|oy)|Ror|Nko|Mro|Lao|Jam)o|(T(gl|en|an)|Roh|Pha|Mon|Gla)g|(Tf|Rj|Hu)ng|(Ind|C(hr|an))s|(Tel|Nsh|Lis|Gur)u|(Y(ez|ii)|Vai|Shu|Prt|M(te|od)|Ly[cd]|Kal|Kth|Eth|Car)i|B(uhd|ra[hi]|opo|eng|(li|hk)s|ugi|a(ss|mu|li))|(T(ib|av)|Nba|Mul|Hrk|Dsr|C(pr|op|ir))t|(Zan|Tag|N(k[dg]|ar)|Lim)b|(Olc|Gre|Bat)k|Diak|(P(e[lr]|al)|Oga|Mly|Ely|C(ha|ak))m|A(vst|r(m[in]|a[bn])|ghb|fak|hom|dlm))\b
                    name: support.type.script.trin
                  - match: \w+
                    name: support.type.script.custom.trin
    patterns:
      - include: "#string-escapes"
      - include: "#unicode-scripts"
      - include: "#regexp-patterns"

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"
      - include: "#variable-names"

  class-names:
    comment: Names for built-in classes
    patterns:
      - comment:

  type-names:
    comment: Names for built-in types
    patterns:
      - comment: Primitive classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Bool|[NR]at|Real|Num|(Big)?(U?Int|Float|Nat)
          |Imaginary|Complex|Char|Rune|Str|Sym
          |U?Int(8|16|32|64|128)
          |[CI]?Float(16|32|64|128)
          |[UI](8|16|32|64|128)
          |[CI]?F(16|32|64|128)
          )\b
        name: support.type.builtin.primitive.trin
      - comment: Data structure classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          Array|Tuple|(Mut)?(List|Set|Map)|Dict|Func|Iter
          |Proc|Seq|Gen|Range|Stack|Heap|Queue|Tree|Trie
          |Future|Stream|RegExp?|Func|Buf|StrBuf|Bytes
          )\b
        name: support.type.builtin.trin
      - comment: Constant/algebraic classes
        match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(
          True|False|Null|Void|NaN|Infin|Empty|Unit
          |Any|Mixed|Just|Some|None|Never|Const|(Im)?pure
          |Class|Enum|Mod|Pkg|Inter|Struct|Obj|Rec
          |Frag|Nspace|Data|Trait|Proto|Proc|Macro|Type|Given
          |Raw|Style|Comp|Elem|Decl|Ext|Impl|Sub|Chan
          )\b
        name: support.type.primitive.trin

      - comment: Interface classes | IEnumerable, etc
        match: \s*\bI((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.interface.trin
      - comment: Namespace classes | NSString, etc
        match: \s*\bNS((\p{Lu}[\w&&\P{Lu}]*)+)\b
        name: entity.name.namespace.trin
      - comment: Error classes | BaseError, etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)?(Error|Exception)\b
        name: support.class.error.trin
      - comment: Trait classes | Serializable, Loggable etc
        match: \s*\b((\p{Lu}[\w&&\P{Lu}]*)+)able\b
        name: support.class.trait.trin

  function-names:
    comment: Names for built-in functions (initial dump)
    patterns:
      - comment: isName functions
        match: (?x)\s*\bis(\p{Lu}[\w&&\P{Lu}]*)+\b\s*
        name: support.function.predicate.trin
      - comment: magic functions
        match: (?x)\s*\b_+([\p{Pc}\p{L}]\w*)+_+\b\s*
        name: support.function.magic.trin

  constant-names:
    comment: Names for constants, symbols and static properties
    patterns: []

  variable-names:
    comment: Standard Library variable names
    patterns: []

  property-names:
    comment: Standard Library property names
    patterns: []

  literals:
    patterns:
      - include: "#regexps"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#symbols"
      - include: "#numbers"
      - include: "#constants"

  constants:
    patterns:
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (true)|(false)|(null)|(void)|(nan)|(infin)
          )\b\s*
        captures:
          1: {name: constant.language.boolean.true.trin}
          2: {name: constant.language.boolean.false.trin}
          3: {name: constant.language.null.trin}
          4: {name: constant.language.undefined.trin}
          5: {name: constant.language.nan.trin}
          6: {name: constant.language.infinity.trin}
      - match: |
          (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(?:
          (it|this|that|super|self|target)
          |(params)
          |(ctor)
          |(prot)
          |(pro)
          )\b\s*
        captures:
          1: {name: variable.language.$1.trin}
          2: {name: variable.language.arguments.trin}
          3: {name: variable.language.constructor.trin}
          4: {name: variable.language.prototype.trin}
          5: {name: variable.language.proto.trin}

  numbers:
    patterns:
      - match: (?<=(^|[({\[])\s*\d\w*)\.
        name: punctuation.separator.decimal.period.trin
      - match: (?<=(?:^|[({\[])\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.trin
      - match: (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:_*\p{Alnum}+)*)
          (?:(\.)(?:\p{Alnum}+(?:_*\p{Alnum}+)*)?)?
          (?:([*/])\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          ((?:[2-9]|[1-9]\d+)b)
          (?:\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (?:(\.)(?:\p{Alnum}+(?:_*\p{Alnum}+)*)?)
          (?:([*/])\p{Alnum}+(?:_*\p{Alnum}+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.arbitrary-radix.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0b)
          (?:[01]+(?:_*[01]+)*)
          (?:(\.)(?:[01]+(?:_*[01]+)*)?)?
          (?:([*/])[01]+(?:_*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0b)
          (?:[01]+(?:_*[01]+)*)?
          (?:(\.)(?:[01]+(?:_*[01]+)*)?)
          (?:([*/])[01]+(?:_*[01]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.binary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:_*[0-3]+)*)
          (?:(\.)(?:[0-3]+(?:_*[0-3]+)*)?)?
          (?:([*/])[0-3]+(?:_*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0q)
          (?:[0-3]+(?:_*[0-3]+)*)?
          (?:(\.)(?:[0-3]+(?:_*[0-3]+)*)?)
          (?:([*/])[0-3]+(?:_*[0-3]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.quaternary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:_*[0-5]+)*)
          (?:(\.)(?:[0-5]+(?:_*[0-5]+)*)?)?
          (?:([*/])[0-5]+(?:_*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0s)
          (?:[0-5]+(?:_*[0-5]+)*)?
          (?:(\.)(?:[0-5]+(?:_*[0-5]+)*)?)
          (?:([*/])[0-5]+(?:_*[0-5]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.senary.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:_*[0-7]+)*)
          (?:(\.)(?:[0-7]+(?:_*[0-7]+)*)?)?
          (?:([*/])[0-7]+(?:_*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0o)
          (?:[0-7]+(?:_*[0-7]+)*)?
          (?:(\.)(?:[0-7]+(?:_*[0-7]+)*)?)
          (?:([*/])[0-7]+(?:_*[0-7]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.octal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:_*[\dab]+)*)
          (?:(\.)(?:[\dab]+(?:_*[\dab]+)*)?)?
          (?:([*/])[\dab]+(?:_*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0z)
          (?:[\dab]+(?:_*[\dab]+)*)?
          (?:(\.)(?:[\dab]+(?:_*[\dab]+)*)?)
          (?:([*/])[\dab]+(?:_*[\dab]+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.duodecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0x)
          (?:\h+(?:_*\h+)*)
          (?:(\.)(?:\h+(?:_*\h+)*)?)?
          (?:([*/])\h+(?:_*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (0x)
          (?:\h+(?:_*\h+)*)?
          (?:(\.)(?:\h+(?:_*\h+)*)?)
          (?:([*/])\h+(?:_*\h+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.hexadecimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          ()
          (?:\d+(?:_*\d+)*)
          (?:(\.)(?:\d+(?:_*\d+)*)?)?
          (?:([*/])\d+(?:_*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          ()
          (?:\d+(?:_*\d+)*)?
          (?:(\.)(?:\d+(?:_*\d+)*)?)
          (?:([*/])\d+(?:_*\d+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: constant.numeric.decimal.trin}
          1: {name: storage.type.numeric.trin}
          2: {name: punctuation.separator.decimal.period.trin}
          3: {name: constant.numeric.other.separator.trin}
          4: {name: constant.numeric.other.exponent.trin}
          5: {name: constant.numeric.other.density.trin}
          6: {name: storage.type.numeric.trin}
      - match: (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:_*\w+)*)
          (?:(\.)(?:\w+(?:_*\w+)*)?)?
          (?:([*/])\w+(?:_*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.trin}
      - match: (?ix)\s*\b
          (\d+\w)
          (?:\w+(?:_*\w+)*)?
          (?:(\.)(?:\w+(?:_*\w+)*)?)
          (?:([*/])\w+(?:_*\w+)*)?
          (\^(?:\d|[1-9]\d+)?[+-]?\d+)?
          (=(?:\d|[1-9]\d+))?
          (:[\p{Pc}\p{L}]\w*)?
          \b\s*
        captures:
          0: {name: invalid.illegal.numeric.trin}

  strings-quoted:
    patterns:
      - comment: single quoted raw string
        begin: (?<!'+)\s*('''+)
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: (?<!'+)\s*(')
        contentName: string.quoted.single.trin
        end: \s*((\1)(?!'+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - match: "''"
            name: constant.character.escape.trin
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: (?<!"+)\s*("""+|")
        contentName: string.quoted.double.trin
        end: \s*((\1)(?!"+))
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#string-content"

  strings-unquoted:
    patterns:
      - begin: |
          (?x)\s*
          (\\\|)\s*
          ([-+*<=>])?\s*
          (?:(\d\w*)|
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.trin}
          5:
            patterns:
              - include: "#line-comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.trin
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.trin
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
          - include: $self
      - begin: |
          (?x)\s*
          (\\\>)\s*
          ([-+*<=>])?\s*
          (?:(\d\w*)|
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3: {patterns: [include: "#numbers"]}
          4: {name: fenced_code.block.language.trin}
          5:
            patterns:
              - include: "#line-comments"
              - match: .+
                name: invalid.illegal.syntax.trin
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.trin
            patterns:
              - include: "#string-content"
              - include: text.html.markdown#inline
          - include: $self
      - match: |
          (?x)
          \s*(\\)
          ((?:\\.|[^({\[)}\]\s.,:;])*?)
          (?=[({\[)}\]\s.,:;]|$)\s*
        name: string.unquoted.trin
        captures:
          1: {name: punctuation.definition.string.trin}
          2: {patterns: [include: "#string-content"]}

  string-content:
    patterns:
      - include: "#string-escapes"
      - include: "#embedded"

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.trin
      - comment: Binary escape sequences
        match: (?i)\\b0*(1(0(0(0(0[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1(0(0(0(0([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1)?|1[01][01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]|1)?|0)
        name: constant.character.escape.binary.trin
      - comment: Binary escape sequences
        begin: (?i)\\b{
        end: "}"
        name: constant.character.escape.binary.trin
        patterns:
          - match: \b0*(1(0(0(0(0[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1(0(0(0(0([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1)?|1[01][01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]|1)?|0)\b
            name: constant.character.escape.binary.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Quaternary escape sequences
        match: (?i)\\q0*(1(0(0[0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|1(0(0([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?)?|[23][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[23][0-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[23]|0)
        name: constant.character.escape.quaternary.trin
      - comment: Quaternary escape sequences
        begin: (?i)\\q{
        end: "}"
        name: constant.character.escape.quaternary.trin
        patterns:
          - match: \b0*(1(0(0[0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|1(0(0([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?)?|[23][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[23][0-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[23]|0)\b
            name: constant.character.escape.quaternary.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Senary escape sequences
        match: (?i)\\s0*(355135(3[01]|[45])|355135[0-2][0-5]|3551(3[0-4]|[45])[0-5][0-5]|355(1[0-2]|[2-5])[0-5][0-5][0-5]|3550[0-5][0-5][0-5][0-5]|35[0-4][0-5][0-5][0-5][0-5][0-5]|(3[0-4]|[45])[0-5][0-5][0-5][0-5][0-5][0-5]|[12][0-5][0-5][0-5][0-5][0-5][0-5][0-5]|3(5(5(1(3(53?)?)?)?)?|55135[0-2]|551(3[0-4]|[45])[0-5]?|55(1[0-2]|[2-5])([0-5][0-5]?)?|550([0-5]([0-5][0-5]?)?)?|5[0-4]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|(3[0-4]|[45])([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|[12]([0-5]([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?)?|0)
        name: constant.character.escape.senary.trin
      - comment: Senary escape sequences
        begin: (?i)\\s{
        end: "}"
        name: constant.character.escape.senary.trin
        patterns:
          - match: \b0*(355135(3[01]|[45])|355135[0-2][0-5]|3551(3[0-4]|[45])[0-5][0-5]|355(1[0-2]|[2-5])[0-5][0-5][0-5]|3550[0-5][0-5][0-5][0-5]|35[0-4][0-5][0-5][0-5][0-5][0-5]|(3[0-4]|[45])[0-5][0-5][0-5][0-5][0-5][0-5]|[12][0-5][0-5][0-5][0-5][0-5][0-5][0-5]|3(5(5(1(3(53?)?)?)?)?|55135[0-2]|551(3[0-4]|[45])[0-5]?|55(1[0-2]|[2-5])([0-5][0-5]?)?|550([0-5]([0-5][0-5]?)?)?|5[0-4]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|(3[0-4]|[45])([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|[12]([0-5]([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?)?|0)\b
            name: constant.character.escape.senary.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Octal escape sequences
        match: (?i)\\o0*((4[01]|[5-7])[0-7][0-7][0-7][0-7][0-7]|[1-3][0-7][0-7][0-7][0-7][0-7][0-7]|(4[01]|[5-7])([0-7]([0-7]([0-7][0-7]?)?)?)?|[1-3]([0-7]([0-7]([0-7]([0-7][0-7]?)?)?)?)?|4[2-7][0-7][0-7][0-7][0-7]|4([2-7]([0-7]([0-7][0-7]?)?)?)?|0)
        name: constant.character.escape.octal.trin
      - comment: Octal escape sequences
        begin: (?i)\\o{
        end: "}"
        name: constant.character.escape.octal.trin
        patterns:
          - match: \b0*((4[01]|[5-7])[0-7][0-7][0-7][0-7][0-7]|[1-3][0-7][0-7][0-7][0-7][0-7][0-7]|(4[01]|[5-7])([0-7]([0-7]([0-7][0-7]?)?)?)?|[1-3]([0-7]([0-7]([0-7]([0-7][0-7]?)?)?)?)?|4[2-7][0-7][0-7][0-7][0-7]|4([2-7]([0-7]([0-7][0-7]?)?)?)?|0)\b
            name: constant.character.escape.octal.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Decimal escape sequences
        match: (?i)\\d?0*(1(1(1(4(1(1[01]|[2-9])|(10|[2-9])\d)|(40|[5-9])\d\d)|(1[0-3]|[2-9])\d\d\d)|(10|[2-9])\d\d\d\d|0\d\d\d\d\d)|1(1(1(4(11?)?)?)?|114(10|[2-9])|11(40|[5-9])\d?|1(1[0-3]|[2-9])(\d\d?)?|(10|[2-9])(\d(\d\d?)?)?|0(\d(\d(\d\d?)?)?)?)?|[2-9]\d\d\d\d\d|[2-9](\d(\d(\d\d?)?)?)?|0)
        name: constant.character.escape.decimal.trin
      - comment: Decimal escape sequences
        begin: (?i)\\d?{
        end: "}"
        name: constant.character.escape.decimal.trin
        patterns:
          - match: \b0*(1(1(1(4(1(1[01]|[2-9])|(10|[2-9])\d)|(40|[5-9])\d\d)|(1[0-3]|[2-9])\d\d\d)|(10|[2-9])\d\d\d\d|0\d\d\d\d\d)|1(1(1(4(11?)?)?)?|114(10|[2-9])|11(40|[5-9])\d?|1(1[0-3]|[2-9])(\d\d?)?|(10|[2-9])(\d(\d\d?)?)?|0(\d(\d(\d\d?)?)?)?)?|[2-9]\d\d\d\d\d|[2-9](\d(\d(\d\d?)?)?)?|0)\b
            name: constant.character.escape.decimal.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Duodecimal escape sequences
        match: (?i)\\z0*(4588(a[0-7]|b)|458(8\d|[9ab])[\dab]|45(8[0-7]|[9ab])[\dab][\dab]|4(5[0-7]|[6-9ab])[\dab][\dab][\dab]|(4[0-4]|[5-9ab])[\dab][\dab][\dab][\dab]|[1-3][\dab][\dab][\dab][\dab][\dab]|4(5(8(8a?)?)?|58(8\d|[9ab])|5(8[0-7]|[9ab])[\dab]?|(5[0-7]|[6-9ab])([\dab][\dab]?)?)?|(4[0-4]|[5-9ab])([\dab]([\dab][\dab]?)?)?|[1-3]([\dab]([\dab]([\dab][\dab]?)?)?)?|0)
        name: constant.character.escape.duodecimal.trin
      - comment: Duodecimal escape sequences
        begin: (?i)\\z{
        end: "}"
        name: constant.character.escape.duodecimal.trin
        patterns:
          - match: \b0*(4588(a[0-7]|b)|458(8\d|[9ab])[\dab]|45(8[0-7]|[9ab])[\dab][\dab]|4(5[0-7]|[6-9ab])[\dab][\dab][\dab]|(4[0-4]|[5-9ab])[\dab][\dab][\dab][\dab]|[1-3][\dab][\dab][\dab][\dab][\dab]|4(5(8(8a?)?)?|58(8\d|[9ab])|5(8[0-7]|[9ab])[\dab]?|(5[0-7]|[6-9ab])([\dab][\dab]?)?)?|(4[0-4]|[5-9ab])([\dab]([\dab][\dab]?)?)?|[1-3]([\dab]([\dab]([\dab][\dab]?)?)?)?|0)\b
            name: constant.character.escape.duodecimal.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - comment: Hexadecimal escape sequences
        match: (?i)\\x0*(1(0\h\h\h\h|[1-9a-f]\h\h\h)|1(0(\h(\h\h?)?)?|[1-9a-f](\h\h?)?)?|[2-9a-f]\h\h\h\h|[2-9a-f](\h(\h\h?)?)?|0)
        name: constant.character.escape.hexadecimal.trin
      - comment: Hexadecimal escape sequences
        begin: (?i)\\x{
        end: "}"
        name: constant.character.escape.hexadecimal.trin
        patterns:
          - match: \b0*(1(0\h\h\h\h|[1-9a-f]\h\h\h)|1(0(\h(\h\h?)?)?|[1-9a-f](\h\h?)?)?|[2-9a-f]\h\h\h\h|[2-9a-f](\h(\h\h?)?)?|0)\b
            name: constant.character.escape.hexadecimal.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - match: (?i)\\u\h{0,8}
        name: constant.character.escape.unicode.trin
      - begin: (?i)\\u{
        end: \s*}
        name: constant.character.escape.unicode.trin
        patterns:
          - match: \b\h{0,8}\b
            name: constant.character.escape.unicode.trin
          - match: \w+
            name: invalid.illegal.unknown-escape.trin
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.trin
        patterns:
          - include: "#unicode-named-chars"
      - match: (?i)\\[a-z&&[^bqsodzxu]]
        name: constant.character.escape.trin
      - match: (?x)\\[\p{S}\p{P}]
        name: constant.character.escape.symbol.trin
      - match: (?x)\\\p{Z}
        name: constant.character.escape.other.trin
      - match: (?x)\\[\p{L}\p{N}\p{C}]
        name: invalid.illegal.unknown-escape.trin

  embedded:
    patterns:
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2: {name: storage.type.format.trin}
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [include: $self]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: $self
      - begin: (\$<)\s*
        end: (>)
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: "#tag-attributes"
          - include: "#tag-names"

  embedded-raw:
    patterns:
      - match: ([$%#])\1
        name: constant.character.escape.trin
      - match: (\#)([+-]?\d+)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {name: constant.numeric.decimal.trin}
      - match: (\#)([?*&~%$]?[\p{Pc}\p{L}]\w*)
        captures:
          1: {name: punctuation.definition.anchor.trin}
          2: {patterns: [include: "#placeholder-variables"]}
      - match: (%)((\w|\\.)+(([^\s'"`\\\[\](){}<>]|\\.)*(\w|\\.)+)?)
        captures:
          1: {name: punctuation.definition.directive.trin}
          2: {name: storage.type.format.trin}
      - match: |
          (?xi)
          (\$)# prefix
          (
          [\p{Pc}\p{L}]\w*
          (?:(?:[?!]?\.|[?!:]:)
          (?:(?:[\p{Pc}\p{L}]\w*)))*
          )# variable
        captures:
          1: {name: punctuation.section.embedded.trin}
          2: {patterns: [include: $self]}
      - begin: (\${)\s*
        end: (})
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: $self
      - begin: (\$<)\s*
        end: (>)
        name: entity.quasi.element.trin
        captures:
          1: {name: punctuation.section.embedded.trin}
        patterns:
          - include: "#tag-attributes"
          - include: "#tag-names"

  symbols:
    match: |
      (?x)
      \s*
      (:)((?:\w|\\.)(?:\\.|[^({\[)}\]\s.,:;])*?)
      (?=[({\[)}\]\s.,:;]|$)\s*
    name: meta.symbol.trin
    captures:
      1: {name: punctuation.definition.symbol.trin}
      2: {name: constant.other.symbol.trin}

  labels:
    match: |
      (?x)
      (?<=^|[({\[\s,;*+-])\s*
      ((?:\w|\\.)(?:\\.|[^({\[)}\]\s.,:;])*?)
      (:)\s+
    name: meta.object-literal.key.trin
    captures:
      1:
        name: constant.other.object.key.trin
        patterns: [include: "#string-escapes"]
      2: {name: punctuation.separator.key-value.trin}

  regexps:
    patterns:
      - begin: (\p{Alnum}*)(`)\s*
        end: \s*(?!\\)(`(?!`))(\p{Alnum}*)
        contentName: string.pattern.regexp.trin
        beginCaptures:
          1: {name: keyword.modifier.trin}
          2: {name: punctuation.section.regexp.begin.trin}
        endCaptures:
          1: {name: punctuation.section.regexp.end.trin}
          2: {name: keyword.other.flag.trin}
        patterns:
          - include: "#comments"
          - include: "#regexp-patterns"
          - begin: (`)(`)\s*\n?
            end: \s*(?=(?!\\)`)
            contentName: string.replace.regexp.trin
            beginCaptures:
              1: {name: punctuation.section.regexp.end.trin}
              2: {name: punctuation.section.regexp.begin.trin}
            patterns:
              - include: "#back-references"
      - begin: |
          (?x)\s*
          (\\\<)\s*
          ([-+*<=>])?\s*
          (?:(\w+)?\b\s*\b
          (
          \w+\s*
          (?:[+-]\s*
          (?:(?:\w+)))*
          )
          )?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.trin}
          2: {name: storage.modifier.chomping-indicator.trin}
          3: {name: keyword.modifier.trin}
          4: {name: keyword.other.flag.trin}
          5:
            patterns:
              - include: "#line-comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.trin
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^((\s)+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.out.trin
            patterns:
              - include: "#regexp-patterns"
          - include: $self

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.trin
      - match: \${2}
        name: constant.character.escape.trin
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.trin
        beginCaptures:
          1: {name: keyword.other.back-reference.trin}
        endCaptures:
          1: {name: keyword.other.back-reference.trin}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-content"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - include: "#strings-quoted"
      - match: \|
        name: keyword.operator.or.trin
      - match: \&
        name: keyword.operator.match.trin
      - match: \!
        name: keyword.operator.disjunction.trin
      - match: \.
        name: constant.character.all.trin
      - match: (?i)\\[by]({\p{Alpha}+})?
        name: keyword.control.anchor.trin
      - match: (?i)(\^|\\<|\\a(?:{\p{Alpha}+})?)|(\$|\\>|\\z(?:{\p{Alpha}+})?)
        captures:
          1: {name: keyword.control.begin.trin}
          2: {name: keyword.control.end.trin}
      - match: (\\\()(?:(\?)|(\+)|([*/]))
        captures:
          1: {name: constant.character.escape.other.trin}
          2: {name: keyword.operator.quantifier.lazy.trin}
          3: {name: keyword.operator.quantifier.eager.trin}
          4: {name: keyword.operator.quantifier.greedy.trin}
      - match: \\\d+
        name: keyword.other.back-reference.trin
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.trin
      - begin: (\\Q)
        contentName: string.quoted.single.trin
        end: (\\E)
        name: string.quoted.raw.trin
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#string-content"
      - begin: (\\q)
        contentName: string.quoted.double.trin
        end: (\\e)
        name: string.quoted.trin
        captures:
          1: {name: punctuation.definition.string.trin}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.trin
        beginCaptures:
          1: {name: keyword.other.back-reference.trin}
        endCaptures:
          1: {name: keyword.other.back-reference.trin}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.trin
        beginCaptures:
          1: {name: keyword.other.subroutine.trin}
        endCaptures:
          1: {name: keyword.other.subroutine.trin}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regexp-groups"
      - include: "#regexp-char-set"
      - include: "#regexp-char-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.trin}
          2: {name: keyword.control.keepout.trin}
          3: {name: keyword.control.search.trin}
          4: {name: constant.character.unicode.trin}
      - match: (?<=[^\\][*+?}])(?:(\?)|(\+)|([*/]))
        captures:
          1: {name: keyword.operator.modifier.lazy.trin}
          2: {name: keyword.operator.modifier.eager.trin}
          3: {name: keyword.operator.modifier.greedy.trin}
      - match: (\?)|(\+)|([*/])
        captures:
          1: {name: keyword.operator.quantifier.lazy.trin}
          2: {name: keyword.operator.quantifier.eager.trin}
          3: {name: keyword.operator.quantifier.greedy.trin}
      - match: \\.
        name: constant.character.escape.other.trin

    repository:
      regexp-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.trin
            captures:
              0: {name: punctuation.section.expression.trin}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.trin
            end: \s*(\))
            name: comment.block.regexp.trin
            captures:
              1: {name: punctuation.definition.comment.trin}
            patterns:
              - match: \\.
                name: comment.block.regexp.trin
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.look-ahead.trin
            captures:
              1: {name: punctuation.definition.group.look-ahead.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.look-behind.trin
            captures:
              1: {name: punctuation.definition.group.look-behind.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.negative-look-ahead.trin
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.negative-look-behind.trin
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{Lower}+(?:[+-]\p{Lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.flag.trin
            captures:
              0: {name: punctuation.definition.group.flag.trin}
              1: {name: punctuation.definition.group.flag.trin}
              2: {name: entity.name.function.method.trin}
              3: {name: keyword.control.recursion.trin}
              4: {name: keyword.other.flag.trin}
              5: {name: punctuation.separator.colon.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.call-out.trin
            captures:
              1: {name: punctuation.definition.group.call-out.trin}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.trin
                captures:
                  1: {name: punctuation.definition.group.call-out.trin}
                  2: {name: keyword.operator.range.trin}
                  3: {name: punctuation.definition.tag.trin}
                  4: {patterns: [include: "#function-entities"]}
                  5: {name: punctuation.definition.tag.trin}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.atomic.trin
            captures:
              1: {name: punctuation.definition.group.atomic.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.non-capturing.trin
            captures:
              1: {name: punctuation.definition.group.non-capturing.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.branch.trin
            captures:
              1: {name: punctuation.definition.group.branch.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.absent.trin
            captures:
              1: {name: punctuation.definition.group.absent.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([\p{Pc}\p{L}]\w*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.back-reference.trin
            captures:
              0: {name: punctuation.definition.group.back-reference.trin}
              1: {name: punctuation.definition.group.back-reference.trin}
              2: {name: entity.name.function.method.trin}
              3: {name: variable.other.trin}
              4: {name: punctuation.separator.colon.trin}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.named.trin
            beginCaptures:
              0: {name: punctuation.definition.group.named.trin}
              1: {patterns: [include: "#variables"]}
            endCaptures:
              0: {name: punctuation.definition.group.named.trin}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.trin
                beginCaptures:
                  1: {name: punctuation.definition.group.named.trin}
                endCaptures:
                  1: {name: punctuation.definition.group.named.trin}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            name: meta.group.trin
            captures:
              0: {name: punctuation.definition.group.trin}
            patterns:
              - include: "#regexp-patterns"

      regexp-char-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.trin
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.trin
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.trin
            patterns:
              - include: "#unicode-named-chars"
          - comment: Binary escape sequences
            match: (?i)\\b0*(1(0(0(0(0[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1(0(0(0(0([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1)?|1[01][01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]|1)?|0)
            name: constant.character.escape.binary.trin
          - comment: Binary escape sequences
            begin: (?i)\\b{
            end: "}"
            name: constant.character.escape.binary.trin
            patterns:
              - match: \b0*(1(0(0(0(0[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01]|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1[01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01][01])|1(0(0(0(0([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1)?|1[01][01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01]([01][01]?)?)?)?)?)?)?)?)?)?)?)?)?)?)?|1[01]|1)?|0)\b
                name: constant.character.escape.binary.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Quaternary escape sequences
            match: (?i)\\q0*(1(0(0[0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|1(0(0([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?)?|[23][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[23][0-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[23]|0)
            name: constant.character.escape.quaternary.trin
          - comment: Quaternary escape sequences
            begin: (?i)\\q{
            end: "}"
            name: constant.character.escape.quaternary.trin
            patterns:
              - match: \b0*(1(0(0[0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|[1-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3])|1(0(0([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[1-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?)?|[23][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3][0-3]|[23][0-3]([0-3]([0-3]([0-3]([0-3]([0-3]([0-3][0-3]?)?)?)?)?)?)?|[23]|0)\b
                name: constant.character.escape.quaternary.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Senary escape sequences
            match: (?i)\\s0*(355135(3[01]|[45])|355135[0-2][0-5]|3551(3[0-4]|[45])[0-5][0-5]|355(1[0-2]|[2-5])[0-5][0-5][0-5]|3550[0-5][0-5][0-5][0-5]|35[0-4][0-5][0-5][0-5][0-5][0-5]|(3[0-4]|[45])[0-5][0-5][0-5][0-5][0-5][0-5]|[12][0-5][0-5][0-5][0-5][0-5][0-5][0-5]|3(5(5(1(3(53?)?)?)?)?|55135[0-2]|551(3[0-4]|[45])[0-5]?|55(1[0-2]|[2-5])([0-5][0-5]?)?|550([0-5]([0-5][0-5]?)?)?|5[0-4]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|(3[0-4]|[45])([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|[12]([0-5]([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?)?|0)
            name: constant.character.escape.senary.trin
          - comment: Senary escape sequences
            begin: (?i)\\s{
            end: "}"
            name: constant.character.escape.senary.trin
            patterns:
              - match: \b0*(355135(3[01]|[45])|355135[0-2][0-5]|3551(3[0-4]|[45])[0-5][0-5]|355(1[0-2]|[2-5])[0-5][0-5][0-5]|3550[0-5][0-5][0-5][0-5]|35[0-4][0-5][0-5][0-5][0-5][0-5]|(3[0-4]|[45])[0-5][0-5][0-5][0-5][0-5][0-5]|[12][0-5][0-5][0-5][0-5][0-5][0-5][0-5]|3(5(5(1(3(53?)?)?)?)?|55135[0-2]|551(3[0-4]|[45])[0-5]?|55(1[0-2]|[2-5])([0-5][0-5]?)?|550([0-5]([0-5][0-5]?)?)?|5[0-4]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|(3[0-4]|[45])([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?|[12]([0-5]([0-5]([0-5]([0-5]([0-5][0-5]?)?)?)?)?)?|0)\b
                name: constant.character.escape.senary.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Octal escape sequences
            match: (?i)\\o0*((4[01]|[5-7])[0-7][0-7][0-7][0-7][0-7]|[1-3][0-7][0-7][0-7][0-7][0-7][0-7]|(4[01]|[5-7])([0-7]([0-7]([0-7][0-7]?)?)?)?|[1-3]([0-7]([0-7]([0-7]([0-7][0-7]?)?)?)?)?|4[2-7][0-7][0-7][0-7][0-7]|4([2-7]([0-7]([0-7][0-7]?)?)?)?|0)
            name: constant.character.escape.octal.trin
          - comment: Octal escape sequences
            begin: (?i)\\o{
            end: "}"
            name: constant.character.escape.octal.trin
            patterns:
              - match: \b0*((4[01]|[5-7])[0-7][0-7][0-7][0-7][0-7]|[1-3][0-7][0-7][0-7][0-7][0-7][0-7]|(4[01]|[5-7])([0-7]([0-7]([0-7][0-7]?)?)?)?|[1-3]([0-7]([0-7]([0-7]([0-7][0-7]?)?)?)?)?|4[2-7][0-7][0-7][0-7][0-7]|4([2-7]([0-7]([0-7][0-7]?)?)?)?|0)\b
                name: constant.character.escape.octal.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Decimal escape sequences
            match: (?i)\\d?0*(1(1(1(4(1(1[01]|[2-9])|(10|[2-9])\d)|(40|[5-9])\d\d)|(1[0-3]|[2-9])\d\d\d)|(10|[2-9])\d\d\d\d|0\d\d\d\d\d)|1(1(1(4(11?)?)?)?|114(10|[2-9])|11(40|[5-9])\d?|1(1[0-3]|[2-9])(\d\d?)?|(10|[2-9])(\d(\d\d?)?)?|0(\d(\d(\d\d?)?)?)?)?|[2-9]\d\d\d\d\d|[2-9](\d(\d(\d\d?)?)?)?|0)
            name: constant.character.escape.decimal.trin
          - comment: Decimal escape sequences
            begin: (?i)\\d?{
            end: "}"
            name: constant.character.escape.decimal.trin
            patterns:
              - match: \b0*(1(1(1(4(1(1[01]|[2-9])|(10|[2-9])\d)|(40|[5-9])\d\d)|(1[0-3]|[2-9])\d\d\d)|(10|[2-9])\d\d\d\d|0\d\d\d\d\d)|1(1(1(4(11?)?)?)?|114(10|[2-9])|11(40|[5-9])\d?|1(1[0-3]|[2-9])(\d\d?)?|(10|[2-9])(\d(\d\d?)?)?|0(\d(\d(\d\d?)?)?)?)?|[2-9]\d\d\d\d\d|[2-9](\d(\d(\d\d?)?)?)?|0)\b
                name: constant.character.escape.decimal.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Duodecimal escape sequences
            match: (?i)\\z0*(4588(a[0-7]|b)|458(8\d|[9ab])[\dab]|45(8[0-7]|[9ab])[\dab][\dab]|4(5[0-7]|[6-9ab])[\dab][\dab][\dab]|(4[0-4]|[5-9ab])[\dab][\dab][\dab][\dab]|[1-3][\dab][\dab][\dab][\dab][\dab]|4(5(8(8a?)?)?|58(8\d|[9ab])|5(8[0-7]|[9ab])[\dab]?|(5[0-7]|[6-9ab])([\dab][\dab]?)?)?|(4[0-4]|[5-9ab])([\dab]([\dab][\dab]?)?)?|[1-3]([\dab]([\dab]([\dab][\dab]?)?)?)?|0)
            name: constant.character.escape.duodecimal.trin
          - comment: Duodecimal escape sequences
            begin: (?i)\\z{
            end: "}"
            name: constant.character.escape.duodecimal.trin
            patterns:
              - match: \b0*(4588(a[0-7]|b)|458(8\d|[9ab])[\dab]|45(8[0-7]|[9ab])[\dab][\dab]|4(5[0-7]|[6-9ab])[\dab][\dab][\dab]|(4[0-4]|[5-9ab])[\dab][\dab][\dab][\dab]|[1-3][\dab][\dab][\dab][\dab][\dab]|4(5(8(8a?)?)?|58(8\d|[9ab])|5(8[0-7]|[9ab])[\dab]?|(5[0-7]|[6-9ab])([\dab][\dab]?)?)?|(4[0-4]|[5-9ab])([\dab]([\dab][\dab]?)?)?|[1-3]([\dab]([\dab]([\dab][\dab]?)?)?)?|0)\b
                name: constant.character.escape.duodecimal.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - comment: Hexadecimal escape sequences
            match: (?i)\\x0*(1(0\h\h\h\h|[1-9a-f]\h\h\h)|1(0(\h(\h\h?)?)?|[1-9a-f](\h\h?)?)?|[2-9a-f]\h\h\h\h|[2-9a-f](\h(\h\h?)?)?|0)
            name: constant.character.escape.hexadecimal.trin
          - comment: Hexadecimal escape sequences
            begin: (?i)\\x{
            end: "}"
            name: constant.character.escape.hexadecimal.trin
            patterns:
              - match: \b0*(1(0\h\h\h\h|[1-9a-f]\h\h\h)|1(0(\h(\h\h?)?)?|[1-9a-f](\h\h?)?)?|[2-9a-f]\h\h\h\h|[2-9a-f](\h(\h\h?)?)?|0)\b
                name: constant.character.escape.hexadecimal.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - match: (?i)\\u\h{0,8}
            name: constant.character.escape.unicode.trin
          - begin: (?i)\\u{
            end: \s*}
            name: constant.character.escape.unicode.trin
            patterns:
              - match: \b\h{0,8}\b
                name: constant.character.escape.unicode.trin
              - match: \w+
                name: invalid.illegal.unknown-escape.trin
          - match: (?i)\\([cm][a-z]|r)
            name: constant.character.control.trin
          - match: *posix-class
            name: constant.other.character-class.posix.trin
          - match: (?i)\\p(c[cfos]?|l[lmotu]?|m[cen]?|n[dlo]?|p[c-fios]?|s[ckmo]?|z[lps])
            name: constant.other.character-class.unicode.trin
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.trin
          - match: (?x)\\[dhlns-w]
            name: constant.other.character-class.trin
          - match: (?x)\\[DHLNS-W]
            name: constant.other.character-class.negated.trin
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.trin
          - match: (?i)\\[a-z&&[^bqsodzxu]]
            name: constant.character.escape.trin
          - match: (?x)\\[\p{S}\p{P}]
            name: constant.character.escape.symbol.trin
          - match: (?x)\\\p{Z}
            name: constant.character.escape.other.trin
          - match: (?x)\\[\p{L}\p{N}\p{C}]
            name: invalid.illegal.unknown-escape.trin
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: (?<!\|)\|\|(?!\|)
            name: keyword.operator.union.trin
          - match: (?<!&)&&(?!&)
            name: keyword.operator.intersection.trin
          - match: (?<!\^)\^\^(?!\^)
            name: keyword.operator.symmetric.trin
          - match: (?<!~)~~(?!~)
            name: keyword.operator.negation.trin
          - match: (?<!-)--(?!-)
            name: keyword.operator.difference.trin
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.trin
          - match: \\.
            name: constant.character.escape.other.trin

      regexp-char-set:
        patterns:
          - begin: (\[=)
            end: \s*(\])
            name: constant.other.character-class.posix.trin
            captures:
              1: {name: punctuation.definition.character-class.posix.trin}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\.)
            end: \s*(\])
            name: constant.other.character-class.posix.trin
            captures:
              1: {name: punctuation.definition.character-class.posix.trin}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[:)
            end: \s*(\])
            name: constant.other.character-class.posix.trin
            captures:
              1: {name: punctuation.definition.character-class.posix.trin}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
              - include: "#regexp-patterns"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.negated.trin
            captures:
              1: {name: punctuation.definition.character-class.negated.trin}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.trin
            captures:
              1: {name: punctuation.definition.character-class.trin}
            patterns:
              - include: "#comments"
              - include: "#regexp-char-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-char-set"

  tag-names:
    patterns:
      - match: (?x)\b([\p{Pc}\p{L}][\p{Pd}\w]*)\b(?=[.:])
        name: entity.name.tag.namespace.trin
      - match: |
          (?x)\b
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\p{Pd}\w&&\P{Pc}]*\p{Pc}+)|
          ([\p{L}&&\P{Ll}][\p{Pd}\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\p{Pd}\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}][\p{Pd}\w]*)
          )\b
        captures:
          1: {name: entity.name.tag.style.trin}
          2: {name: entity.name.tag.script.trin}
          3: {name: entity.name.tag.trin support.class.component.trin}
          4: {name: entity.name.tag.trin}
      - match: ":"
        name: punctuation.separator.namespace.trin
      - match: \.
        name: punctuation.accessor.trin

  jsx:
    comment: Avoid < operator expressions as best we can using Zertosh's regex
    begin: (?=<[\p{Pc}\p{L}])
    end: (?=.)|$
    applyEndPatternLast: 1
    patterns:
      - include: "#tag-element-name"

  tag-element-name:
    patterns:
      - comment: JSX Fragment
        name: meta.tag.trin
        contentName: meta.tag.trin
        begin: \s*+(<)\s*(?=>)
        end: (?<=</)(>)
        beginCaptures:
          1: {name: punctuation.definition.tag.trin}
        endCaptures:
          1: {name: punctuation.definition.tag.trin}
        patterns:
          - include: "#tag-termination"
      - comment: "Tags that end > are trapped in #tag-termination"
        name: meta.tag.trin
        contentName: meta.tag.trin
        begin: |
          (?x)\s*+(<)#start tag begin
          ([\p{Pc}\p{L}]\w*(?:[:.\p{Pd}][\p{Pc}\p{L}]\w*)*)#tag name
          (?=[\/>\s])(?![:])(?<!\.|:)
        end: \s*(?<=</)(\2)(>)|(<?/>)|((?<=</)\O*?)>
        beginCaptures:
          1: {name: punctuation.definition.tag.trin}
          2: {patterns: [include: "#tag-names"]}
        endCaptures:
          1: {patterns: [include: "#tag-names"]}
          2: {name: punctuation.definition.tag.trin}
          3: {name: punctuation.definition.tag.trin}
          4: {name: invalid.illegal.termination.trin}
        patterns:
          - include: "#tag-termination"
          - include: "#tag-attributes"
  tag-termination:
    comment: uses non consuming search for </ in </tag>
    contentName: meta.jsx.children.trin
    name: meta.jsx.children.trin
    begin: (>)
    end: (</)
    captures:
      0: {name: punctuation.definition.tag.trin}
    patterns:
      - include: "#evaluated-code"
      - include: "#jsx-entities"
      - include: "#tag-element-name"
      - include: "#string-content"
      - include: markdown.math.block
      - include: text.html.markdown#inline
  tag-attributes:
    patterns:
      - include: "#evaluated-code"
      - include: "#attribute-name"
      - include: source.yaml#flow-collection
      - include: "#spread-attribute"
      - include: "#strings-unquoted"
      - include: "#strings-quoted"
      - include: "#numbers"
      - include: "#regexps"
      - include: "#string-content"
      - include: "#tag-element-name"
      - include: "#comments"
  spread-attribute:
    comment: Spread attribute { ... AssignmentExpression }
    match: (?<!\*)\*(?!\*)
    name: keyword.operator.spread.trin
  attribute-name:
    patterns:
      - comment: Attribute names
        match: (?<=[)}\]])(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
        captures:
          1: {name: punctuation.separator.key-value.trin}
          2:
            name: string.unquoted.html.trin
            patterns:
              - include: "#string-content"
              - include: source.yaml#flow-scalar-plain-out-implicit-type
      - comment: Attribute names
        match: (?<![^\s<])([\p{Pc}\p{L}][\p{Pd}\w]*)(=)?((?:\w|\\.)(?:\\.|[^\s</>])*)?\s*
        captures:
          1: {name: entity.other.attribute-name.trin}
          2: {name: punctuation.separator.key-value.trin}
          3:
            name: string.unquoted.html.trin
            patterns:
              - include: "#string-content"
              - include: source.yaml#flow-scalar-plain-out-implicit-type
  evaluated-code:
    patterns:
      - comment: Style attribute
        begin: \s*#{\s*
        end: \s*}\s*
        captures:
          0: {name: punctuation.section.embedded.trin}
        patterns:
          - include: source.css.scss#flow_control
          - include: source.css.scss#rules
          - include: source.css.scss#properties
          - include: source.css.scss
      - begin: \s*\${\s*
        end: \s*}\s*
        captures:
          0: {name: punctuation.section.embedded.trin}
        patterns:
          - include: "#spread-attribute"
          - include: $self
  jsx-entities:
    patterns:
      - captures: &jsx-entities
          1: {name: punctuation.definition.entity.trin}
          2: {name: punctuation.definition.entity.trin}
        match: (&)#\d+(;)
        name: constant.character.escape.decimal.trin
      - captures: *jsx-entities
        match: (?i)(&)#x\h+(;)
        name: constant.character.escape.hexadecimal.trin
      - captures: *jsx-entities
        match: (?i)(&)#b[01]+(;)
        name: constant.character.escape.binary.trin
      - captures: *jsx-entities
        match: (?i)(&)#q[0-3]\h+(;)
        name: constant.character.escape.quaternary.trin
      - captures: *jsx-entities
        match: (?i)(&)#s[0-5]\h+(;)
        name: constant.character.escape.senary.trin
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.trin
      - captures: *jsx-entities
        match: (?i)(&)#o[0-7]\h+(;)
        name: constant.character.escape.octal.trin
      - captures: *jsx-entities
        match: (?i)(&)#z[\dab]\h+(;)
        name: constant.character.escape.duodecimal.trin
      - captures: *jsx-entities
        match: (&)(?:\\.|[^(){}\[\]\s;])+?(;)
        name: constant.character.entity.xml
      - match: '&(?=\w*;)'
        name: invalid.illegal.ambiguous-ampersand.trin
      - comment: Entity with & and invalid name
        match: '&\s*+;'
        name: invalid.illegal.bad-ampersand.trin

  jsdoc:
    patterns:
      - include: "#jsdoc-inline-tags"
      - include: "#jsdoc-access"
      - include: "#jsdoc-as-name-path"
      - include: "#jsdoc-simple"
      - include: "#jsdoc-simple-name-path"
      - include: "#jsdoc-module"
      - include: "#jsdoc-type-name"
      - include: "#jsdoc-type-no-name"
      - comment: additional jsdoc V2 keywords
        match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
        name: storage.type.class.jsdoc
      - comment: additional jsdoc keywords
        match:
          (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss
          mixin|singleton|template|uses|xtype)\b
        name: storage.type.class.jsdoc

    repository:
      jsdoc-access:
        comment: "@tag protected...."
        match: (@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-module:
        comment: "@tag {optional type} module:file"
        begin: (@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - match: (?:(module)(:))?(((?!\*/)\S)+)
            captures:
              1: {name: keyword.module.jsdoc}
              2: {name: punctuation.jsdoc}
              3: {name: string.modulename.jsdoc}
      jsdoc-as-name-path:
        comment: to terminate the block
        begin: (@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-name-path-scopes"
      jsdoc-simple:
        comment: "@tag"
        match: (@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-name-path:
        comment: "@tag {opt type} Class#xxx or Class#Event:aaaa etc"
        begin: (@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-name-path-scopes"
      jsdoc-type-name:
        comment: "@tag {optional type} name"
        begin: (@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
          - include: "#jsdoc-name-scopes"
      jsdoc-type-no-name:
        comment: "@tag {types}"
        begin: (@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-scopes"
      jsdoc-inline-tags:
        name: meta.tag.inline.jsdoc
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.jsdoc}
              3: {name: string.jsdoc}
      jsdoc-typedef-scopes:
        name: entity.name.type.instance.jsdoc
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - include: "#jsdoc-name-path-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-obj:
        comment: typedef object
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
          - include: "#jsdoc-typedef-primitives"
          - match: \b([\p{Pc}\p{L}]\w*)\s*(:)
            captures:
              1: {name: variable.other.readwrite.jsdoc}
          - include: "#jsdoc-name-path-scopes"
          - include: "#jsdoc-typedef-obj"
      jsdoc-name-scopes:
        patterns:
          - match: ((?!\*/)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.jsdoc}
          - name: variable.other.jsdoc
            begin: \[
            end: \]|^
            patterns:
              - include: "#jsdoc-string"
              - include: "#jsdoc-name-scopes"
      jsdoc-name-path-scopes:
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*(?=[\p{Pc}\p{L}])
            captures:
              1: {name: keyword.as.jsdoc}
          - match: \s*(?:([\p{Pc}\p{L}&&\P{Ll}]+\w*)|([\p{Pc}\p{L}]\w*))(?=[\s\-~.#]|$)
            captures:
              1: {name: entity.name.class.jsdoc}
              2: {name: entity.name.function.jsdoc}
          - match: (\.)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.static.jsdoc}
          - match: (\#)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.instance.jsdoc}
          - match: (~|-)([\p{Pc}\p{L}]\w*)(?=\s|$|\")
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: entity.name.function.method.inner.jsdoc}
          - match: (\#)(event)(:)
            captures:
              1: {name: keyword.operator.accessor.jsdoc}
              2: {name: keyword.event.jsdoc}
              3: {name: keyword.operator.jsdoc}
          - name: string.method.jsdoc
            begin: \.(?="|')
            end: (?=.)
            applyEndPatternLast: 1
            patterns:
              - include: "#jsdoc-string"
      jsdoc-string:
        name: string.jsdoc
        match: \"(\\"|[^"])*"|'(\\'|[^'])*'

  comments:
    patterns:
      - include: "#block-comments"
      - include: "#line-comments"

  block-comments:
    patterns:
      - begin: \s*((/\+\+))
        end: (\s*(\+/))
        name: comment.block.documentation.nested.trin
        captures:
          1: {name: comment.block.documentation.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
          - include: "#nested-block-jsdoc"
      - begin: \s*((/\+))
        end: (\s*(\+/))
        name: comment.block.nested.trin
        captures:
          1: {name: comment.block.nested.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: text.html.markdown#inline
          - include: "#nested-block"
      - begin: \s*((/\*\*))
        end: (\s*(\*/))
        name: comment.block.documentation.trin
        captures:
          1: {name: comment.block.documentation.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: \s*((/\*))
        end: (\s*(\*/))
        name: comment.block.trin
        captures:
          1: {name: comment.block.trin}
          2: {name: punctuation.definition.comment.trin}
        patterns:
          - include: text.html.markdown#inline

  line-comments:
    patterns:
      - begin: ((^\s*)|\s*)((//=))
        end: \s*$
        name: comment.line.special.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.special.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          1: {name: punctuation.definition.comment.trin}
        patterns:
          - include: "#comment-special"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//\+))
        end: \s*$
        name: comment.line.playground.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.playground.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.playground.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((///))
        end: \s*$
        name: comment.line.documentation.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.documentation.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.documentation.trin}
        patterns:
          - include: "#jsdoc"
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//!|\A#!))
        end: \s*$
        name: comment.line.shebang.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.shebang.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.shebang.trin}
        patterns:
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//\*))
        end: \s*$
        name: comment.line.doctype.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.doctype.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.doctype.trin}
        patterns:
          - include: text.html.markdown#inline
      - begin: ((^\s*)|\s*)((//))
        end: \s*$
        name: comment.line.number-sign.trin
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.trin}
          3: {name: comment.line.double-slash.trin}
          4: {name: punctuation.definition.comment.trin}
        endCaptures:
          0: {name: comment.line.number-sign.trin}
        patterns:
          - include: text.html.markdown#inline

  nested-block-jsdoc:
    begin: (/\+\+)\s*
    end: \s*(\+/)
    name: comment.block.documentation.nested.trin
    captures:
      1: {name: punctuation.definition.comment.trin}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-block-jsdoc"
  nested-block:
    begin: (/\+)\s*
    end: \s*(\+/)
    name: comment.block.nested.trin
    captures:
      1: {name: punctuation.definition.comment.trin}
    patterns:
      - include: text.html.markdown#inline
      - include: "#nested-block"
  nested-special:
    begin: (/\+)\s*
    end: \s*(\+/)
    captures:
      1: {name: punctuation.definition.comment.trin}
    patterns:
      - include: "#jsdoc"
      - include: text.html.markdown#inline
      - include: "#nested-special"

  calls:
    patterns:
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?|->)
          \b(?:# don't match keywords
          in|of|as|is|out|new|infer|unset
          |typeof|nameof|sizeof
          |keyof|valueof|pairof|instof
          |len|del|to|til|till|thru|by

          |var|val|let|set|get|def|fn|fun|func
          |class|enum|module|package|inter|struct|object|record
          |frag|space|data|trait|proto|proc|macro|type|given
          |raw|style|compo|element|decl|ext|impl|sub

          |if|lest|elif|elest|else|then
          |for|each|loop|while|until|from|with
          |do|redo|try|retry|throw|catch|finally
          |switch|case|default|match|when|otherwise
          |unison|series|spawn|kill|fix|lock
          |break|continue|return|await|label|yield|goto
          |import|export|impose|expose|using
          |debug|check|assert|fallthru
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b\s+
          (?=
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|out|new|infer|unset
          |typeof|nameof|sizeof
          |keyof|valueof|pairof|instof
          |len|del|to|til|till|thru|by

          |var|val|let|set|get|def|fn|fun|func
          |class|enum|module|package|inter|struct|object|record
          |frag|space|data|trait|proto|proc|macro|type|given
          |raw|style|compo|element|decl|ext|impl|sub

          |if|lest|elif|elest|else|then
          |for|each|loop|while|until|from|with
          |do|redo|try|retry|throw|catch|finally
          |switch|case|default|match|when|otherwise
          |unison|series|spawn|kill|fix|lock
          |break|continue|return|await|label|yield|goto
          |import|export|impose|expose|using
          |debug|check|assert|fallthru
          )\b
          )
          [\w]+|\[(?!<)|<\|(?!>)(?=\|*)|<\+(?!>)(?=\+*))
        captures:
          1: {patterns: [include: "#function-entities"]}
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)\s*\b
          (
          (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
          \b(?:# don't match keywords
          in|of|as|is|out|new|infer|unset
          |typeof|nameof|sizeof
          |keyof|valueof|pairof|instof
          |len|del|to|til|till|thru|by

          |var|val|let|set|get|def|fn|fun|func
          |class|enum|module|package|inter|struct|object|record
          |frag|space|data|trait|proto|proc|macro|type|given
          |raw|style|compo|element|decl|ext|impl|sub

          |if|lest|elif|elest|else|then
          |for|each|loop|while|until|from|with
          |do|redo|try|retry|throw|catch|finally
          |switch|case|default|match|when|otherwise
          |unison|series|spawn|kill|fix|lock
          |break|continue|return|await|label|yield|goto
          |import|export|impose|expose|using
          |debug|check|assert|fallthru
          )\b
          )
          [\p{Pc}\p{L}]\w*
          )
          \b
          (?=
          (?:[!?~]?\.=?|[?!:]:=?)?\s*\#?\(|
          (?:[!?~]?\.=?|[?!:]:=?)?\s+['"`\\\[]|
          (?:[!?~]?\.=?|[?!:]:=?)?\s+<[\p{Pc}\p{L}]
          )
        captures:
          1: {patterns: [include: "#function-entities"]}

  function-entities:
    patterns:
      - match: |
          (?x)\b(?:
          (?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
          (?:# Properties (note all properties are by default, symbols)
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          |
          (?:# Objects and maps
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          (?!\.\.+)(?=[!?~]?\.=?|[?!:]:=?|\#?\[)
          |
          (?:# Regular variables
          (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
          ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
          ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
          ([\p{Pc}\p{L}]\w*)
          )
          )\b
        captures:
          1: {name: entity.name.tag.trin}
          2: {name: entity.name.tag.trin support.class.component.trin}
          3: {name: entity.name.class.builtin.trin}
          4: {name: entity.name.function.method.trin}
          5: {name: variable.other.global.trin}
          6: {name: variable.other.constant.object.trin}
          7: {name: variable.other.conditional.trin}
          8: {name: variable.other.object.trin}
          9: {name: entity.name.function.tagged-template.trin}
          10: {name: entity.name.type.trin}
          11: {name: entity.name.class.trin}
          12: {name: entity.name.function.trin}
      - include: $self

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int
      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b
      (?:
      (?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties (note all properties are by default, symbols)
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?!\.\.+)(?=[!?~]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )
      \b\s*
    captures:
      1: {name: variable.other.index.trin}
      2: {name: variable.other.constant.property.trin}
      3: {name: variable.other.property.static.trin}
      4: {name: variable.other.property.trin}
      5: {name: variable.other.global.trin}
      6: {name: variable.other.constant.object.trin}
      7: {name: variable.other.conditional.trin}
      8: {name: variable.other.object.trin}
      9: {name: variable.other.dollar.trin}
      10: {name: variable.other.constant.trin}
      11: {name: variable.other.class.trin}
      12: {name: variable.other.readwrite.trin}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops:
        match: (?<=^|['"`\\\s({\[])([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)(?=$|['"`\\\s)}\]])
        captures:
          0:
            patterns:
              - comment: augmented assignment += -= *= /= etc
                match: (?<=^|['"`\\({\[\s])([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+(?<![!:~.<=>])=)(?=$|['"`\\\s)}\]])
                name: keyword.operator.assignment.augmented.trin

              - comment: |
                  BUILT-IN OPERATORS

                  1: assignment : :=
                  2: arithmetic + - * ** *** / // /// % %% *> <*
                  3: increment/decrement ++ --
                  4: logical && || ^^ !& !| !^ &| &!
                  5: bitwise & | ^ ~
                  6: bitwise shift << >> <<< >>>
                  7: function pipeline <| |> <|| ||> <||| |||>
                  8: function composition +> <+ <++ +>>
                  9: class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<
                  10: relational < > <= >=
                  11: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
                  12: equality == != === !==
                  13: wavy operators ~> <~ ~~> <~~
                  14: fat arrow-like => ==> <==
                  15: skinny arrow-like -> --> <- <--
                  16: null-coalescing ??
                  17: non-null coalescing !!
                  18: compact ternary operator ?:
                  19: inverse ternary operator !:
                  20: infix function call $:
                captures:
                  1: {name: keyword.operator.assignment.trin}
                  2: {name: keyword.operator.arithmetic.trin}
                  3: {name: keyword.operator.successor.trin}
                  4: {name: keyword.operator.logical.trin}
                  5: {name: keyword.operator.bitwise.trin}
                  6: {name: keyword.operator.bitwise.shift.trin}
                  7: {name: keyword.operator.pipeline.trin}
                  8: {name: keyword.operator.compose.trin}
                  9: {name: keyword.operator.class.trin}
                  10: {name: keyword.operator.relational.trin}
                  11: {name: keyword.operator.regexp.trin}
                  12: {name: keyword.operator.comparison.trin}
                  13: {name: keyword.operator.similarity.trin}
                  14: {name: keyword.operator.arrow.fat.trin}
                  15: {name: keyword.operator.arrow.skinny.trin}
                  16: {name: keyword.operator.null-coalescing.trin}
                  17: {name: keyword.operator.coalescing.trin}
                  18: {name: keyword.operator.conditional.trin}
                  19: {name: keyword.operator.ternary.trin}
                  20: {name: keyword.operator.macro.dollar.trin}
                match: |
                  (?x)
                  (?<=^|['"`\\({\[\s])# spacing
                  (?:
                  (:?=)#1
                  |([+-]|\*{1,3}|~?/|%%?|\#\#?|<?\*>?)#2
                  |(\+\+|--)#3
                  |([&|^~]{2})#4
                  |([&|^~])#5
                  |(<<<?|>>>?)#6
                  |(\|{1,3}>|<\|{1,3})#7
                  |(\+>|<\+)#8
                  |([<>]?[!:][<>]?)#9
                  |([<>]=?)#10
                  |(<>|=<|<?[/*|+$]>?)#11
                  |([!=]==?)#12
                  |(~>|<~|~~>|<~~)#13
                  |(<==|==?>)#14
                  |(--?>|<--?)#15
                  |(\?\?)#16
                  |(!!)#17
                  |(\?:)#18
                  |(!:)#19
                  |(\$:)#20
                  )
                  (?=$|['"`\\\s)}\]])

              - comment: |
                  CUSTOM OPERATORS

                  1: custom bitwise (& | ^ ~)
                  2: custom arithmetic (+ - * / %)
                  3: custom prototype (:)
                  4: custom accessor (.)
                  5: custom equality (= !)
                  6: custom comparison (< >)
                  7: custom private (? #)
                  8: custom mathematical (Unicode Sm)
                  9: custom currency (Unicode Sc)
                  10: custom ASCII (between \x80 and \xff)
                  11: custom infix operators (all other chars)
                captures:
                  1: {name: keyword.operator.bitwise.custom.trin}
                  2: {name: keyword.operator.arithmetic.custom.trin}
                  3: {name: keyword.operator.prototype.custom.trin}
                  4: {name: keyword.operator.accessor.custom.trin}
                  5: {name: keyword.operator.comparison.custom.trin}
                  6: {name: keyword.operator.relational.custom.trin}
                  7: {name: keyword.operator.private.custom.trin}
                  8: {name: keyword.operator.math.custom.trin}
                  9: {name: keyword.operator.currency.custom.trin}
                  10: {name: keyword.operator.ascii.custom.trin}
                  11: {name: keyword.operator.infix.custom.trin}
                match: |
                  (?x)
                  (?<=^|['"`\\({\[\s])# spacing
                  (?:
                  ([&|^~][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#1
                  |([+\-*/%][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#2
                  |(:[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#3
                  |(\.[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#3
                  |([!=][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#4
                  |([<>][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#5
                  |([?\#][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#6
                  |(\p{Sm}[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#7
                  |(\p{Sc}[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#8
                  |([\p{S}\p{P}&&[\x80-\xff]][\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#9
                  |([\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)#10
                  )
                  (?=$|['"`\\\s)}\]])

      unary-ops:
        patterns:
          - &primary-operators
            comment: Primary binary operators
            match: |
              (?x)(?<=\b|^|[)}\]'"`\\])
              (?:
              ([>.]\.[.<])
              |(\?[.:]=?)
              |(~[.:]=?)
              |(![.:]=?)
              |((?:::|\.)=?)
              |(->)
              )
              (?=\b|$|[({\['"`\\])
            captures:
              1: {name: keyword.operator.range.trin}
              2: {name: punctuation.accessor.optional.trin}
              3: {name: punctuation.accessor.cascade.trin}
              4: {name: punctuation.accessor.call.trin}
              5: {name: punctuation.accessor.trin}
              6: {name: punctuation.accessor.module.trin}

          - &prefix-operators
            comment: Prefix operators
            match: |
              (?x)
              (?:([*/])#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]])#15
              (?=[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*
              [\w({\[_,;'"`])
            name: keyword.operator.prefix.trin
            captures:
              1: {name: keyword.operator.module.all.trin}
              2: {name: keyword.operator.increment.trin}
              3: {name: keyword.operator.decrement.trin}
              4: {name: keyword.operator.intersection.trin}
              5: {name: keyword.operator.union.trin}
              6: {name: keyword.operator.symmetric.trin}
              7: {name: keyword.operator.logical.trin}
              8: {name: keyword.operator.private.trin}
              9: {name: keyword.operator.decorator.trin}
              10: {name: keyword.operator.bitwise.not.trin}
              11: {name: keyword.operator.existential.trin}
              12: {name: keyword.operator.assignment.trin}
              13: {name: keyword.operator.pipeline.trin}
              14: {name: keyword.operator.private.trin}
              15: {name: keyword.operator.prefix.trin}

          - &suffix-operators
            comment: Suffix operators
            match: |
              (?x)
              (?<=[\w)}\]_,;'"`]
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*)
              (?:([*/])#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |(\#)#14
              |[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]])#15
            name: keyword.operator.suffix.trin
            captures:
              1: {name: keyword.operator.module.all.trin}
              2: {name: keyword.operator.increment.trin}
              3: {name: keyword.operator.decrement.trin}
              4: {name: keyword.operator.intersection.trin}
              5: {name: keyword.operator.union.trin}
              6: {name: keyword.operator.symmetric.trin}
              7: {name: punctuation.accessor.call.trin}
              8: {name: keyword.operator.private.trin}
              9: {name: keyword.operator.decorator.trin}
              10: {name: keyword.operator.bitwise.trin}
              11: {name: punctuation.accessor.optional.trin}
              12: {name: keyword.operator.assignment.trin}
              13: {name: keyword.operator.pipeline.trin}
              14: {name: keyword.operator.private.trin}
              15: {name: keyword.operator.suffix.trin}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# prefix
              (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
              \b(?:# don't match keywords
              in|of|as|is|out|new|infer|unset
              |typeof|nameof|sizeof
              |keyof|valueof|pairof|instof
              |len|del|to|til|till|thru|by

              |var|val|let|set|get|def|fn|fun|func
              |class|enum|module|package|inter|struct|object|record
              |frag|space|data|trait|proto|proc|macro|type|given
              |raw|style|compo|element|decl|ext|impl|sub

              |if|lest|elif|elest|else|then
              |for|each|loop|while|until|from|with
              |do|redo|try|retry|throw|catch|finally
              |switch|case|default|match|when|otherwise
              |unison|series|spawn|kill|fix|lock
              |break|continue|return|await|label|yield|goto
              |import|export|impose|expose|using
              |debug|check|assert|fallthru
              )\b
              )
              [\w]+
              (?:[\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# primary
              [\w]+)*
              [\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]*# suffix
              )\s*([^(]|$|;))
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.compose.trin}
              2: {name: keyword.operator.pipeline.trin}
            patterns:
              - match: |
                  (?x)\s*\b
                  (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
                  \b(?:# don't match keywords
                  in|of|as|is|out|new|infer|unset
                  |typeof|nameof|sizeof
                  |keyof|valueof|pairof|instof
                  |len|del|to|til|till|thru|by

                  |var|val|let|set|get|def|fn|fun|func
                  |class|enum|module|package|inter|struct|object|record
                  |frag|space|data|trait|proto|proc|macro|type|given
                  |raw|style|compo|element|decl|ext|impl|sub

                  |if|lest|elif|elest|else|then
                  |for|each|loop|while|until|from|with
                  |do|redo|try|retry|throw|catch|finally
                  |switch|case|default|match|when|otherwise
                  |unison|series|spawn|kill|fix|lock
                  |break|continue|return|await|label|yield|goto
                  |import|export|impose|expose|using
                  |debug|check|assert|fallthru
                  )\b
                  )
                  (?:
                  (?:# Objects and maps
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  (?!\.\.+)(?=[!?~]?\.=?|[?!:]:=?|\#?\[)
                  |
                  (?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
                  (?:# Properties (note all properties are by default, symbols)
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  |
                  (?:# Regular variables
                  (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
                  ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
                  ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
                  ([\p{Pc}\p{L}]\w*)
                  )
                  )\b
                captures:
                  1: {name: variable.other.global.trin}
                  2: {name: variable.other.constant.object.trin}
                  3: {name: variable.other.conditional.trin}
                  4: {name: variable.other.object.trin}
                  5: {name: entity.name.tag.trin}
                  6: {name: entity.name.tag.trin support.class.component.trin}
                  7: {name: entity.name.class.builtin.trin}
                  8: {name: entity.name.function.method.trin}
                  9: {name: entity.name.function.tagged-template.trin}
                  10: {name: entity.name.type.trin}
                  11: {name: entity.name.class.trin}
                  12: {name: entity.name.function.trin}
              - *primary-operators

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.trin}
            patterns:
              - begin: \s*(?=([\p{Pc}\p{L}]\w*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.trin
              - include: $self

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!(?<!(?:(?<!\.)\.|[?!:]:)=?)
      \b(?:# don't match keywords
      in|of|as|is|out|new|infer|unset
      |typeof|nameof|sizeof
      |keyof|valueof|pairof|instof
      |len|del|to|til|till|thru|by

      |var|val|let|set|get|def|fn|fun|func
      |class|enum|module|package|inter|struct|object|record
      |frag|space|data|trait|proto|proc|macro|type|given
      |raw|style|compo|element|decl|ext|impl|sub

      |if|lest|elif|elest|else|then
      |for|each|loop|while|until|from|with
      |do|redo|try|retry|throw|catch|finally
      |switch|case|default|match|when|otherwise
      |unison|series|spawn|kill|fix|lock
      |break|continue|return|await|label|yield|goto
      |import|export|impose|expose|using
      |debug|check|assert|fallthru
      )\b
      )
      (?:
      (?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
      (?:# Properties (note all properties are by default, symbols)
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      |
      (?:# Objects and maps
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      (?!\.\.+)(?=[!?~]?\.=?|[?!:]:=?|\#?\[)
      |
      (?:# Regular variables
      (\p{Pc}+[\p{Pc}\p{L}]\w*(?!\p{Pc}+)|[\p{Pc}\p{L}][\w&&\P{Pc}]*\p{Pc}+)|
      ([\p{L}&&\P{Ll}][\w&&\P{Ll}]*)|
      ((?:[\p{Pc}\p{L}&&\P{Ll}]+[\w&&\P{Lu}]*)+)|
      ([\p{Pc}\p{L}]\w*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.trin}
      2: {name: entity.name.tag.trin}
      3: {name: entity.name.namespace.trin}
      4: {name: entity.name.interface.trin}
      5: {name: entity.name.tag.block.trin}
      6: {name: entity.name.tag.script.trin}
      7: {name: entity.name.tag.style.trin}
      8: {name: entity.name.tag.inline.trin}
      9: {name: entity.name.label.trin}
      10: {name: entity.name.project.trin}
      11: {name: entity.name.class.trin}
      12: {name: entity.name.type.trin}

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.mapping.trin
              - match: (?<!\s):(?!:)
                name: punctuation.separator.key-value.trin
              - match: (?<=^|[({\[])\s*([*+-](?:\s+[*+-])*)
                name: punctuation.definition.block.sequence.item.trin
        patterns:
          - begin: \s*(?<=(?:[\p{S}\p{P}&&[^,;'"`\\p{Pc}({\[)}\]]]+)\s*|[({\[]\s*|^\s*|\b(?:var|let|const)\b\s*)(\#\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.mapping.trin}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(?<=(?:[\p{S}\p{P}&&[^,;'"`\\p{Pc}({\[)}\]]]+)\s*|[({\[]\s*|^\s*|\b(?:var|let|const)\b\s*)(\{)\s*
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.trin}
            patterns:
              - include: "#labels"
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        repository:
          punctuation:
            patterns:
              - match: ","
                name: punctuation.separator.arguments.trin
        patterns:
          - begin: \s*(\#\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.parameters.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        repository:
          punctuation:
            patterns:
              - match: (?<=\b|^|[)}\]'"`\\\s])(:)(?=\b|$|[({\['"`\\\s])
                captures:
                  1: {name: punctuation.separator.slice.trin}
              - match: ","
                name: punctuation.separator.sequence.trin
        patterns:
          - begin: \s*(@\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.typeparameters.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\#\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.sequence.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.trin}
            patterns:
              - include: "#punctuation"
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        name: storage.type.extends.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        name: storage.type.implements.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(typeof|nameof|sizeof|keyof|valueof|pairof|infer|as|is)\b\s*
        name: keyword.operator.expression.$1.trin

  type-operators:
    patterns:
      - comment: primary binary operators
        match: |
          (?x)(?<=^|[)}\]\w'"`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[({\[\w'"`])
        captures:
          1: {name: punctuation.accessor.optional.trin}
          2: {name: punctuation.accessor.cascade.trin}
          3: {name: punctuation.accessor.call.trin}
          4: {name: punctuation.accessor.trin}
          5: {name: punctuation.accessor.module.trin}

      - comment: type operators
        match: |
          (?x)\s*
          (?:
          (\+)|
          (\-)|
          ([*/])|
          (\/)|
          (\%)|
          (\!)|
          (\?)|
          (\&)|
          (\|)|
          (\^)|
          (\~)|
          (\$)|
          (\#)|
          ([<>])
          )
          (?=$|[({\[\w'"\s])
        captures:
          1: {name: keyword.operator.sum.trin}
          2: {name: keyword.operator.difference.trin}
          3: {name: keyword.operator.product.trin}
          4: {name: keyword.operator.quotient.trin}
          5: {name: keyword.operator.remainder.trin}
          6: {name: keyword.operator.only.trin}
          7: {name: keyword.operator.maybe.trin}
          8: {name: keyword.operator.intersection.trin}
          9: {name: keyword.operator.union.trin}
          10: {name: keyword.operator.symmetric.trin}
          11: {name: keyword.operator.negation.trin}
          12: {name: keyword.operator.macro.dollar.trin}
          13: {name: keyword.operator.private.trin}
          14: {name: keyword.operator.class.trin}

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=.)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.trin}
    patterns:
      - include: "#types"

  types:
    patterns:
      - match: \s*(==>|--?>|~~?>)
        name: keyword.operator.type.function.trin
      - match: \s*(<==|<--?|<~~?)
        name: keyword.operator.type.channel.trin
      - include: "#params-clause"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#type-names"
      - include: "#custom-types"
      - include: "#type-brackets"
      - include: "#code-block"
      - include: "#type-operators"
      - include: "#literals"

  support:
    patterns:
      - comment: Swift
      - include: source.swift#builtin-properties
      - include: source.swift#builtin-types
      - include: source.swift#builtin-functions

      - comment: JavaScript
      - include: source.js#support-objects
      - include: "#support-js"

      - comment: Python
      - include: source.python#builtin-functions
      - include: source.python#builtin-types
      - include: source.python#magic-function-names
      - include: source.python#magic-variable-names

      - comment: PHP
      - include: source.php#support
      - include: source.php#class-builtin
      - include: "#support-php"

      - comment: Other (coming soon!)

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.trin}
    patterns: &function-params
      - include: "#clauses"
      - include: "#declarations"
      - include: "#keywords"
      - match: (?i)\s*\?[\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.optional.trin
      - match: (?i)\s*\*[\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.spread.trin
      - match: (?i)\s*[&~][\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.name.trin
      - match: (?i)\s*\%[\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.reference.trin
      - match: (?i)\s*\$[\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.other.trin
      - match: (?i)\s*\b[\p{Pc}\p{L}]\w*\b\s*(?=\s+:?=|\s*[,:;)]|\s*\|(?!\|))
        name: variable.parameter.trin
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#code-block"
      - include: "#declarations"
      - include: "#type-keywords"
      - include: "#illegal-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#type-annotation"
      - match: \s*(?<!\*)\*(?!\*)\s*
        name: keyword.generator.asterisk.trin
      - include: "#type-operators"
      - include: "#support"
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]))
        end: (?=.)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.trin}
        patterns:
          - include: "#types"

  modifier-keywords:
    match: |
      (?x)
      (
      (?:
      (?:
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      # access modifiers
      pub|priv|prot|inline|final|mut|immut
      |seal|abs|intern|extern|imp|exp|glo|loc

      # concurrency modifiers
      |a?sync|stat|dyn|lazy|eager|strong|weak
      |vola|unsafe|unfix|bound|free|opaque|trans

      # property or method modifiers
      |re|gen|oper|[gs]et|early|late
      |prefix|suffix|infix|primary|unary
      )
      )\b\s*
      |# Decorators
      @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
      )*
      )

      (?=
      \s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b
      (?:
      var|val|let|set|get|def|fn|fun|func
      |class|enum|module|package|inter|struct|object|record
      |frag|space|data|trait|proto|proc|macro|type|given
      |raw|style|compo|element|decl|ext|impl|sub
      )
      \b
      )
    captures:
      1:
        patterns: &modifier-keywords
          - match: |
              (?x)\s*@[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
            name: entity.name.class.decorator.trin
          - match: |
              (?x)\s*
              \s*\b
              (?:
              (# Access modifiers
              pub|priv|prot|inline|final|mut|immut
              |seal|abs|intern|extern|imp|exp|glo|loc
              )|
              (# Function or method modifiers
              a?sync|stat|dyn|lazy|eager|strong|weak
              |vola|unsafe|unfix|bound|free|opaque|trans
              )|
              (# Property modifiers
              re|gen|oper|[gs]et|early|late
              |prefix|suffix|infix|primary|unary
              )
              )\b\s*
            captures:
              1: {name: storage.modifier.trin}
              2: {name: storage.type.accessor.trin}
              3: {name: storage.type.property.trin}

  declaration-keywords:
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(va[rl]|[lsg]et)\b\s*
        name: storage.type.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(decl)\b\s*
        name: keyword.other.declare.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def|fn|func?)\b\s*
        name: storage.type.function.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        name: storage.type.class.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        name: storage.type.enum.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        name: storage.type.module.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(package)\b\s*
        name: storage.type.package.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)\b\s*
        name: storage.type.interface.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        name: storage.type.structure.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        name: storage.type.object.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(record)\b\s*
        name: storage.type.record.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(frag)\b\s*
        name: storage.type.fragment.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        name: storage.type.data.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        name: storage.type.trait.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)\b\s*
        name: storage.type.protocol.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        name: storage.type.procedure.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        name: storage.type.macro.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
        name: storage.type.type.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)\b\s*
        name: storage.type.constraint.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(raw)\b\s*
        name: storage.type.raw.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        name: storage.type.style.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)\b\s*
        name: storage.type.component.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(element)\b\s*
        name: storage.type.element.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)\b\s*
        name: storage.type.subroutine.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        name: storage.type.extends.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        name: storage.type.implementation.trin

  general-keywords:
    comment: general keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)\b\s*
        name: keyword.control.conditional.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)\b\s*
        name: keyword.control.loop.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(do|redo)\b\s*
        name: keyword.control.do.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|retry|throw|catch|finally)\b\s*
        name: keyword.control.trycatch.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch|case|default)\b\s*
        name: keyword.control.switch.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match|when|otherwise)\b\s*
        name: keyword.control.match.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unison|series|spawn|kill|fix|lock)\b\s*
        name: keyword.control.thread.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|skip|return|await|label|yield|goto|pass)\b\s*
        name: keyword.control.flow.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|impose|expose|using)\b\s*
        name: keyword.control.module.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with|then)\b\s*
        name: keyword.control.$1.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(debug|check|assert)\b\s*
        name: keyword.other.$1.trin

  expression-keywords:
    comment: expression keywords
    patterns:
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of|as|is|new|infer|typeof|nameof|sizeof|keyof|pairof|valueof)\b\s*
        name: keyword.operator.expression.$1.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(len)\b\s*
        name: keyword.operator.expression.length.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(del)\b\s*
        name: keyword.operator.expression.delete.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(to|til|till|thru|by)\b\s*
        name: keyword.operator.expression.range.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unset)\b\s*
        name: keyword.operator.expression.void.trin
      - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(instof)\b\s*
        name: keyword.operator.expression.instanceof.trin

  keywords:
    patterns:
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#query-expression"
      - include: "#modifier-keywords"
      - include: "#declaration-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      sql-expression:
        patterns:
          - captures:
              1: {name: keyword.other.create.trin}
              2: {name: keyword.other.table.trin}
              5: {name: entity.name.function.trin}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(create(?:\s+or\s+replace)?|replace)\s+(aggregate|conversion|database|domain|function|group|(unique\s+)?index|language|operator
              class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)(['"`]?)(\w+)\4
            name: meta.create.trin
          - captures:
              1: {name: keyword.other.drop.trin}
              2: {name: keyword.other.table.trin}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(drop|delete)\s+(aggregate|conversion|database|domain|function|group|index|language|operator
              class|operator|rule|schema|sequence|table|tablespace|trigger|type|user|view))
            name: meta.drop.trin
          - captures:
              1: {name: keyword.other.drop.trin}
              2: {name: keyword.other.table.trin}
              3: {name: entity.name.function.trin}
              4: {name: keyword.other.cascade.trin}
            match: (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(drop|delete)\s+(table)\s+(\w+)(\s+cascade)?\b)
            name: meta.drop.trin
          - captures:
              1: {name: keyword.other.alter.trin}
              2: {name: keyword.other.table.trin}
            match:
              (?:\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(alter|update)\s+(aggregate|conversion|database|domain|function|group|index|language|operator
              class|operator|proc(edure)?|rule|schema|sequence|table|tablespace|trigger|type|user|view)\s+)
            name: meta.alter.trin

      control-expression:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(break|continue|fallthru|label|goto|pass)\b
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.control.flow.trin}
        patterns:
          - match: *entity-name
            name: constant.other.label.trin

      module-expression:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(import|export|impose|expose|using)\b\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.control.module.trin}
            patterns:
              - include: source.yaml#flow-collection
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from|to|thru|but|just|only|and|or|not|as|all|any|some|none|in|of)\b\s*
                name: keyword.control.module.trin
              - include: "#type-keywords"
              - include: "#strings-quoted"
              - include: "#strings-unquoted"
              - include: "#symbols"
              - include: "#type-operators"
              - match: ","
                name: punctuation.separator.comma.trin
              - match: *entity-name
                name: variable.other.readwrite.alias.trin

      query-expression:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(from)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
          2: {patterns: [include: $self]}
          3: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self

      query-body:
        patterns:
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#sort-clause"
          - include: "#select-clause"
          - include: "#group-clause"
          - include: "#limit-clause"
          - include: "#reduce-clause"

      join-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:inner|(?:full)\b\s*\bouter|left|right)?\b\s*\bjoin)\b\s*(.*?)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(in|of)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
          2: {patterns: [include: $self]}
          3: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(on|equals|into)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self
      where-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(where|having)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - include: "#query-body"
          - include: $self
      sort-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(order|sort)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(asc|desc|by)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self
      select-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(select\b\s*\b(?:unique|any|all)?)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self
      limit-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:take|drop|limit)\b\s*\b(?:first|last|head|tail)?)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self
      reduce-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b((?:fold|reduce|scan)\b\s*\b(?:left|right)?)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|while|until|with)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self
      group-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(group)\b\s*
        beginCaptures:
          1: {name: keyword.query.trin}
        end: (?=[,;)}\]])
        patterns:
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(by|into)\b\s*
            name: keyword.query.trin
          - include: "#query-body"
          - include: $self

  declarations:
    patterns:
      - include: "#variable"
      - include: "#function"
      - include: "#class"
      - include: "#enum"
      - include: "#module"
      - include: "#package"
      - include: "#interface"
      - include: "#structure"
      - include: "#object"
      - include: "#record"
      - include: "#fragment"
      - include: "#namespace"
      - include: "#data"
      - include: "#trait"
      - include: "#protocol"
      - include: "#procedure"
      - include: "#macro"
      - include: "#constraint"
      - include: "#raw"
      - include: "#style"
      - include: "#component"
      - include: "#element"
      - include: "#subroutine"
      - include: "#extends"
      - include: "#implements"

    repository:
      variable:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(va[rl]|[lsg]et)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.trin}
      function:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(def|fn|func?)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.function.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.function.trin
      class:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(class)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.class.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.class.trin
      enum:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(enum)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.enum.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.enum.trin
      module:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(module)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.module.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.module.trin
      package:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(package)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.package.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.package.trin
      interface:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(inter)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.interface.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.interface.trin
      structure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(struct)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.structure.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.structure.trin
      object:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(object)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.object.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.object.trin
      record:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(record)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.record.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.record.trin
      fragment:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(frag)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.fragment.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.fragment.trin
      namespace:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(space)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.namespace.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.namespace.trin
      data:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(data)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.data.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.data.trin
      trait:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(trait)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.trait.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.trait.trin
      protocol:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proto)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.protocol.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.protocol.trin
      procedure:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(proc)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.procedure.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.procedure.trin
      macro:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(macro)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.macro.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.macro.trin
      type:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.type.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.type.trin
      constraint:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(given)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.constraint.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.constraint.trin
      raw:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(raw)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.raw.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.raw.trin
      style:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(style)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.style.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.style.trin
      component:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(compo)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.component.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.component.trin
      element:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(element)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.element.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.element.trin
      subroutine:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(sub)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.subroutine.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.subroutine.trin
      extends:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(ext)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.extends.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.extends.trin
      implements:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(impl)\b\s*
        end: (?=.)|$
        beginCaptures:
          1: {name: storage.type.implements.trin}
        patterns:
          - include: "#block-entities"
          - match: *entity-name
            name: entity.name.implements.trin

  params-clause:
    begin: |
      (?x)
      (?<=(?:^\s*|\#?[({\[]\s*|(?:[\p{S}\p{P}&&[^,;'"`\\p{Pc}({\[)}\]]]+)\s+|\b(?:#keywords
      in|of|as|is|out|new|infer|unset
      |typeof|nameof|sizeof
      |keyof|valueof|pairof|instof
      |len|del|to|til|till|thru|by

      |var|val|let|set|get|def|fn|fun|func
      |class|enum|module|package|inter|struct|object|record
      |frag|space|data|trait|proto|proc|macro|type|given
      |raw|style|compo|element|decl|ext|impl|sub

      |if|lest|elif|elest|else|then
      |for|each|loop|while|until|from|with
      |do|redo|try|retry|throw|catch|finally
      |switch|case|default|match|when|otherwise
      |unison|series|spawn|kill|fix|lock
      |break|continue|return|await|label|yield|goto
      |import|export|impose|expose|using
      |debug|check|assert|fallthru
      )\b)\s*)
      (\|)
      (?!\|)
    captures:
      1: {name: punctuation.separator.arguments.trin}
    end: (?<!\|)(\|)(?!\|)
    patterns:
      - include: "#function-params"

  clauses:
    patterns:
      - include: "#macro-call"
      - include: "#params-clause"
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      macro-call:
        match: (?x)\s*\b([\p{Pc}\p{L}]\w*)\b(?=[\\'"])
        name: entity.name.function.tagged-template.trin

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.trin}
        patterns:
          - include: "#function-params"

      method-clause:
        patterns:
          - begin: |
              (?x)(?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              (
              (?:
              (?:# access modifiers
              pub|priv|prot|inline|final|mut|immut
              |seal|abs|intern|extern|imp|exp|glo|loc

              # concurrency modifiers
              |a?sync|stat|dyn|lazy|eager|strong|weak
              |vola|unsafe|unfix|bound|free|opaque|trans

              # property or method modifiers
              |re|gen|oper|[gs]et|early|late
              |prefix|suffix|infix|primary|unary
              |# Decorators
              @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
              )\s*\b)*
              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.method.trin}
              2: {name: keyword.operator.assignment.trin}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.trin}
            endCaptures:
              1: {name: punctuation.separator.arguments.trin}
            patterns:
              - include: "#function-params"
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)\s*(?<=[!?~]?\.=?|[?!:]:=?)(?<!\.\.+)
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              ((?:
              \s*(?:
              (?:# access modifiers
              pub|priv|prot|inline|final|mut|immut
              |seal|abs|intern|extern|imp|exp|glo|loc

              # concurrency modifiers
              |a?sync|stat|dyn|lazy|eager|strong|weak
              |vola|unsafe|unfix|bound|free|opaque|trans

              # property or method modifiers
              |re|gen|oper|[gs]et|early|late
              |prefix|suffix|infix|primary|unary
              |# Decorators
              @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
              ))
              \s*)*)
              (?=\s*\b
              (?:
              def|func?
              )\b
              )
            captures:
              1: {name: entity.name.function.method.trin}
              2: {name: keyword.operator.assignment.trin}
              3: {patterns: *modifier-keywords}

      function-clause:
        patterns:
          - begin: |
              (?x)\s*
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              (
              (?:
              (?:# access modifiers
              pub|priv|prot|inline|final|mut|immut
              |seal|abs|intern|extern|imp|exp|glo|loc

              # concurrency modifiers
              |a?sync|stat|dyn|lazy|eager|strong|weak
              |vola|unsafe|unfix|bound|free|opaque|trans

              # property or method modifiers
              |re|gen|oper|[gs]et|early|late
              |prefix|suffix|infix|primary|unary
              |# Decorators
              @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
              )\s*\b)*
              )\s*
              (\|)
              (?!\|)
            end: (?<!\|)(\|)(?!\|)
            beginCaptures:
              1: {name: entity.name.function.trin}
              2: {name: keyword.operator.assignment.trin}
              3: {patterns: *modifier-keywords}
              4: {name: punctuation.separator.arguments.trin}
            endCaptures:
              1: {name: punctuation.separator.arguments.trin}
            patterns:
              - include: "#function-params"
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([\p{Pc}\p{L}]\w*)\s+
              ([?:]?=)\s+
              ((?:
              \s*(?:
              (?:# access modifiers
              pub|priv|prot|inline|final|mut|immut
              |seal|abs|intern|extern|imp|exp|glo|loc

              # concurrency modifiers
              |a?sync|stat|dyn|lazy|eager|strong|weak
              |vola|unsafe|unfix|bound|free|opaque|trans

              # property or method modifiers
              |re|gen|oper|[gs]et|early|late
              |prefix|suffix|infix|primary|unary
              |# Decorators
              @[\p{Pc}\p{L}]\w*(?:(?:\.|::)[\p{Pc}\p{L}])*\s*
              ))
              \s*)*)
              (?=\s*\b
              (?:
              def|func?
              )\b
              )
            captures:
              1: {name: entity.name.function.trin}
              2: {name: keyword.operator.assignment.trin}
              3: {patterns: *modifier-keywords}

      new-clause:
        applyEndPatternLast: 1
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(new)\b
        end: (?=.)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.trin}
        patterns:
          - match: *entity-name
            name: entity.name.instance.trin
          - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(is|as)\b\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.trin}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(type)\b\s*
            end: (?=.)|$
            beginCaptures:
              1: {name: keyword.other.typedef.trin}
            patterns:
              - match: \s*([?:]?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.trin}
              - include: "#types"

      case-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(case|default)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        beginCaptures:
          1: {name: keyword.control.switch.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      catch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(try|retry|throw|catch|finally)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.catch.trin
        beginCaptures:
          1: {name: keyword.control.error.trin}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
                name: keyword.control.error.trin
              - include: "#code-block"
              - include: $self
          - match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b
            name: keyword.control.error.trin
          - include: "#code-block"
          - include: $self

      thread-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(unison|series|spawn|kill|fix|lock)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.thread.trin
        beginCaptures:
          1: {name: keyword.control.thread.trin}
        patterns:
          - &thread-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.thread.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *thread-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      do-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(do|redo)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.do.trin
        beginCaptures:
          1: {name: keyword.control.do.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      for-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(for|each|loop|while|until)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.for.trin
        beginCaptures:
          1: {name: keyword.control.loop.trin}
        patterns:
          - &for-clause-keywords
            match: \s*\b(in|of)\b
            name: keyword.control.loop.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *for-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

      if-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(if|lest|elif|elest|else)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.if.trin
        beginCaptures:
          1: {name: keyword.control.conditional.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      match-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(match)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.match.trin
        beginCaptures:
          1: {name: keyword.control.match.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      switch-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(switch)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.switch.trin
        beginCaptures:
          1: {name: keyword.control.switch.trin}
        patterns:
          - include: "#code-block"
          - include: $self

      when-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(when|otherwise)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        beginCaptures:
          1: {name: keyword.control.match.trin}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - include: "#type-operators"
              - include: "#code-block"
              - include: $self
          - include: "#type-operators"
          - include: "#code-block"
          - include: $self

      with-clause:
        begin: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(with)\b\s*
        end: (?<=})|(?=;|(?<=\s)(?:=>|(?<!(?:(?<!\.)\.|[?!:]:)=?)\bthen\b)|$)
        name: meta.with.trin
        beginCaptures:
          1: {name: keyword.control.with.trin}
        patterns:
          - &with-clause-keywords
            match: (?x)\s*(?<!(?:(?<!\.)\.|[?!:]:)=?)\b(as)\b\s*
            name: keyword.control.with.trin
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.trin}
            patterns:
              - *with-clause-keywords
              - include: "#code-block"
              - include: $self
          - include: "#code-block"
          - include: $self

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#semicolon"

    repository:
      line-continuation:
        match: (\\)\s*(?=/[/*+]|$)
        name: punctuation.separator.continuation.line.trin
      comma:
        match: \s*(,)
        name: punctuation.separator.comma.trin
      right-arrow:
        match: (?:^|['"`\\({\[\s]*)(=>)(?:$|['"`\\\s)}\]])
        name: punctuation.definition.arrow.trin}
      double-semi:
        match: \s*(;;)
        name: punctuation.terminator.expression.trin
      semicolon:
        match: \s*(;)
        name: punctuation.terminator.statement.trin

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#code-block"
      - include: "#square-brackets"
      - include: "#round-brackets"

  code-block:
    patterns:
      - begin: (\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.section.class.trin}
        patterns:
          - include: $self
      - begin: (\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.block.trin}
        patterns:
          - include: $self

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.trin
          - match: (?<!\s):(?!:)
            name: punctuation.separator.key-value.trin
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.typeparameters.trin}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(?<=\b(?:va[rl]|[lsg]et)\b\s*)(\#?\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.binding-pattern.object.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\p{S}\p{P}&&[^,;'"`\\p{Pc}({\[)}\]]]+|^|[({\[])(?<![\w,;'"`)}\]]\||\s=>)\s*(\#\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.mapping.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\p{S}\p{P}&&[^,;'"`\\p{Pc}({\[)}\]]]+|^|[({\[])(?<![\w,;'"`)}\]]\||\s=>)\s*(\{)\s*
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.trin
      function-params:
        patterns: *function-params
    patterns:
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.)(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.trin}
        patterns:
          - include: "#punctuation"
          - include: "#function-params"
          - include: $self
      - begin: \s*(\#?\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.trin}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<![\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)(:)(?![\p{S}\p{P}&&[^,;'"`\\\p{Pc}({\[)}\]]]+)
            captures:
              1: {name: punctuation.separator.slice.trin}
          - match: ","
            name: punctuation.separator.sequence.trin
    patterns:
      - begin: \s*(?<=\b(?:va[rl]|[lsg]et)\b\s*)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.binding-pattern.array.trin}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(?<=[\w'"`)}\]]|[^.]\.)(\#?\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.attribute-selector.trin}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\#\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.sequence.trin}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\[)\s*
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.trin}
        patterns:
          - include: "#punctuation"
          - include: $self

  support-js:
    patterns:
      - begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          2: {name: support.class.builtin.js}
          4: {name: keyword.operator.accessor.js}
          5: {name: support.class.builtin.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<=\.)\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.function.mutator.js}
        patterns:
          - include: "#round-brackets"
      - begin: (?<!\.)\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.error.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(debugger)\b
        captures:
          1: {name: keyword.other.js}
      - match: (?<!\.)\s*+\b(document|window)\b
        captures:
          1: {name: support.type.object.dom.js}
      - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
        captures:
          1: {name: support.constant.dom.js}
      - begin: (?<!\.)\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.console.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.console.js}
        patterns:
          - include: "#round-brackets"
      - match: (?<!\.)\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
        captures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.process.js}
      - begin: (?<!\.)\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.type.object.process.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.function.process.js}
        patterns:
          - include: "#round-brackets"
      - match: (((?<!\.)\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
        captures:
          1: {name: support.type.object.module.js}
          2: {name: keyword.operator.accessor.js}
          3: {name: support.type.object.module.js}
      - match: (?<!\.)\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
        captures:
          1: {name: support.type.object.node.js}
      - begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
        end: (?=.)
        applyEndPatternLast: 1
        beginCaptures:
          1: {name: support.class.node.js}
        patterns:
          - include: "#round-brackets"
      - match: |-
          (?<=\.|::)\s*\b
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: |-
          (?x)(?<=\.|::)\s*\b
          (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName
          |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop
          |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor
          |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption
          |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear
          |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete
          |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset
          |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
          |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
          |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
          |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
          |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
          |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
          |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
          |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
          |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
          |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
          |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
          |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
          |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
          |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
          |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
          |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
          |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
          |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
          |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
          \b\s*(?!\()
        name: support.variable.property.dom.js
      - match: (?x)(?<=\.|::)\s*\b(module|exports|id|filename|loaded|parent|children)\b\s*
        name: support.type.object.module.js

  named-chars-database:
    patterns:
      - comment: Yes this is a bit ridiculous, there are quite a lot of these
        name: constant.character.html.trin
        match: (?x)\b(A(Elig|MP|acute|breve|c(irc|y)|fr|grave|lpha|macr|nd|o(gon|pf)|pplyFunction|ring|s(cr|sign)|tilde|uml)|B(a(ckslash|r(wed|v))|cy|e(cause|rnoullis|ta)|fr|opf|reve|scr|umpeq)|C(Hcy|OPY|a(cute|p(italDifferentialD)?|yleys)|c(aron|edil|irc|onint)|dot|e(dilla|nterDot)|fr|hi|ircle(Dot|Minus|Plus|Times)|lo(ckwiseContourIntegral|seCurly(DoubleQuote|Quote))|o(lone?|n(gruent|int|tourIntegral)|p(roduct|f)|unterClockwiseContourIntegral)|ross|scr|up(Cap)?)|D(D(otrahd)?|Jcy|Scy|Zcy|a(gger|rr|shv)|c(aron|y)|el(ta)?|fr|i(a(critical(Acute|Do(ubleAcute|t)|Grave|Tilde)|mond)|fferentialD)|o(pf|t((Dot|Equal))?|uble(ContourIntegral|Do(wnArrow|t)|L(eft(Arrow|RightArrow|Tee)|ong(Left(Arrow|RightArrow)|RightArrow))|Right(Arrow|Tee)|Up(Arrow|DownArrow)|VerticalBar)|wn(Arrow((Bar|UpArrow))?|Breve|Left(RightVector|TeeVector|Vector(Bar)?)|Right(TeeVector|Vector(Bar)?)|Tee(Arrow)?|arrow))|s(cr|trok))|E(NG|TH|acute|c(aron|irc|y)|dot|fr|grave|lement|m(acr|pty(SmallSquare|VerySmallSquare))|o(gon|pf)|psilon|qu(al(Tilde)?|ilibrium)|s(cr|im)|ta|uml|x(ists|ponentialE))|F(cy|fr|illed(SmallSquare|VerySmallSquare)|o(pf|rAll|uriertrf)|scr)|G(Jcy|ammad?|breve|c(edil|irc|y)|dot|fr|opf|reater(Equal(Less)?|FullEqual|Greater|Less|SlantEqual|Tilde)|scr|[Tgt])|H(ARDcy|a(cek|t)|circ|fr|ilbertSpace|o(pf|rizontalLine)|s(cr|trok)|ump(DownHump|Equal))|I(Ecy|Jlig|Ocy|acute|c(irc|y)|dot|fr|grave|m((a(cr|ginaryI)|plies))?|n(t(e(gral|rsection))?|visible(Comma|Times))|o(gon|pf|ta)|scr|tilde|u(kcy|ml))|J(c(irc|y)|fr|opf|s(cr|ercy)|ukcy)|K(Hcy|Jcy|appa|c(edil|y)|fr|opf|scr)|L(Jcy|a(cute|mbda|ng|placetrf|rr)|c(aron|edil|y)|e(ft(A(ngleBracket|rrow((Bar|RightArrow))?)|Ceiling|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Floor|Right(Arrow|Vector)|T(ee((Arrow|Vector))?|riangle((Bar|Equal))?)|Up(DownVector|TeeVector|Vector(Bar)?)|Vector(Bar)?|arrow|rightarrow)|ss(EqualGreater|FullEqual|Greater|Less|SlantEqual|Tilde))|fr|l(eftarrow)?|midot|o(ng(Left(Arrow|RightArrow)|RightArrow|left(arrow|rightarrow)|rightarrow)|pf|wer(LeftArrow|RightArrow))|s(cr|trok|h)|[Tt])|M(ap|cy|e(diumSpace|llintrf)|fr|inusPlus|opf|scr|u)|N(Jcy|acute|c(aron|edil|y)|e(gative(MediumSpace|Thi(ckSpace|nSpace)|VeryThinSpace)|sted(GreaterGreater|LessLess)|wLine)|fr|o(Break|nBreakingSpace|pf|t((C(ongruent|upCap)|DoubleVerticalBar|E(lement|qual(Tilde)?|xists)|Greater((Equal|FullEqual|Greater|Less|SlantEqual|Tilde))?|Hump(DownHump|Equal)|Le(ftTriangle((Bar|Equal))?|ss((Equal|Greater|Less|SlantEqual|Tilde))?)|Nested(GreaterGreater|LessLess)|Precedes((Equal|SlantEqual))?|R(everseElement|ightTriangle((Bar|Equal))?)|S(quareSu(bset(Equal)?|perset(Equal)?)|u(bset(Equal)?|cceeds((Equal|SlantEqual|Tilde))?|perset(Equal)?))|Tilde((Equal|FullEqual|Tilde))?|VerticalBar))?)|scr|tilde|u)|O(Elig|acute|c(irc|y)|dblac|fr|grave|m(acr|ega|icron)|opf|penCurly(DoubleQuote|Quote)|s(cr|lash)|ti(lde|mes)|uml|ver(B(ar|rac(ket|e))|Parenthesis)|r)|P(artialD|cy|fr|hi|lusMinus|o(incareplane|pf)|r((ecedes((Equal|SlantEqual|Tilde))?|ime|o(duct|portion(al)?)))?|s(cr|i)|i)|Q(UOT|fr|opf|scr)|R(Barr|EG|a(cute|ng|rr(tl)?)|c(aron|edil|y)|e(verse(E(lement|quilibrium)|UpEquilibrium))?|fr|ho|ight(A(ngleBracket|rrow((Bar|LeftArrow))?)|Ceiling|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Floor|T(ee((Arrow|Vector))?|riangle((Bar|Equal))?)|Up(DownVector|TeeVector|Vector(Bar)?)|Vector(Bar)?|arrow)|o(pf|undImplies)|rightarrow|s(cr|h)|uleDelayed)|S(H(CHcy|cy)|OFTcy|acute|c((aron|edil|irc|y))?|fr|hort(DownArrow|LeftArrow|RightArrow|UpArrow)|igma|mallCircle|opf|q(rt|uare((Intersection|Su(bset(Equal)?|perset(Equal)?)|Union))?)|scr|tar|u(b(set(Equal)?)?|c(ceeds((Equal|SlantEqual|Tilde))?|hThat)|p((erset(Equal)?|set))?|m))|T(HORN|RADE|S(Hcy|cy)|a[bu]|c(aron|edil|y)|fr|h(e(refore|ta)|i(ckSpace|nSpace))|ilde((Equal|FullEqual|Tilde))?|opf|ripleDot|s(cr|trok))|U(a(cute|rr(ocir)?)|br(cy|eve)|c(irc|y)|dblac|fr|grave|macr|n(der(B(ar|rac(ket|e))|Parenthesis)|ion(Plus)?)|o(gon|pf)|p(Arrow((Bar|DownArrow))?|DownArrow|Equilibrium|Tee(Arrow)?|arrow|downarrow|per(LeftArrow|RightArrow)|si(lon)?)|ring|scr|tilde|uml)|V(Dash|bar|cy|dashl?|e(r(bar|t(ical(Bar|Line|Separator|Tilde))?|yThinSpace)|e)|fr|opf|scr|vdash)|W(circ|edge|fr|opf|scr)|X(fr|opf|scr|i)|Y(Acy|Icy|Ucy|acute|c(irc|y)|fr|opf|scr|uml)|Z(Hcy|acute|c(aron|y)|dot|e(roWidthSpace|ta)|fr|opf|scr)|a(acute|breve|c((irc|ute|[Edy]))?|elig|fr?|grave|l(e(fsym|ph)|pha)|m(a(cr|lg)|p)|n(d((and|slope|[dv]))?|g((le|msd(a[a-h])?|rt(vbd?)?|s(ph|t)|zarr|e))?)|o(gon|pf)|p((acir|id|os|prox(eq)?|[Ee]))?|ring|s(cr|ymp(eq)?|t)|tilde|uml|w(conint|int))|b(Not|a(ck(cong|epsilon|prime|sim(eq)?)|r(vee|wed(ge)?))|brk(tbrk)?|c(ong|y)|dquo|e(cause?|mptyv|psi|rnou|t(ween|[ah]))|fr|ig(c(ap|irc|up)|o(dot|plus|times)|s(qcup|tar)|triangle(down|up)|uplus|vee|wedge)|karow|l(a(ck(lozenge|square|triangle((down|left|right))?)|nk)|k(1[24]|34)|ock)|n(e(quiv)?|ot)|o(pf|t(tom)?|wtie|x(D[LRlr]|H[DUdu]?|U[LRlr]|V[HLRhlr]?|box|d[LRlr]|h[DUdu]?|minus|plus|times|u[LRlr]|v[HLRhlr]?))|prime|r(eve|vbar)|s(cr|emi|ime?|ol((hsub|b))?)|u(ll(et)?|mp((eq?|E))?))|c(a(cute|p((and|brcup|c(ap|up)|dot|s))?|r(et|on))|c(a(ps|ron)|edil|irc|ups(sm)?)|dot|e(dil|mptyv|nt(erdot)?)|fr|h(cy|eck(mark)?|i)|ir((c((eq|le(arrow(left|right)|d(ast|circ|dash|[RS]))))?|fnint|mid|scir|[Ee]))?|lubs(uit)?|o(lon(eq?)?|m(mat?|p((fn|le(ment|xes)))?)|n(g(dot)?|int)|p(rod|y(sr)?|f))|r(arr|oss)|s(cr|u(be?|pe?))|tdot|u(darr[lr]|e(pr|sc)|larrp?|p((brcap|c(ap|up)|dot|or|s))?|r(arrm?|ly(eq(prec|succ)|vee|wedge)|ren|vearrow(left|right))|vee|wed)|w(conint|int)|ylcty)|d(Arr|Har|a(gger|leth|rr|shv?)|b(karow|lac)|c(aron|y)|d((a(gger|rr)|otseq))?|e(lta|mptyv|g)|f(isht|r)|har[lr]|i(am((ond(suit)?|s))?|gamma|sin|v((ide(ontimes)?|onx))?|e)|jcy|lc(orn|rop)|o(llar|pf|t((eq(dot)?|minus|plus|square))?|ublebarwedge|wn(arrow|downarrows|harpoon(left|right)))|r(bkarow|c(orn|rop))|s(c[ry]|ol|trok)|t(dot|rif?)|u(arr|har)|wangle|z(cy|igrarr))|e(D(Dot|ot)|a(cute|ster)|c(aron|irc?|olon|y)|dot|f(Dot|r)|g((rave|s(dot)?))?|l((inters|s(dot)?|l))?|m(acr|pty((set|v))?|sp(1[34])?)|n(sp|g)|o(gon|pf)|p(ar(sl)?|lus|si((lon|v))?)|q(c(irc|olon)|s(im|lant(gtr|less))|u(als|est|iv(DD)?)|vparsl)|r(Dot|arr)|s(cr|dot|im)|t[ah]|u(ml|ro)|x(cl|ist|p(ectation|onentiale))|e)|f(allingdotseq|cy|emale|f(ilig|l(ig|lig)|r)|ilig|jlig|l(at|lig|tns)|nof|o(pf|r(all|kv?))|partint|r(a(c(1[2-68]|2[35]|3[458]|45|5[68]|78)|sl)|own)|scr)|g(El?|a(cute|mmad?|p)|breve|c(irc|y)|dot|e((q((slant|q))?|s((cc|dot(ol?)?|l(es)?))?|l))?|fr|gg?|imel|jcy|l[Eaj]?|n(ap(prox)?|e(qq?)?|sim|E)|opf|rave|s(cr|im[el]?)|t((c(ir|c)|dot|lPar|quest|r(a(pprox|rr)|dot|eq(less|qless)|less|sim)))?|v(ertneqq|nE))|h(Arr|a(irsp|lf|milt|r(dcy|r((cir|w))?))|bar|circ|e(arts(uit)?|llip|rcon)|fr|ks(earow|warow)|o(arr|mtht|ok(leftarrow|rightarrow)|pf|rbar)|s(cr|lash|trok)|y(bull|phen))|i(acute|c((irc|y))?|e(cy|xcl)|f[fr]|grave|i((i(int|nt)|nfin|ota))?|jlig|m(a(cr|g(line|part|e)|th)|of|ped)|n((care|fin(tie)?|odot|t((cal|e(gers|rcal)|larhk|prod))?))?|o(cy|gon|pf|ta)|prod|quest|s(cr|in((dot|sv?|[Ev]))?)|t(ilde)?|u(kcy|ml))|j(c(irc|y)|fr|math|opf|s(cr|ercy)|ukcy)|k(appav?|c(edil|y)|fr|green|hcy|jcy|opf|scr)|l(A(arr|rr|tail)|Barr|Eg?|Har|a(cute|emptyv|gran|mbda|ng((le|d))?|quo|rr((b(fs)?|fs|hk|lp|pl|sim|tl))?|t((ail|es?))?|p)|b(arr|brk|r(ac[ek]|k(sl[du]|e)))|c(aron|e(dil|il)|ub|y)|d(ca|quor?|r(dhar|ushar)|sh)|e((ft(arrow(tail)?|harpoon(down|up)|leftarrows|right(arrows?|harpoons|squigarrow)|threetimes)|q((slant|q))?|s((cc|dot(or?)?|g(es)?|s(approx|dot|eq(gtr|qgtr)|gtr|sim)))?|g))?|f(isht|loor|r)|gE?|h(ar(ul?|d)|blk)|jcy|l((arr|corner|hard|tri))?|m(idot|oust(ache)?)|n(ap(prox)?|e(qq?)?|sim|E)|o(a(ng|rr)|brk|ng(left(arrow|rightarrow)|mapsto|rightarrow)|oparrow(left|right)|p(ar|lus|f)|times|w(ast|bar)|z((enge|f))?)|par(lt)?|r(arr|corner|hard?|tri|m)|s(aquo|cr|im[eg]?|q(uor?|b)|trok|h)|t((c(ir|c)|dot|hree|imes|larr|quest|r(Par|i[ef]?)))?|ur(dshar|uhar)|v(ertneqq|nE))|m(DDot|a(cr|l(t(ese)?|e)|p(sto((down|left|up))?)?|rker)|c(omma|y)|dash|easuredangle|fr|ho|i(cro|d((ast|cir|dot))?|nus((du?|b))?)|l(cp|dr)|nplus|o(dels|pf)|s(cr|tpos)|u((ltimap|map))?|p)|n(G(tv?|g)|L(eft(arrow|rightarrow)|tv?|l)|Rightarrow|V(Dash|dash)|a(bla|cute|ng|p((id|os|prox|E))?|tur(als?)?)|b(sp|umpe?)|c(a(ron|p)|edil|ong(dot)?|up|y)|dash|e((Arr|ar(hk|r(ow)?)|dot|quiv|s(ear|im)|xists?))?|fr|g(e((q((slant|q))?|s))?|sim|tr?|E)|h(Arr|arr|par)|i((sd?|v))?|jcy|l(Arr|arr|dr|e((ft(arrow|rightarrow)|q((slant|q))?|ss?))?|sim|t(rie?)?|E)|mid|o(pf|t((in((dot|v[a-c]|E))?|ni(v[a-c])?))?)|p(ar((allel|sl|t))?|olint|r((cue|e(c(eq)?)?))?)|r(Arr|arr[cw]?|ightarrow|trie?)|s(c((cue|[er]))?|hort(mid|unison)|im(eq?)?|mid|par|qsu(be|pe)|u(b((set(eqq?)?|[Ee]))?|cc(eq)?|p((set(eqq?)?|[Ee]))?))|t(gl|ilde|lg|riangle(left(eq)?|right(eq)?))|u(m((ero|sp))?)?|v(Dash|Harr|ap|dash|g[et]|infin|l(Arr|t(rie)?|e)|r(Arr|trie)|sim)|w(Arr|ar(hk|r(ow)?)|near))|o(a(cute|st)|c(irc?|y)|d(ash|blac|iv|ot|sold)|elig|f(cir|r)|g(on|rave|t)|h(bar|m)|int|l(arr|c(ir|ross)|ine|t)|m(acr|ega|i(cron|nus|d))|opf|p(ar|erp|lus)|r((arr|d((er(of)?|[fm]))?|igof|or|slope|v))?|s(cr|lash|ol)|ti(lde|mes(as)?)|uml|vbar|S)|p(ar((a(llel)?|s(im|l)|t))?|cy|er(cnt|iod|mil|tenk|p)|fr|h(iv?|mmat|one)|i((tchfork|v))?|l(an(ckh?|kv)|us((acir|cir|d[ou]|mn|sim|two|[be]))?)|o(intint|pf|und)|r((ap|cue|e(c((approx|curlyeq|eq|n(approx|eqq|sim)|sim))?)?|imes?|n(ap|sim|E)|o(f(alar|line|surf)|p(to)?|d)|sim|urel|E))?|s(cr|i)|uncsp|m)|q(fr|int|opf|prime|scr|u(at(ernions|int)|est(eq)?|ot))|r(A(arr|rr|tail)|Barr|Har|a(c(ute|e)|dic|emptyv|ng((le|[de]))?|quo|rr((ap|b(fs)?|fs|hk|lp|pl|sim|tl|[cw]))?|t(ail|io(nals)?))|b(arr|brk|r(ac[ek]|k(sl[du]|e)))|c(aron|e(dil|il)|ub|y)|d(ca|ldhar|quor?|sh)|e(al((ine|part|s))?|ct|g)|f(isht|loor|r)|h(ar(ul?|d)|ov?)|i(ght(arrow(tail)?|harpoon(down|up)|left(arrows|harpoons)|rightarrows|squigarrow|threetimes)|ng|singdotseq)|l(arr|har|m)|moust(ache)?|nmid|o(a(ng|rr)|brk|p(ar|lus|f)|times)|p(ar(gt)?|polint)|rarr|s(aquo|cr|q(uor?|b)|h)|t(hree|imes|ri((ltri|[ef]))?)|uluhar|x)|s(acute|bquo|c((a(ron|p)|cue|e(dil)?|irc|n(ap|sim|E)|polint|sim|[Ey]))?|dot[be]?|e(Arr|ar(hk|r(ow)?)|ct|mi|swar|tm(inus|n)|xt)|fr(own)?|h(arp|c(hcy|y)|ort(mid|unison)|y)|i(gma[fv]?|m((dot|eq?|gE?|lE?|ne|plus|rarr))?)|larr|m(a(llsetminus|shp)|eparsl|i(le|d)|t(es?)?)|o(ftcy|l(b(ar)?)?|pf)|pa(des(uit)?|r)|q(c(aps?|ups?)|su(b((set(eq)?|e))?|p((set(eq)?|e))?)|u((ar[ef]|f))?)|rarr|s(cr|etmn|mile|tarf)|t(arf?|r(aight(epsilon|phi)|ns))|u(b((dot|e(dot)?|mult|n[Ee]|plus|rarr|s(et((eqq?|neqq?))?|im|u[bp])|E))?|cc((approx|curlyeq|eq|n(approx|eqq|sim)|sim))?|ng|p((d(ot|sub)|e(dot)?|hs(ol|ub)|larr|mult|n[Ee]|plus|s(et((eqq?|neqq?))?|im|u[bp])|[1-3E]))?|m)|w(Arr|ar(hk|r(ow)?)|nwar)|zlig)|t(a(rget|u)|brk|c(aron|edil|y)|dot|elrec|fr|h(e(re(fore|4)|ta((sym|v))?)|i(ck(approx|sim)|nsp)|k(ap|sim)|orn)|i(lde|mes((b(ar)?|d))?|nt)|o(ea|p((bot|cir|f(ork)?))?|sa)|prime|r(ade|i(angle((down|left(eq)?|right(eq)?|q))?|dot|minus|plus|sb|time|e)|pezium)|s(c[ry]|hcy|trok)|w(ixt|ohead(leftarrow|rightarrow)))|u(Arr|Har|a(cute|rr)|br(cy|eve)|c(irc|y)|d(arr|blac|har)|f(isht|r)|grave|h(ar[lr]|blk)|l(c(orn(er)?|rop)|tri)|m(acr|l)|o(gon|pf)|p(arrow|downarrow|harpoon(left|right)|lus|si((lon|h))?|uparrows)|r(c(orn(er)?|rop)|ing|tri)|scr|t(dot|ilde|rif?)|u(arr|ml)|wangle)|v(Arr|Barv?|Dash|a(ngrt|r(epsilon|kappa|nothing|p(hi|ropto|i)|r(ho)?|s(igma|u(bsetneqq?|psetneqq?))|t(heta|riangle(left|right))))|cy|dash|e(e((bar|eq))?|llip|r(bar|t))|fr|ltri|nsu[bp]|opf|prop|rtri|s(cr|u(bn[Ee]|pn[Ee]))|zigzag)|w(circ|e(d(bar|geq?)|ierp)|fr|opf|r(eath)?|scr|p)|x(c(ap|irc|up)|dtri|fr|h(Arr|arr)|l(Arr|arr)|map|nis|o(dot|p(lus|f)|time)|r(Arr|arr)|s(cr|qcup)|u(plus|tri)|vee|wedge|i)|y(ac(ute|y)|c(irc|y)|en|fr|icy|opf|scr|u(cy|ml))|z(acute|c(aron|y)|dot|e(etrf|ta)|fr|hcy|igrarr|opf|scr|w(nj|j)))\b
      - comment: Yes this is a bit ridiculous, there are quite a lot of these
        match: (?x)\b(A((E(acute)?|acute|breve|circumflex|dieresis|grave|lpha(tonos)?|macron|ogonek|ring(acute)?|tilde))?|B(eta)?|C((acute|c(aron|edilla|ircumflex)|dotaccent|hi))?|D((c(aron|roat)|elta))?|E((acute|breve|c(aron|ircumflex)|d(ieresis|otaccent)|grave|macron|ng|ogonek|psilon(tonos)?|t(a(tonos)?|h)|uro))?|G((amma|breve|c(aron|ircumflex)|dotaccent))?|H((185(33|43|51)|22073|bar|circumflex))?|I((acute|breve|circumflex|d(ieresis|otaccent)|fraktur|grave|macron|o(gonek|ta((dieresis|tonos))?)|tilde|J))?|J(circumflex)?|K(appa)?|L((a(cute|mbda)|caron|dot|slash))?|Mu?|N((acute|caron|tilde|u))?|O((acute|breve|circumflex|dieresis|grave|h(orn|ungarumlaut)|m(acron|ega(tonos)?|icron(tonos)?)|slash(acute)?|tilde|E))?|P((hi|si|i))?|R((acute|caron|fraktur|ho))?|S((F(0(10000|20000|30000|40000|50000|60000|70000|80000|90000)|1(00000|10000|90000)|2(00000|10000|20000|30000|40000|50000|60000|70000|80000)|3(60000|70000|80000|90000)|4(00000|10000|20000|30000|40000|50000|60000|70000|80000|90000)|5(00000|10000|20000|30000|40000))|acute|c(aron|edilla|ircumflex)|igma))?|T((au|bar|caron|h(eta|orn)))?|U((acute|breve|circumflex|dieresis|grave|h(orn|ungarumlaut)|macron|ogonek|psilon((dieresis|tonos|1))?|ring|tilde))?|W((acute|circumflex|dieresis|grave))?|Xi?|Y((acute|circumflex|dieresis|grave))?|Z((acute|caron|dotaccent|eta))?|a((acute|breve|c(ircumflex|ute(comb)?)|dieresis|e(acute)?|grave|l(eph|pha(tonos)?)|m(acron|persand)|n(gle((left|right))?|oteleia)|ogonek|pproxequal|r(ing(acute)?|row(both|d(bl(both|down|left|right|up)|own)|left|right|up(dn(bse)?)?))|s(cii(circum|tilde)|terisk(math)?)|t(ilde)?))?|b((a(ckslash|r)|eta|lock|r(ac(e(left|right)|ket(left|right))|eve|okenbar)|ullet))?|c((a(cute|r(on|riagereturn))|c(aron|edilla|ircumflex)|dotaccent|e(dilla|nt)|hi|irc(le((multiply|plus))?|umflex)|lub|o(lon(monetary)?|mma|ngruent|pyright)|urrency))?|d((agger(dbl)?|c(aron|roat)|e(gree|lta)|i(amond|eresis(tonos)?|vide)|kshade|nblock|o(llar|ng|t(accent|belowcomb|lessi|math))))?|e((acute|breve|c(aron|ircumflex)|d(ieresis|otaccent)|grave|ight|l(ement|lipsis)|m(acron|dash|ptyset)|n(dash|g)|ogonek|psilon(tonos)?|qu(al|ivalence)|stimated|t(a(tonos)?|h)|x(clam(d(bl|own))?|istential)))?|f((emale|i(guredash|lled(box|rect)|ve(eighths)?)|lorin|our|ra(ction|nc)))?|g((amma|breve|c(aron|ircumflex)|dotaccent|ermandbls|r(a(dient|ve(comb)?)|eater(equal)?)|uil(lemot(left|right)|singl(left|right))))?|h((bar|circumflex|eart|o(okabovecomb|use)|ungarumlaut|yphen))?|i((acute|breve|circumflex|dieresis|grave|macron|n(finity|te(gral((bt|tp))?|rsection)|v(bullet|circle|smileface))|o(gonek|ta((dieresis(tonos)?|tonos))?)|tilde|j))?|j(circumflex)?|k((appa|greenlandic))?|l((a(cute|mbda)|caron|dot|ess(equal)?|fblock|ira|o(gical(and|not|or)|ngs|zenge)|slash|tshade))?|m((a(cron|le)|inu(te|s)|u((ltiply|sicalnote(dbl)?))?))?|n((a(cute|postrophe)|caron|ine|ot(e(lement|qual)|subset)|tilde|u(mbersign)?))?|o((acute|breve|circumflex|dieresis|g(onek|rave)|h(orn|ungarumlaut)|m(acron|ega((tonos|1))?|icron(tonos)?)|ne((dotenleader|eighth|half|quarter|third))?|penbullet|r(d(feminine|masculine)|thogonal)|slash(acute)?|tilde|e))?|p((ar(agraph|en(left|right)|tialdiff)|e(r(cent|iod(centered)?|pendicular|thousand)|seta)|hi1?|lus(minus)?|r(escription|o(duct|p(ersu(bset|perset)|ortional)))|si|i))?|q(u(estion(down)?|ote(dbl((base|left|right))?|left|r(eversed|ight)|singl(base|e))))?|r((a(cute|dical)|caron|e(flexsu(bset|perset)|gistered|vlogicalnot)|ho|ing|tblock))?|s((acute|c(aron|edilla|ircumflex)|e(c(ond|tion)|micolon|ven(eighths)?)|hade|i(gma1?|milar|x)|lash|mileface|pa(ce|de)|terling|u(chthat|mmation|n)))?|t((au|bar|caron|h(e(refore|ta1?)|orn|ree((eighths|quarters))?)|ilde(comb)?|onos|r(ademark|iag(dn|lf|rt|up))|wo((dotenleader|thirds))?))?|u((acute|breve|circumflex|dieresis|grave|h(orn|ungarumlaut)|macron|n(derscore(dbl)?|i(on|versal))|ogonek|p(block|silon((dieresis(tonos)?|tonos))?)|ring|tilde))?|w((acute|circumflex|dieresis|eierstrass|grave))?|xi?|y((acute|circumflex|dieresis|en|grave))?|z((acute|caron|dotaccent|e(ro|ta)))?|[FQVv])\b
        name: constant.character.aglfn.trin
